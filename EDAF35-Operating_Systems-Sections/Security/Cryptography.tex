\subsection{Cryptography}\label{subsec:Cryptography}
In an isolated computer, the \nameref{def:Operating_System} can reliably determine the sender and recipient of all interprocess communication, since it controls all communication channels in the computer.
In a network of computers, the situation is quite different.
A networked computer receives bits ``from the wire'' with no immediate and reliable way of determining what machine or application sent those bits.
Similarly, the computer sends bits onto the network with no way of knowing who might eventually receive them.
Additionally, there is no way of knowing if an eavesdropper listened to the communication.

It is generally considered infeasible to build a network of any scale in which the source and destination addresses of packets can be trusted in this sense.
Therefore, the only alternative is somehow to eliminate the need to trust the network.
This is the job of cryptography.

Cryptography enables a recipient of a message to verify that the message was created by some computer possessing a certain key.
Similarly, a sender can encode its message so that only a computer with a certain key can decode the message.
Keys are designed so that it is not computationally feasible to derive them from the messages they were used to generate or from any other public information.
Thus, they provide a much more trustworthy means of constraining senders and receivers of messages.

\begin{blackbox}
  For a greater in-depth discussion of cryptography and the mathematics, algorithms, and theory behind what is in use, please refer to \href{file:./EDIN01-Cryptography-Reference_Sheet.pdf}{EDIN01, Cryptography}.
\end{blackbox}

\subsubsection{Encryption}\label{subsubsec:Encryption}
Encryption is used frequently in many aspects of modern computing. It is used to send
messages securely across across a network, as well as to protect database data,
files, and even entire disks from having their contents read by unauthorized
entities. An encryption algorithm enables the sender of a message to ensure that
only a computer possessing a certain key can read the message, or ensure that
the writer of data is the only reader of that data.

An encryption algorithm consists of the following components:
\begin{itemize}[noitemsep]
\item A set $\Keyspace$ of keys.
\item A set $\Messages$ of messages.
\item A set $\Ciphertexts$ of ciphertexts.
\item An encrypting function $E : \Keyspace \rightarrow (\Messages \rightarrow \Ciphertexts)$.
  Meaning that for each $k \in \Keyspace$, $E_{k}$ is a function for generating ciphertexts from plaintext messages.
  Both $E$ and $E_{k}$ for any $k$ should be efficiently computable functions.
\item A decrypting function $D : \Keyspace \rightarrow (\Ciphertexts \rightarrow \Messages)$.
  That is, for each $k \in \Keyspace$, $D_{k}$ is a function for generating plaintext messages from ciphertexts.
  Both $D$ and $D_{k}$ for any $k$ should be efficiently computable functions.
\end{itemize}

An encryption algorithm must provide this essential property:
\begin{blackbox}
Given a ciphertext $c \in \Ciphertexts$, a computer can compute $m$ such that $E_{k}(m) = c$ only if it possesses $k$.
\end{blackbox}

Thus, a computer holding $k$ can decrypt ciphertexts to the plaintexts used to produce them, but a computer not holding $k$ cannot decrypt ciphertexts.
Since ciphertexts are generally exposed (for example, sent on a network), it must be infeasible to derive $k$ from the ciphertexts.

\paragraph{Symmetric Encryption}\label{par:Symmetric_Encryption}
\begin{definition}[Symmetric Encryption]\label{def:Symmetric_Encryption}
  \emph{Symmetric Encryption} uses algorithms that take in the \textbf{SAME} key for both encryption and decryption.
  There are 2 types of symmetric encryption algorithms: block ciphers and stream ciphers.
\end{definition}

In a \nameref{def:Symmetric_Encryption} algorithm, the same key is used to encrypt and to decrypt.
Therefore, the secrecy of k must be protected.
Note that the key exchange can take place directly between the two parties or via a trusted third party (such as a certificate authority).

Encryption algorithms that work on a block of bits at a time is known as a block cipher.
Block ciphers are not in themselves secure encryption schemes.
With block ciphers, if the same key is used for encrypting messages longer than their required block sizes extended amount of data, the encryption algorithm becomes vulnerable to attack.
However, there are many modes of encryption that are based on stream ciphers, which can be used to securely encrypt longer messages.

A stream cipher is designed to encrypt and decrypt a stream of bytes or bits rather than a block.
This is useful when the length of a communication would make a block cipher too slow.
The key is input into a pseudoâ€“random-bit generator, which is an algorithm that attempts to produce random bits.
The output of the generator when fed a key is a keystream.
A keystream is an infinite set of bits that can be used to encrypt a plaintext stream by simply XORing it with the plaintext.

\paragraph{Asymmetric Encryption}\label{par:Asymmetric_Encryption}
\begin{definition}[Asymmetric Encryption]\label{def:Asymmetric_Encryption}
  \emph{Asymmetric encryption} uses algorithms that can take in 2 keys, a public and private key.
  The public key is available to everyone in the world, and the private one is held by the one who generated the pair.
\end{definition}
In an \nameref{def:Asymmetric_Encryption} algorithm, there are different encryption and decryption keys.
An entity preparing to receive encrypted communication creates two keys and makes one of them (called the public key) available to anyone who wants it.
The private key (or ``secret key'') must remain secret, as anyone holding that key can decrypt any message created by the matching public key.
Any sender can use that key to encrypt a communication, but only the key creator can decrypt the communication.
This scheme, known as public-key encryption, was a breakthrough in cryptography.
No longer must a key be kept secret and delivered securely.
Instead, anyone can encrypt a message to the receiving entity, and no matter who else is listening, only that entity can decrypt the message.

Asymmetric cryptography is much more computationally expensive to execute.
It is much faster for a computer to encode and decode ciphertext using symmetric algorithms than by using asymmetric algorithms.
However, these algorithms are not used for general-purpose encryption of large amounts of data.
They are used not only for encryption of small amounts of data but also for \nameref{par:Authentication}, confidentiality, and \nameref{par:Key_Distribution}.

\paragraph{Authentication}\label{par:Authentication}
Constraining the set of potential senders of a message is called authentication.
Authentication is thus complementary to encryption.
Authentication is also useful for proving that a message has not been modified.

Note that this sort of authentication is similar to but distinct from \nameref{subsec:User_Authentication}.

An authentication algorithm using symmetric keys consists of the following components:
\begin{itemize}[noitemsep]
\item A set $\Keyspace$ of keys.
\item A set $\Messages$ of messages.
\item A set $\Authenticators$ of authenticators.
\item A function $S : \Keyspace \rightarrow (\Messages \rightarrow \Authenticators)$.
  That is, for each $k \in \Keyspace$, $S_{k}$ is a function for generating authenticators from messages.
  Both $S$ and $S_{k}$ for any $k$ should be efficiently computable functions.
\item A function $V : \Keyspace \rightarrow (\Messages \times \Authenticators \rightarrow \lbrace \mathtt{true}, \mathtt{false} \rbrace)$.
  That is, for each $k \in \Keyspace$, $V_{k}$ is a function for verifying authenticators on messages.
  Both $V$ and $V_{k}$ for any $k$ should be efficiently computable functions.
\end{itemize}

The critical property that an authentication algorithm must possess is this:
\begin{blackbox}
  For a message $m$, a computer can generate an authenticator $a \in \Authenticators$ such that $V_{k}(m, a) = \mathtt{true}$ only if it possesses $k$.
\end{blackbox}

Thus, a computer holding $k$ can generate authenticators on messages so that any computer possessing $k$ can verify them.
However, a computer not holding $k$ cannot generate authenticators on messages that can be verified using $V_{k}$.
Since authenticators are generally exposed (for example, sent on a network with the messages themselves), it must not be feasible to derive $k$ from the authenticators.
Practically, if $V_{k}(m, a) = \mathtt{true}$, then we know that $m$ has not been modified, and that the sender of the message has $k$.
If we share $k$ with only one entity, then we know that the message originated from $k$.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
