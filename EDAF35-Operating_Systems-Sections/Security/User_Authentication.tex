\subsection{User Authentication}\label{subsec:User_Authentication}
If a system cannot authenticate a user, then authenticating that a message came from that user is pointless.
Thus, a major security problem for operating systems is user authentication.
The protection system depends on the ability to identify the programs and processes currently executing, which in turn depends on the ability to identify each user of the system.

Users normally identify themselves.
So how do we determine whether a user’s identity is authentic?
Generally, user authentication is based on one or more of three things:
\begin{enumerate}[noitemsep]
\item The user’s possession of something (a key or card).
\item The user’s knowledge of something (a user identifier and password).
\item An attribute of the user (fingerprint, retina pattern, or signature).
\end{enumerate}

\subsubsection{Passwords}\label{subsubsec:User_Authentication_Passwords}
The most common approach to authenticating a user identity is the use of passwords.
When the user identifies themself by user ID or account name, they are asked for a password.
If the user-supplied password matches the password stored in the system, the system assumes that the account is being accessed by the owner of that account.
Passwords are often used to protect objects in the computer system, in the absence of more complete protection schemes.
They can be treated as a special case of keys or capabilities.
Different passwords may be associated with different access rights.
For example, different passwords may be used for reading files, appending files, and updating files.

In practice, most systems require only one password for a user to gain full rights.
Although more passwords theoretically would be more secure, such systems tend not to be implemented due to the classic trade-off between security and convenience.
If security makes something inconvenient, then the security is frequently bypassed or otherwise circumvented.

\subsubsection{Password Vulnerabilities}\label{subsubsec:Password_Vulnerabilities}
Passwords are extremely common because they are easy to understand and use.
Unfortunately, passwords can often be guessed, accidentally exposed, sniffed (read by an eavesdropper), or illegally transferred from an authorized user to an unauthorized one.
There are two common ways to guess a password.
\begin{enumerate}[noitemsep]
\item One way is for the intruder (either human or program) to know the user or to have information about the user.
  All too frequently, people use personal information as their passwords.
\item The other way is to use brute force, enumerating all possible combinations of valid password characters until the password is found.
\end{enumerate}

In addition to being guessed, passwords can be exposed as a result of
visual or electronic monitoring.

The final type of password compromise, illegal transfer, is the result of human nature.
Most computer installations have a rule that forbids users to share accounts.
This rule is sometimes implemented for accounting reasons but is often aimed at improving security.
Sometimes, users break account-sharing this behavior can result in a system’s being accessed by unauthorized users.

Passwords can be either generated by the system or selected by a user.
However, system-generated passwords may be difficult to remember.
Some systems also age passwords, forcing users to change their passwords at regular intervals.
This method is not foolproof either, because users can easily toggle between two passwords.
The solution, as implemented on some systems, is to record a password history for each user.

\subsubsection{Securing Passwords}\label{subsubsec:Securing_Passwords}
One problem with all these approaches is the difficulty of keeping the password secret within the computer.
How can the system store a password securely yet allow its use for authentication when the user presents her password?
The \textsc{unix} system uses secure hashing to avoid the necessity of keeping its password list secret.
Because the list is hashed rather than encrypted, it is impossible for the system to decrypt the stored value and determine the original password.
When a user presents a password, it is hashed and compared against the stored encoded password.
Even if the stored encoded password is seen, it cannot be decoded, so the password cannot be determined.

Systems also include a ``salt,'' or recorded random number, in the hashing algorithm.
The salt value is added to the password to ensure that if two plaintext passwords are the same, they result in different hash values.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
