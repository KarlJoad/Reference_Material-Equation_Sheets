\subsection{Segmentation}\label{subsec:Segmentation}
Dealing with memory in terms of its physical properties is inconvenient to both the \nameref{def:Operating_System} and the programmer.
If the hardware could provide a memory mechanism that mapped the programmerâ€™s view to the actual physical memory, the system would have more freedom to manage memory, while the programmer would have a more natural programming environment.
\nameref{def:Segmentation} provides such a mechanism.

\begin{definition}[Segmentation]\label{def:Segmentation}
  \emph{Segmentation} is a memory-management scheme that supports a programmer's view of memory of segments of a program.
  Each segment has a name and a length.
  Segments vary in length, and the length of each is intrinsically defined by its purpose in the program.
  Elements within a segment are identified by their offset from the beginning of the segment
  Therefore, when a programmer specifies something in the program, it is reached by an address by two quantities: a segment name and an offset.

  This makes a \nameref{def:Logical_Address_Space} is a collection of segments.
  These addresses specify both the segment name and the offset within the segment.

  \begin{remark}[Memory Locations when using Segmentation]\label{rmk:Segmentation_Memory_Locations}
    \nameref{def:Segmentation} is a method of breaking up a program into segments that behave as logical units in a program and are each referenced, and thus located, separately.
    This allows the \nameref{def:Physical_Address_Space} of a process to be noncontiguous.

    However, it makes no attempt to avoid \nameref{def:External_Fragmentation}.
  \end{remark}
\end{definition}

For example, a C compiler might create separate segments for:
\begin{enumerate}[noitemsep]
\item Code
\item Global variables
\item The heap, from which memory is allocated
\item The stacks used by each thread
\item The standard C library
\end{enumerate}

\subsubsection{Hardware Support for Segmentation}\label{subsubsec:Segmentation_Hardware_Support}
The values that the programmer specifies are now 2-dimensional objects, and a memory address is one-dimensional, so the \nameref{def:Memory_Management_Unit} must handle the mapping of these 2D \nameref{def:Logical_Address}es to the 1D \nameref{def:Physical_Address}es.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
