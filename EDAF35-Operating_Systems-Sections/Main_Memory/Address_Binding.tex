\subsection{Address Binding}\label{subsec:Address_Binding}
Just as in programming languages, there are different possible times when a \nameref{def:Program} stored on a disk can have \nameref{def:Memory} addresses bound to it, this is called \nameref{def:Address_Binding}.

\begin{definition}[Address Binding]\label{def:Address_Binding}
  \emph{Address binding} is the act of putting ``something'' (a variable, a function, a value, anything) at a location in \nameref{def:Memory}.
  Because these memory locations have unique addresses assigned to them, the ``something'' that was put there is bound to that memory address.
\end{definition}

For a \nameref{def:Program} to be executed, it must be brought into memory and placed within a \nameref{def:Process}.
The processes that are waiting for their binary images to be brought to memory from the disk before beginning execution form the \nameref{def:Input_Queue}.

\begin{definition}[Input Queue]\label{def:Input_Queue}
  The \emph{input queue} is the queue in which \nameref{def:Process}es are placed while they wait for their \nameref{def:Program} binary image to arrive from the disk.
\end{definition}

There are 3 major times when \nameref{def:Address_Binding} can occur:
\begin{enumerate}[noitemsep]
\item \nameref{subsubsec:Compile_Time_Address_Binding}
\item \nameref{subsubsec:Load_Time_Address_Binding}
\item \nameref{subsubsec:Execution_Time_Address_Binding}
\end{enumerate}

\subsubsection{Compile-Time Address Binding}\label{subsubsec:Compile_Time_Address_Binding}
If the addresses that the \nameref{def:Process} will use are known at compile-time, then \nameref{def:Absolute_Code} can be generated.

\begin{definition}[Absolute Code]\label{def:Absolute_Code}
  In \emph{absolute code}, the memory location of the \nameref{def:Process} is fixed during every execution, and because the \nameref{def:Program} is always the same size, anything that requires a memory can be referenced by this unchanging value.
\end{definition}

If, at some later time, the starting location changes, then the whole program must be recompiled.
In the case of assembly languages, this might mean recalculating the absolute memory locations of everything in the program.

These reasons led to the developement of relative addressing in assembly languages and the use of \nameref{subsubsec:Load_Time_Address_Binding}.

\subsubsection{Load-Time Address Binding}\label{subsubsec:Load_Time_Address_Binding}
If it is not known at compile time where the process will reside in memory, then the compiler must generate \nameref{def:Relocatable_Code}.

\begin{definition}[Relocatable Code]\label{def:Relocatable_Code}
  \emph{Relocatable code} uses relative addressing from certain known points.
  For example, a compiler will know that to access some variable \texttt{x}, the location where \texttt{x} is stored in memory is 14 bytes past the beginning of the function's start of the frame.
  Thus, if the starting address of the function changes, the code only needs to be reloaded to find a newly changed value.
\end{definition}

In this case, the final binding of ``stuff'' to memory addresses is delayed until load time.
If the starting address changes, the user code only needs to be reloaded to incorporate this changed value.
This is how most programs are written and executed.
If you change something in a C program, you must recompile and reload the program to have the changes take effect.

\subsubsection{Execution-Time Address Binding}\label{subsubsec:Execution_Time_Address_Binding}
If the process can be moved during its execution from one memory segment to another, then binding must be delayed until run time.
Special hardware must be available for this scheme to work.
Most general-purpose operating systems use this method.

There are 4 major items that affect how this works:
\begin{enumerate}[noitemsep]
\item \nameref{def:Dynamic_Loading}
\item \nameref{def:Dynamic_Linking}
\item \nameref{def:Swapping}
\item \nameref{def:Paging}
\end{enumerate}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
