\subsection{Contiguous Memory Allocation}\label{subsec:Contiguous_Memory_Allocation}
Main memory must contain everything for the system to run, including both the \nameref{def:Operating_System} and \nameref{def:User} \nameref{def:Process}es.
It is our jobs, as operating system engineers to make the allocation of memory for the \nameref{def:Operating_System} as efficient as possible.
The earliest and simplest method is that of \nameref{def:Contiguous_Memory_Allocation}.

Memory is usually divided into two partitions: one for the \nameref{def:Operating_System} and one for the user processes.
We can place the operating system in either low memory or high memory, depending on the location of the \nameref{def:Interrupt_Vector}.
Typically, the interrupt vector is in low addresses, so the OS is usually put there too.
Throughout this document, we assume that the OS inhabits the lowest addresses.

\begin{definition}[Contiguous Memory Allocation]\label{def:Contiguous_Memory_Allocation}
  In \emph{contiguous memory allocation}, each \nameref{def:Process} is contained in a single contiguous section of memory that is also contiguous with the next process.

  In short, this means that each \nameref{def:Process} sits in its own contiguous block and is right next to the next process.
\end{definition}

\subsubsection{Memory Protection}\label{subsubsec:Contiguous_Memory_Protection}
In \nameref{def:Contiguous_Memory_Allocation}, we can provide memory protection by using concepts from earlier.
If the \texttt{base} register is considered as the \texttt{relocation} register (because of \nameref{def:Logical_Address} conversion to \nameref{def:Physical_Address}), and use the \texttt{limit} register as before, then we can protect this \nameref{def:Process}.
Since the \nameref{def:Operating_System} is the only entity that can change the values of the \texttt{relocation} and \texttt{limit} registers, this (currently executing) process and others cannot interfere with each other.

When the \nameref{rmk:CPU_Scheduler} selects a \nameref{def:Process} for execution, the \nameref{def:Dispatcher} loads the \texttt{relocation} and \texttt{limit} registers with the correct values as part of the \nameref{def:Context_Switch}.
Because every address generated by a CPU is checked against these registers, we can protect the operating system and other usersâ€™ programs and data from being modified by this running process.
This scheme is an effective way to allow the \nameref{def:Operating_System} to change size dynamically, which is highly desireable.

\subsubsection{Memory Allocation}\label{subsubsec:Contiguous_Memory_Allocation}
Within the \nameref{def:User} memory, there are 2 main methods of \nameref{def:Process}-memory allocation:
\begin{enumerate}[noitemsep]
\item \nameref{par:Multiple_Partition_Scheme}
\item \nameref{par:Variable_Partition_Scheme}
\end{enumerate}

Both methods use the same idea of dividing all free memory into separate partitions, however the size of these partitions and how they are divided is the differentiating factor.

\paragraph{Multiple-Partition Scheme}\label{par:Multiple_Partition_Scheme}
In the \emph{multiple-partition scheme}, all free memory is statically divided into equal sized partitions.
Thus, the size of a partition is fixed throughout the execution of the \nameref{def:Operating_System}.
When a partition is free, a \nameref{def:Process} is selected from the input queue and placed into the free partition.
When the process terminates, the partition is returned to the pool of available partitions.

\paragraph{Variable-Partition Scheme}\label{par:Variable_Partition_Scheme}
In the \emph{variable-partition scheme}, all free memory is pooled together.
The free memory is called a \emph{hole}.

\begin{blackbox}
  In many ways, this mirrors the use of the heap in programs.
  Many of the principles from heap and the allocation of stuff to the heap also apply in this case as well.
\end{blackbox}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
