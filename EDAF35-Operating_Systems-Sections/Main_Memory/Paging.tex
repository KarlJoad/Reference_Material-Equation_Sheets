\subsection{Paging}\label{subsec:Paging}
Most memory-management schemes used before the introduction of \nameref{def:Paging} suffered from the problem of fitting memory chunks of varying sizes on the \nameref{def:Backing_Store}
This arises because space must be found on the backing store, when main memory needs to be swapped out.
The backing store has the same \nameref{def:Fragmentation} problems discussed in connection with main memory, but access is much slower, so compaction is impossible.

\begin{definition}[Paging]\label{def:Paging}
  \emph{Paging} allows the \nameref{def:Physical_Address_Space} of a \nameref{def:Process} to be noncontiguous.
  This is achieved breaking up \nameref{def:Physical_Memory} and \nameref{def:Logical_Address_Space} into equally, fixed-size blocks.
  \begin{itemize}[noitemsep]
  \item \nameref{def:Physical_Memory} is broken up into \emph{frames}.
  \item \nameref{def:Logical_Address_Space} is broken up into \emph{pages}.
  \item The \nameref{def:Backing_Store} is also broken up, as a multiple (1 through $n$) of the frame size.
  \end{itemize}

  Paging avoids the issue of \nameref{def:External_Fragmentation} and solves the problem of fitting memory chunks of varying sizes on the \nameref{def:Backing_Store}.
  However, \nameref{def:Internal_Fragmentation} is still an issue.
\end{definition}

\nameref{def:Paging} is implemented through cooperation between the operating system and the computer hardware.
Similar to how \nameref{def:Segmentation} has a segment table, \textbf{EACH \nameref{def:Process}} in a \nameref{def:Paging} system has a \nameref{def:Page_Table}.

\begin{definition}[Page Table]\label{def:Page_Table}
  A \emph{page table} is a table that maintains the mapping of logical pages to physical frames in memory.
  The page table is a simple lookup table, where the current \nameref{def:Process}'s current page number is also the value of the index.
  The value contained at that element is the location of the frame in memory.
  This is combined with the use of \nameref{def:Logical_Address}es that are generated by the CPU.\@
\end{definition}

To reach an address, the CPU generates a \nameref{def:Logical_Address} that has 2 parts, a page number $p$ and a page offset $d$.
Like before, the page number is used as an \textbf{INDEX} in the \nameref{def:Page_Table}.
The page table contains the base address of each page in physical memory.
This base address is combined with the page offset to define the physical memory address that is sent to the memory unit.

The frame size, and thus the page size, are defined by the hardware.
The size of a page is a power of 2, varying between 512 bytes and $\SI{1}{\gibi\byte}$\footnote{\si{\gibi\byte} is a gibibyte, or \si[prefixes-as-symbols=false]{\gibi} bytes} per page, depending on the computer architecture.
A power of 2 as a page size makes the translation of a \nameref{def:Logical_Address} into a page number and page offset particularly easy.

If the size of the logical address space is $2^{m}$, and a page size is $2^{n}$ bytes, then the high-order $m-n$ \textbf{bits} of a \nameref{def:Logical_Address} designate the page number, and the $n$ low-order \textbf{bits} designate the page offset.
\begin{equation}\label{eq:Page_Table_Calculations}
  \begin{aligned}
    p &= m-n \\
    d &= n \\
  \end{aligned}
\end{equation}

Thus, to translate the \nameref{def:Logical_Address} to a \nameref{def:Physical_Address}, \Cref{eq:Paging_Logical_Physical_Address_Conversion} is used.

\begin{equation}\label{eq:Paging_Logical_Physical_Address_Conversion}
  f = \bigl( i(p) \times s \bigr) + d
\end{equation}
\begin{description}[noitemsep]
\item $f$: Resulting \nameref{def:Physical_Address}.
\item $i(p)$: Mapped frame number of the given page number $p$ from the \nameref{def:Page_Table}.
\item $s$: Size of the page/frame.
\end{description}

If \nameref{def:Process} size is independent of page size, we expect \nameref{def:Internal_Fragmentation} to average one-half page per process.
This consideration suggests that small page sizes are desirable.
However, overhead is involved in maintaining the \nameref{def:Page_Table} itself, with each page-table entry increasing the overhead.
Also, disk I/O is more efficient when the amount data being transferred is larger.

Generally, page sizes have grown over time as processes, data sets, and main memory have become larger.
Today, pages typically are between $\SI{4}{\kibi{}\byte{}}$ and $\SI{8}{\kibi{}\byte{}}$ in size, and some systems support even larger page sizes.
Some CPUs and kernels now support multiple page sizes.
Variable on-the-fly page size is still being developed.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
