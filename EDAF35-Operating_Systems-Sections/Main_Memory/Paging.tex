\subsection{Paging}\label{subsec:Paging}
Most memory-management schemes used before the introduction of \nameref{def:Paging} suffered from the problem of fitting memory chunks of varying sizes on the \nameref{def:Backing_Store}
This arises because space must be found on the backing store, when main memory needs to be swapped out.
The backing store has the same \nameref{def:Fragmentation} problems discussed in connection with main memory, but access is much slower, so compaction is impossible.

\begin{definition}[Paging]\label{def:Paging}
  \emph{Paging} allows the \nameref{def:Physical_Address_Space} of a \nameref{def:Process} to be noncontiguous.
  This is achieved breaking up \nameref{def:Physical_Memory} and \nameref{def:Logical_Address_Space} into equally, fixed-size blocks.
  \begin{itemize}[noitemsep]
  \item \nameref{def:Physical_Memory} is broken up into \emph{frames}.
  \item \nameref{def:Logical_Address_Space} is broken up into \emph{pages}.
  \item The \nameref{def:Backing_Store} is also broken up, as a multiple (1 through $n$) of the frame size.
  \end{itemize}

  Paging avoids the issue of \nameref{def:External_Fragmentation} and solves the problem of fitting memory chunks of varying sizes on the \nameref{def:Backing_Store}.
  However, \nameref{def:Internal_Fragmentation} is still an issue.
\end{definition}

\nameref{def:Paging} is implemented through cooperation between the operating system and the computer hardware.
Similar to how \nameref{def:Segmentation} has a segment table, \textbf{EACH \nameref{def:Process}} in a \nameref{def:Paging} system has a \nameref{def:Page_Table}.

\begin{definition}[Page Table]\label{def:Page_Table}
  A \emph{page table} is a table that maintains the mapping of logical pages to physical frames in memory.
  The page table is a simple lookup table, where the current \nameref{def:Process}'s current page number is also the value of the index.
  The value contained at that element is the location of the frame in memory.
  This is combined with the use of \nameref{def:Logical_Address}es that are generated by the CPU.\@
\end{definition}

To reach an address, the CPU generates a \nameref{def:Logical_Address} that has 2 parts, a page number $p$ and a page offset $d$.
Like before, the page number is used as an \textbf{INDEX} in the \nameref{def:Page_Table}.
The page table contains the base address of each page in physical memory.
This base address is combined with the page offset to define the physical memory address that is sent to the memory unit.

The frame size, and thus the page size, are defined by the hardware.
The size of a page is a power of 2, varying between 512 bytes and $\SI{1}{\gibi\byte}$\footnote{\si{\gibi\byte} is a gibibyte, or \si[prefixes-as-symbols=false]{\gibi} bytes} per page, depending on the computer architecture.
A power of 2 as a page size makes the translation of a \nameref{def:Logical_Address} into a page number and page offset particularly easy.

If the size of the logical address space is $2^{m}$, and a page size is $2^{n}$ bytes, then the high-order $m-n$ \textbf{bits} of a \nameref{def:Logical_Address} designate the page number, and the $n$ low-order \textbf{bits} designate the page offset.
\begin{equation}\label{eq:Page_Table_Calculations}
  \begin{aligned}
    p &= m-n \\
    d &= n \\
  \end{aligned}
\end{equation}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
