\subsection{Kernel I/O Subsystem}\label{subsec:Kernel_IO_Subsystem}
Kernels provide many services related to I/O, which build on the hardware and \nameref{def:Device_Driver} infrastructure, including:
\begin{itemize}[noitemsep]
\item \nameref{subsubsec:IO_Scheduling}.
\item \nameref{subsubsec:IO_Buffering}.
\item \nameref{subsubsec:IO_Caching}.
\item \nameref{subsubsec:Spooling_Device_Reservation}.
\item \nameref{subsubsec:IO_Error_Handling}.
\end{itemize}

The I/O subsystem is also responsible for protecting itself from errant processes and malicious users.

\subsubsection{I/O Scheduling}\label{subsubsec:IO_Scheduling}
To schedule a set of I/O requests means to determine a good order in which to execute them.
The order in which applications issue system calls rarely is the best choice.
Scheduling can improve overall system performance, can share device access fairly among processes, and can reduce the average waiting time for I/O to complete.

Operating-system developers implement scheduling by maintaining a queue of requests for each device.
When an application issues a \nameref{def:Blocking_Syscall} I/O system call, the request is placed on the queue for \textbf{that} device.
The I/O scheduler rearranges the order of the queue to improve the overall system efficiency and the average response time experienced by applications.
The operating system may also try to be fair, so that no one application receives especially poor service, or it may give priority service for delay-sensitive requests.

When a kernel supports \textbf{asynchronous} I/O, it must be able to keep track of many I/O requests at the same time.
For this purpose, the operating system might attach the wait queue to a device-status table.
The kernel manages this table, which contains an entry for each I/O device.
Each entry indicates:
\begin{itemize}[noitemsep]
\item The device's type
\item Address
\item State (not functioning, idle, or busy)
  \begin{itemize}[noitemsep]
  \item If the device is busy with a request, the type of request and other parameters will be stored in the table entry for that device.
  \end{itemize}
\end{itemize}

\subsubsection{Buffering}\label{subsubsec:IO_Buffering}
Buffering is done for three reasons.
\begin{enumerate}[noitemsep]
\item One reason is to cope with a speed mismatch between the producer and consumer of a data stream.
\item A second use of buffering is to provide adaptations for devices that have different data-transfer sizes.
\item A third use of buffering is to support copy semantics for application I/O.
  \begin{itemize}[noitemsep]
  \item Copy semantics are such that writing to a disk will not corrupt any data.
  \item The version of the data written to disk is guaranteed to be the version at the time of the application system call.
  \end{itemize}
\end{enumerate}

\subsubsection{Caching}\label{subsubsec:IO_Caching}
A cache is a region of fast memory that holds \textbf{copies} of data.
Access to the cached copy is more efficient than access to the original.

The difference between a buffer and a cache is that a buffer may hold the only existing copy of a data item, whereas a cache holds a copy on faster storage of an item that resides elsewhere.
However, a section of memory can sometimes be used for both purposes.
For instance, to preserve copy semantics and to enable efficient scheduling of disk I/O, the operating system uses buffers in main memory to hold disk data.
These buffers are also used as a cache, to improve the I/O efficiency for files that are shared by applications or that are being written and reread rapidly.

\subsubsection{Spooling and Device Reservation}\label{subsubsec:Spooling_Device_Reservation}
A spool is a buffer that holds output for a device, such as a printer, that cannot
accept interleaved data streams.
For example, a printer can serve only one job at a time, but several applications may wish to print their output concurrently, without having their output mixed together.
The operating system solves this problem by intercepting all output to the printer.
Each applicationâ€™s output is spooled to a separate disk file.
When an application finishes printing, the spooling system queues the corresponding spool file for output to the printer.
The spooling system copies the queued spool files to the printer one at a time.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
