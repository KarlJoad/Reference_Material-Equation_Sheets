\section{Virtual Memory}\label{sec:Virtual_Memory}
As our natural definition of Von Neumann computers, the instructions being executed must be in \nameref{def:Physical_Memory}.
Thus, the first approach to meeting this requirement is to place the entire \nameref{def:Logical_Address_Space} in physical memory.
This is unfortunate, since it limits the size of a program to the size of physical memory.
\nameref{def:Dynamic_Loading} can help ease this restriction, but it generally requires special precautions and extra work by the programmer.

However, an examination of real \nameref{def:Program}s shows us that, in many cases, the entire program is not needed.
Even in those cases where the entire program is needed, it may not all be needed at the same time.
The ability to execute a program that is only partially in memory has many benefits:
\begin{itemize}[noitemsep]
\item Programs are no longer constrained by amount of \nameref{def:Physical_Memory} available.
  Users able to write programs for an extremely large \nameref{def:Virtual_Address_Space}, simplifying the programming task.
\item Each user program takes less physical memory, more programs could be run at the same time.
  This yields a corresponding increase in CPU utilization and throughput but with no increase in response time or turnaround time.
\item Less I/O needed to load or swap user programs into memory, so each user program would run faster.
\end{itemize}

\begin{definition}[Virtual Memory]\label{def:Virtual_Memory}
  Virtual memory involves the separation of logical memory as perceived by users from \nameref{def:Physical_Memory}.
  This separation allows:
  \begin{itemize}[noitemsep]
  \item Extremely large virtual memory to be provided for programmers when less physical memory is available.
  \item \nameref{def:Process}es can share files easily.
  \item \nameref{par:Shared_Memory} can be implemented.
    \begin{itemize}[noitemsep]
    \item For example, sharing a library between different processes can be handled just by mapping the virtual memory location into the process's \nameref{def:Virtual_Address_Space}.
    \item Although each process considers the library to be part of \textbf{its} virtual address space, the frames where the libraries reside in physical memory are shared by all the processes.
    \item Typically, a library is mapped read-only into the space of each process that is linked with it.
    \item This is typically implemented with \nameref{subsubsec:Shared_Pages}.
    \end{itemize}
  \item An efficient method for \nameref{def:Process} creation.
\end{itemize}

  Virtual memory makes the task of programming much easier, because the programmer no longer needs to worry about the amount of physical memory available; they can concentrate instead on the problem to be programmed.
\end{definition}

\begin{definition}[Physical Memory]\label{def:Physical_Memory}
  \emph{Physical memory} is the memory that is physically installed in the computer.
  There is a finite amount of this, determined by how much is installed by the system designer.
\end{definition}

\begin{definition}[Virtual Address Space]\label{def:Virtual_Address_Space}
  The \emph{virtual address space} of a \nameref{def:Process} consists of all the \nameref{def:Virtual_Address}es generated by a \nameref{def:Program}.
  It refers to the logical (virtual) view of \textbf{how a \nameref{def:Process} is stored in memory}.
  Typically, this view is one of perfectly continguous memory locations, when in fact, the process could be in many different, noncontiguous locations and the \nameref{def:Memory_Management_Unit} handles the \nameref{def:Paging}.

  \begin{remark}
    The \nameref{def:Virtual_Address_Space} is only calculated by one \nameref{def:Program}/\nameref{def:Process} at a time.
    To find the total virtual address space used, all \nameref{def:Process}es must have their virtual address spaces aggregated.
  \end{remark}
\end{definition}

The large blank space between the heap and the stack is part of the virtual address space but will require actual physical pages only if the heap or stack grows.
Virtual address spaces that include these holes are known as \nameref{def:Sparse_Address_Space}s.

\begin{definition}[Sparse Address Space]\label{def:Sparse_Address_Space}
  A \emph{sparse address space} is a \nameref{def:Virtual_Address_Space} that is not completely mapped to \nameref{def:Physical_Memory}.
  Typically, this is done in the case of programs for the memory space between the stack and heap, which is overwhelmingly empty.

  Sparse address spaces are beneficial because these holes can be filled on demand, when the \nameref{def:Process} needs more \nameref{def:Physical_Memory}, or to dynamically link shared objects during program execution.
\end{definition}

\input{./EDAF35-Operating_Systems-Sections/Virtual_Memory/Demand_Paging}

\input{./EDAF35-Operating_Systems-Sections/Virtual_Memory/Copy_on_Write}

\input{./EDAF35-Operating_Systems-Sections/Virtual_Memory/Page_Replacement}

\input{./EDAF35-Operating_Systems-Sections/Virtual_Memory/Thrashing}

\input{./EDAF35-Operating_Systems-Sections/Virtual_Memory/Memory_Mapped_Files}

\input{./EDAF35-Operating_Systems-Sections/Virtual_Memory/Allocating_Kernel_Memory}

\input{./EDAF35-Operating_Systems-Sections/Virtual_Memory/Other_Topics}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
