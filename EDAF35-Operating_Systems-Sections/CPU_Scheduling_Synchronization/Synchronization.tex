\subsection{Process/Thread Synchronization}\label{subsec:Synchronization}
The main problem that occurs in multi\nameref{def:Thread}ed programs is that there is a small portion of code that is a \nameref{def:Critical_Section}.
This leads to the development of the \nameref{subsubsec:Critical_Section_Problem}.

\begin{definition}[Critical Section]\label{def:Critical_Section}
  The \emph{critical section} of a \nameref{def:Process} is a portion where the \nameref{def:Thread} and/or \nameref{def:Process} is changing common variables, updating a table, writing a file, or other global state changes.
\end{definition}

\subsubsection{Critical Section Problem}\label{subsubsec:Critical_Section_Problem}
The \emph{Critical Section Problem} is the issue of coordinating multiple \nameref{def:Thread}s about a \nameref{def:Critical_Section} of the code.
The problem is to design a protocol that the \nameref{def:Process}es/\nameref{def:Thread}s can use to cooperate.
Each \nameref{def:Process} must request permission to enter its critical section.
The section of code implementing this request is the \nameref{def:Entry_Section}.
The critical section may be followed by an \nameref{def:Exit_Section}.
The remaining code is the \nameref{def:Remainder_Section}.

\begin{definition}[Entry Section]\label{def:Entry_Section}
  The \emph{entry section} of a \nameref{def:Process} is the portion where the request to execute the \nameref{def:Critical_Section} occurs.
  In the case of a \nameref{def:Mutex}, this is the process of aquiring the it.
  For a \nameref{def:Semaphore}, it is the process of manipulating the value it currently contains.
\end{definition}

\begin{definition}[Exit Section]\label{def:Exit_Section}
  In the \emph{exit section}, the constructs used to ensure coordination in the \nameref{def:Critical_Section} are freed.
  In the case of a \nameref{def:Mutex}, this is the process of releasing the it.
  For a \nameref{def:Semaphore}, it is the process of manipulating the value it currently contains in the opposite direction it was initially manipulated by.
\end{definition}

\begin{definition}[Remainder Section]\label{def:Remainder_Section}
  The \emph{remainder section} is the rest of the code, after this \nameref{def:Critical_Section}.
  This code may be parallelized, or not.
  It could contain further \nameref{def:Critical_Section}s.
\end{definition}

Any solution to this problem \textbf{MUST} satisfy one of the following 3 requirements:
\begin{enumerate}[noitemsep]
\item \textbf{Mutual Exclusion}.
  If \nameref{def:Process} $P_{i}$ is executing its \nameref{def:Critical_Section}, then \textbf{no other} processes can execute their critical sections.
\item \textbf{Progress}.
  If no \nameref{def:Process} is executing its \nameref{def:Critical_Section}, and some processes wish to enter their critical sections, then only those processes that \textbf{are not executing} in their \nameref{def:Remainder_Section}s can decide which will enter the \nameref{def:Critical_Section} next.
  Essentially, the only way a process gets a voice in the choice is by not having executed the critical section yet.
\item \textbf{Bounded Waiting}.
  There exists a bound on the number of times that other \nameref{def:Process}es are allowed to enter their \nameref{def:Critical_Section}s after a process has made a request to enter its critical section and before that request is granted.
\end{enumerate}

To handle the \nameref{subsubsec:Critical_Section_Problem}, there are 2 main types of \nameref{def:Kernel}s that present solutions.
\begin{enumerate}[noitemsep]
\item \nameref{def:Nonpreemptive_Kernel}s. Not used frequently today.
\item \nameref{def:Preemptive_Kernel}s. The most common type today.
\end{enumerate}

\begin{definition}[Nonpreemptive Kernel]\label{def:Nonpreemptive_Kernel}
  A \emph{nonpreemptive kernel} is a \nameref{def:Kernel} that does \textbf{NOT} use \nameref{def:Preemption} on \nameref{def:Process}es or \nameref{def:Thread}s running in kernel-mode.
\end{definition}

\begin{definition}[Preemptive Kernel]\label{def:Preemptive_Kernel}
  A \emph{preemptive kernel} is a \nameref{def:Kernel} that uses \nameref{def:Preemption} on \nameref{def:Process}es or \nameref{def:Thread}s running in kernel-mode.
  This means that we cannot say anything definitive about the state of the \nameref{def:Kernel}'s data structures at a given time, because we cannot say which process/thread is running at that time.
\end{definition}

\subsubsection{Hardware Support for Synchronization}\label{subsubsec:Hardware_Support_Synchronization}
Software-based solutions to handling multithreading and multiprocessing tends to be better than hardware-based solutions, as they are more flexible.
Many of the solutions that will be presented here are based on the idea of \textbf{\nameref{def:Lock}ing}.

\begin{definition}[Lock]\label{def:Lock}
  A \emph{lock} allows \textbf{only one} \nameref{def:Thread} to enter the portion of code that is locked.
  While a thread holds this lock no other \nameref{def:Thread} can execute on this code portion.

\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
