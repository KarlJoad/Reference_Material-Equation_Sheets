\subsection{Scheduling}\label{subsec:Scheduling}
CPU scheduling is the basis of multiprogrammed operating systems.
In a single-processor system, only one process can run at a time.
Others must wait until the CPU is free and can be rescheduled.
By switching the CPU among processes, the operating system can maximize CPU utilization.

For example, a \nameref{def:Process} is executed until it must wait.
Typically the process waits for the completion of some I/O request.
In a simple computer system, the CPU then just sits idle.
All this waiting time is wasted; no useful work is accomplished.

\begin{blackbox}
  \textbf{On operating systems that support them, \nameref{def:Kernel_Thread}s, not \nameref{def:Process}es are scheduled by the operating system.}
  However, the terms ``process scheduling'' and ``thread scheduling'' are often used interchangeably.
  Process scheduling is used when discussing general scheduling concepts and thread scheduling to refer to thread-specific ideas.
\end{blackbox}

Scheduling of this kind is a fundamental operating-system function.
Almost all computer resources are scheduled before use.

\subsubsection{CPU and I/O Bursts}\label{subsubsec:CPU_IO_Bursts}
To properly schedule a \nameref{def:Process}, its \nameref{def:CPU_Burst}s and \nameref{def:I/O_Burst}s need to observed.

\begin{definition}[CPU Burst]\label{def:CPU_Burst}
  A \emph{CPU burst} is one of the states of execution for a \nameref{def:Process}.
  This is the state when the process is actively using the CPU to perform computations.
  In this state, the CPU is performing activity for \textbf{this} \nameref{def:Process}, and \textbf{IS NOT} waiting for an I/O device to perform some action or return information.
\end{definition}

\begin{definition}[I/O Burst]\label{def:I/O_Burst}
  An \emph{I/O burst} is one of the states of execution for a \nameref{def:Process}.
  This is the state when the process is waiting on the I/O device to return the requested information or perform the desired action.
  In this state, the CPU is doing no activity for \textbf{this} \nameref{def:Process}.
\end{definition}

A \nameref{def:Process} alternates between these two bursts, with the final \nameref{def:CPU_Burst} terminating this \nameref{def:Process}'s execution.
The distribution of length of CPU bursts is an exponential or hyperexponential graph.
This means:
\begin{itemize}[noitemsep]
\item There is a large number of short duration CPU bursts.
\item There is a small number of long duration CPU bursts.
\end{itemize}

We can categorize these into either \nameref{def:CPU_Bound} programs or \nameref{def:IO_Bound} programs.
\begin{itemize}[noitemsep]
\item I/O-bound programs have a small number of CPU bursts which have a relatively short duration relative to the I/O operations.
  The I/O operations take up a majority of the time the \nameref{def:Process} executes.
\item CPU-bound programs have a large number of CPU bursts, which have a relatively long duration relative to the I/O operations.
  The CPU operatiosn take up a majority of the time the \nameref{def:Process} executes.
\end{itemize}

\subsubsection{CPU Scheduler}\label{subsubsec:CPU_Scheduler}
Whenever the CPU becomes idle, i.e.\ it has finished the current CPU burst early, or there is an I/O operation, the \nameref{def:Operating_System} must select the next \nameref{def:Process} and/or \nameref{def:Thread} to schedule.
This is handled by the \nameref{def:Short_Term_Scheduler}.

\begin{definition}[Short-Term Scheduler]\label{def:Short_Term_Scheduler}
  The \emph{short-term scheduler} is responsible for scheduling either the next \nameref{def:Process} or \nameref{def:Thread} for execution on the \textbf{CPU} from all the possible ones in memory.
  This is run quite frequently, every couple hundred milliseconds, usually.

  \begin{remark}[CPU Scheduler]\label{rmk:CPU_Scheduler}
    Because the \nameref{def:Short_Term_Scheduler} only schedules tasks for the CPU, it is also called the \emph{CPU Scheduler}.
  \end{remark}
\end{definition}

\paragraph{Preemption and Scheduling}\label{par:Preemption_Scheduling}
There are 4 times when CPU scheduling occurs:
\begin{enumerate}[noitemsep]
\item When a process switches from the \texttt{RUNNING} state to the \texttt{WAITING} state.
\item When a process switches from the \texttt{RUNNING} state to the \texttt{READY} state (for example, when an interrupt occurs).
\item When a process switches from the \texttt{WAITING} state to the \texttt{READY} state (for example, at completion of I/O).
\item When a process terminates.
\end{enumerate}

In the case of Times 1 and 4, there are no options in terms of scheduling.
In the first situation, a \nameref{def:Process} is being made unschedule-able by the \nameref{def:Operating_System}.
So, another process must be switched in for the one that was made to wait.
Similarly, when a \nameref{def:Process} terminates, there is no option for how to schedule it, because it's done executing.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
