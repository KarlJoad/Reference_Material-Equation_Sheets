\subsection{System Calls}\label{subsec:System_Calls}
\begin{definition}[System Call]\label{def:System_Call}
  Software may trigger an interrupt by executing a special operation called a \emph{system call}.
  This can also be called a monitor call.

  System calls provide an interface to the services made available by an \nameref{def:Operating_System}.
  These calls are generally available as routines written in C and C++.
  Some of the lowest-level tasks (for example, tasks where hardware must be accessed directly) may have to be written using assembly instructions.

  There are roughly 6 different types of system calls:
  \begin{enumerate}[noitemsep]
  \item \nameref{subsubsec:Process_Control}
    \begin{itemize}[noitemsep]
    \item End, Abort
    \item Load, Execute
    \item Create process, Terminate process
    \item Get process attributes, Set process attributes
    \item Wait for time
    \item Wait event, Signal event
    \item Allocate and Free memory
    \end{itemize}
  \item \nameref{subsubsec:File_Manipulation}
    \begin{itemize}[noitemsep]
    \item Create file, Delete file
    \item Open, Close
    \item Read, Write, Reposition
    \item Get file attributes, Set file attributes
    \end{itemize}
  \item \nameref{subsubsec:Device_Manipulation}
    \begin{itemize}[noitemsep]
    \item Request device, Release device
    \item Read, Write, Reposition
    \item Get device attributes, Set device attributes
    \item Logically attach or detach devices
    \end{itemize}
  \item \nameref{subsubsec:Information_Maintenance}
    \begin{itemize}[noitemsep]
    \item Get time or date, Set time or date
    \item Get system data, Set system data
    \item Get Process, File, or Device attributes
    \item Set Process, File, or Device attributes
    \end{itemize}
  \item \nameref{subsubsec:Communications}
    \begin{itemize}[noitemsep]
    \item Create, Delete communication connection
    \item Send, Receive messages
    \item Transfer status information
    \item Attach or Detach remote devices
    \end{itemize}
  \item \nameref{subsubsec:Protection}
  \end{enumerate}
\end{definition}

\begin{table}[h!tbp]
  \centering
  \begin{tabular}{lll}
    \toprule
    & \textbf{Windows} & \textbf{Unix} \\
    \midrule
    \nameref{subsubsec:Process_Control} & \mintinline{cpp}{CreateProcess()} & \mintinline{c}{fork()} \\
    & \mintinline{cpp}{ExitProcess()} & \mintinline{c}{exit()} \\
    & \mintinline{cpp}{WaitForSingleObject()} & \mintinline{c}{wait()} \\
    \midrule
    \nameref{subsubsec:File_Manipulation} & \mintinline{cpp}{CreateFile()} & \mintinline{c}{open()} \\
    & \mintinline{cpp}{ReadFile()} & \mintinline{c}{read()} \\
    & \mintinline{cpp}{WriteFile()} & \mintinline{c}{write()} \\
    & \mintinline{cpp}{CloseHandle()} & \mintinline{c}{close()} \\
    \midrule
    \nameref{subsubsec:Device_Manipulation} & \mintinline{cpp}{SetConsoleMode()} & \mintinline{c}{ioctl()} \\
    & \mintinline{cpp}{ReadConsole()} & \mintinline{c}{read()} \\
    & \mintinline{cpp}{WriteConsole()} & \mintinline{c}{write()} \\
    \midrule
    \nameref{subsubsec:Information_Maintenance} & \mintinline{cpp}{GetCurrentProcessID()} & \mintinline{c}{getpid()} \\
    & \mintinline{cpp}{SetTimer()} & \mintinline{c}{alarm()} \\
    & \mintinline{cpp}{Sleep()} & \mintinline{c}{sleep()} \\
    \midrule
    \nameref{subsubsec:Communications} & \mintinline{cpp}{CreatePipe()} & \mintinline{c}{pipe()} \\
    & \mintinline{cpp}{CreateFileMapping()} & \mintinline{c}{shm_open()} \\
    & \mintinline{cpp}{MapViewOfFile()} & \mintinline{c}{mmap()} \\
    \midrule
    \nameref{subsubsec:Protection} & \mintinline{cpp}{SetFileSecurity()} & \mintinline{c}{chmod()} \\
    & \mintinline{cpp}{InitializeSecurityDescriptor()} & \mintinline{c}{umask()} \\
    & \mintinline{cpp}{SetSecurityDescriptorGroup()} & \mintinline{c}{chown()} \\
    \bottomrule
  \end{tabular}
  \caption{System Calls in Unix and Windows}
  \label{tab:System_Calls_Examples}
\end{table}

\nameref{def:System_Call}s are exposed to the programmer by an \nameref{def:API}.
\begin{definition}[Application Programming Interface]\label{def:API}
  An \emph{Application Programming Interface} (\emph{API}) specifies a set of functions that are available to an application programmer.
  They specify the parameters that are passed to each function and the return values the programmer can expect.

  Typically, API calls perform \nameref{def:System_Call}s in the background, without the programmer knowing about them.
\end{definition}

\subsubsection{Process Control}\label{subsubsec:Process_Control}
A running program needs to be able to halt its own execution, either normally or abnormally.
If a system call is made to terminate the currently running program abnormally, or if the program runs into a problem and causes an error \nameref{def:Trap}, a dump of memory is sometimes taken and an error message generated.
The dump is written to disk and may be examined by a debugger—a system program designed to aid the programmer in finding and correcting errors, or bugs—to determine the cause of the problem.

Under either normal or abnormal circumstances, the operating system must transfer control to the invoking command interpreter.
The command interpreter then reads the next command.

To determine how bad the execution halt was, when the program ceases execution, it will return an exit code.
By convention, and for no other reason, an exit code of \texttt{0} is considered to be the program completed execution successfully.
Otherwise, the greater the return value, the greater the severity of the error.

\subsubsection{File Manipulation}\label{subsubsec:File_Manipulation}
We first need to be able to \mintinline{c}{create()} and \mintinline{c}{delete()} files.
Either system call requires the name of the file and perhaps some of the file’s attributes.
Once the file is created, we need to \mintinline{c}{open()} it and to use it.
We may then \mintinline{c}{read()}, \mintinline{c}{write()}, or perform any other \nameref{def:API}-defined action(s).
Finally, we need to \mintinline{c}{close()} the file, indicating that we are no longer using it.

We may need these same sets of operations for directories if we have a directory structure for organizing files in the file system.
In addition, for either files or directories, we need to be able to determine the values of various attributes and perhaps to reset them if necessary.

\begin{definition}[File Attribute]\label{def:File_Attribute}
  A \emph{file attribute} contains metadata about the file.
  This includes the file's name, type, protection codes, accounting information, and so on.
\end{definition}

\begin{remark*}
  If the system programs are callable by other programs, then each can be considered an \nameref{def:API} by other system programs.
\end{remark*}

\subsubsection{Device Manipulation}\label{subsubsec:Device_Manipulation}
\begin{definition}[Device]\label{def:Device}
  A \emph{device} in an \nameref{def:Operating_System} is a resource that must be controlled.
  Some of these devices are physical devices (for example, disk drives), while others can be thought of as abstract or virtual devices (for example, files).
\end{definition}

A system with multiple users may require us to first \mintinline{c}{request()} a device, to ensure exclusive use of it.
After we are finished with the device, we \mintinline{c}{release()} it.
These functions are similar to the \mintinline{c}{open()} and \mintinline{c}{close()} system calls for files.
Other operating systems allow unmanaged access to devices.
The hazard then is the potential for device contention and perhaps \nameref{def:Deadlock}.

Once the device has been requested (and allocated to us), we can \mintinline{c}{read()}, \mintinline{c}{write()}, just as we can with files.
In fact, the similarity between I/O devices and files is so great that many operating systems, including UNIX, merge the two into a combined file–device structure.
In this case, a set of system calls can be shared between both files and \nameref{def:Device}s.
Sometimes, I/O devices are identified by special file names, directory placement, or file attributes.

\subsubsection{Information Maintenance}\label{subsubsec:Information_Maintenance}
Many system calls exist simply for the purpose of transferring information between the \nameref{def:User} program and the \nameref{def:Operating_System}.
For example, most systems have a system call to return the current \mintinline{c}{time()} and \mintinline{c}{date()}.
Other system calls may return information about the system, such as the number of current users, the version number of the operating system, the amount of free memory or disk space, and so on.

Another set of system calls is helpful in debugging a program.
Many systems provide system calls to \mintinline{c}{dump()} memory.
A program \texttt{trace} lists each system call as it is executed.
In addition, the \nameref{def:Operating_System} keeps information about all its processes, and \nameref{def:System_Call}s are used to access this information.

\subsubsection{Communications}\label{subsubsec:Communications}
\subsubsection{Protection}\label{subsubsec:Protection}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
