\subsection{Threading Issues}\label{subsec:Threading_Issues}
In this section, we will discuss some common issues that arise because of multithreading.

\subsubsection{The \texorpdfstring{\kernelinline{fork()}}{\texttt{fork()}} and \texorpdfstring{\kernelinline{exec()}}{\texttt{exec()}} System Calls}\label{subsubsec:Fork_Exec_System_Calls}
Since \kernelinline{fork()} creates a separate, but duplicate, child \nameref{def:Process} from its parent, what are the semantics when creating a \nameref{def:Thread} on a UNIX system, since \nameref{def:Thread}s are just another kind of \nameref{def:Process}?

If one thread in a program calls \kernelinline{fork()}, does the new process duplicate all threads, or is the new process single-threaded?
To answer this, there are two versions of \kernelinline{fork()}, one that duplicates all threads and another that duplicates only the thread that invoked the \kernelinline{fork()} system call.

The \kernelinline{exec()} system call is relatively unchanged; if a thread invokes the \kernelinline{exec()} system call, the program specified in the parameter to \kernelinline{exec()} will \textbf{replace the entire process}, including all threads.

Which version of \kernelinline{fork()} to use depends on the application.
If \kernelinline{exec()} will be called immediately after forking, then duplicating \textbf{all} threads is unnecessary, as the program specified in the parameters to \kernelinline{exec()} will replace the process anyways, thus duplicating only the calling thread is appropriate.
If, however, the separate process does not call \kernelinline{exec()} after forking, the separate process should duplicate all threads.

\subsubsection{Signal Handling}\label{subsubsec:Signal_Handling}
\begin{definition}[Signal]\label{def:Signal}
  A UNIX \emph{signal} is used to notify a \nameref{def:Process} that an event has occurred.
  The reception of the signal can be synchronous or asynchronous.
  Synchronous in this context means that the signal is \textbf{delivered to the same proces that caused the signal}.
  Asynchronous means the signal is generated by an event \textbf{external to the running process}, such as keyboard presses or timer expiration.

  Which one depends on the source of and the reason for the event to be signaled.
  However, all signals have the same general pattern:
  \begin{enumerate}[noitemsep]
  \item A signal is generated by the occurrence of a particular event.
  \item The signal is delivered to a process.
  \item Once delivered, the signal must be handled.
  \end{enumerate}
\end{definition}

When a \nameref{def:Signal} is delivered, it must be handled by either:
\begin{enumerate}[noitemsep]
\item The default signal handler
\item The user-defined signal handler
\end{enumerate}

Every \nameref{def:Signal} has a default handler that the \nameref{def:Kernel} runs to handle the \nameref{def:Signal}.
However, these actions can be overridden by a user-defined signal handler.
How a \nameref{def:Process} responds to a signal depends on the process and the type of signal that is received.

Signal handling in single-threaded processes is simple, because the only \nameref{def:Thread} is also the \nameref{def:Process}.
However, multithreaded programs have some complications because there are multiple \nameref{def:Thread}s for the single \nameref{def:Process}.
\begin{enumerate}[noitemsep]
\item Deliver the signal to the thread to which the signal applies.
\item Deliver the signal to every thread in the process.
\item Deliver the signal to certain threads in the process.
\item Assign a specific thread to receive all signals for the process.
\end{enumerate}

How a \nameref{def:Signal} is delivered depends on the type of signal generated.
Synchronous signals need to be delivered \textbf{to the \nameref{def:Thread} causing the \nameref{def:Signal}}.
Some asynchronous signals need to be delievered to all threads in a \nameref{def:Process}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
