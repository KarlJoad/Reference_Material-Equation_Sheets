\subsection{Virtualization and OS Components}\label{subsec:Virtualization_OS_Components}
Here, I discuss how the \nameref{def:VMM} provides core \nameref{def:Operating_System} functions like \nameref{subsec:Scheduling}, I/O, and memory management.

\subsubsection{CPU Scheduling}\label{subsubsec:VM_CPU_Scheduling}
A system with \nameref{def:Virtualization}, frequently acts like a multiprocessor system.
The virtualization software presents one or more \nameref{def:Virtual_CPU}s to each of the \nameref{def:Virtual_Machine}s running on the system and then schedules the use of the physical CPUs among the virtual machines.
The significant variations among virtualization technologies make it difficult to generalize the effect of virtualization on scheduling.

First, consider the general case of \nameref{def:VMM} scheduling.
The VMM has a number of physical CPUs available and a number of threads to run on those CPUs.
The threads can be VMM threads or guest threads.
The VMM itself needs some CPU cycles for guest management and I/O management and can steal cycles from the guests by scheduling its threads across all of the system CPUs, but the impact of this action is relatively minor.
Guests are configured with a certain number of \nameref{def:Virtual_CPU}s at creation time, and can be adjusted throughout the life of the VM.\@

When there are enough CPUs to allocate the requested number to each guest, the \nameref{def:VMM} can treat the CPUs as dedicated and schedule only a given guest's threads on that guest's CPUs.
In this situation, the guests act much like native \nameref{def:Operating_System}s running on native CPUs.
In other situations, there may not be enough CPUs to go around, especially if the CPUs have \nameref{def:Overcommit}ment, where the guests are configured for more CPUs than exist in the system.
Then, a VMM can use standard \nameref{subsubsec:Scheduling_Algorithms} to make progress on each thread but can also add a fairness aspect to those algorithms.

\begin{definition}[Overcommit]\label{def:Overcommit}
  \nameref{def:Virtualization} systems allow the created virtual resources to \emph{overcommit} the system's physical resources.
  For example, a \nameref{def:Virtual_Machine} can be given 2 \nameref{def:Virtual_CPU}s, when there is only 1 physical CPU.\@
  The same can happen with memory; a guest can be configured have more memory than the host system has.
\end{definition}

Even given a \nameref{def:Scheduler} that provides fairness, any guest \nameref{def:Operating_System} scheduling algorithm that assumes a certain amount of progress in a given amount of time will be negatively affected by virtualization.
Within a \nameref{def:Virtual_Machine}, the guest operating system is at the mercy of the \nameref{def:Virtualization} system as to what CPU resources it actually receives.

The net effect of such scheduling layering is that individual virtualized \nameref{def:Operating_System}s receive only a portion of the available CPU cycles, even though they believe they are receiving all of the cycles and that they are scheduling for all of those cycles.

\subsubsection{Memory Management}\label{subsubsec:VM_Memory_Management}
Efficient memory use in general-purpose operating systems is one of the major keys to performance.
In virtualized environments, there are more users of memory (the guests and their applications, as well as the VMM), leading to more pressure on memory use.
Further adding to this pressure is that VMMs typically \nameref{def:Overcommit} memory.
The extra need for efficient memory mean great measures are taken to ensure the optimal use of memory.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
