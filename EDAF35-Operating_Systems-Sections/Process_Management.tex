\section{Process Management}\label{sec:Process_Management}
\begin{definition}[Process]\label{def:Process}
  A \emph{process} is a \nameref{def:Program} in the midst of execution, and all its related resources.
  In fact, two or more processes can exist that are executing the same program.
  Processes are, however, more than just the executing program code (often called the text section in Unix).
  They also include a set of resources such as open files and pending signals, internal \nameref{def:Kernel} data, processor state, a memory address space with one or more memory mappings, one or more \nameref{def:Thread}s of execution, and a data section containing global variables.

  Processes, in effect, are the living result of running program code.
\end{definition}

\begin{definition}[Program]\label{def:Program}
  A \emph{program} is object code stored on some media, typically as a \nameref{def:File}.
  These contain the instructions that the processor will execute when the program is running as a \nameref{def:Process}.
  These instructions are stored in what is called the \emph{text section} of the program.
  It also contains statically allocated information, such as \kernelinline{static} variables.
\end{definition}

Occassionally, \nameref{def:Thread}s can be subject to \nameref{def:Preemption}.

\begin{definition}[Preemption]\label{def:Preemption}
  \emph{Preemption} is the act of temporarily interrupting a task being carried out by a computer system, without requiring its cooperation, and with the intention of resuming the task at a later time.
  Such changes of the executed task are known as context switches.
  It is normally carried out by a privileged task or part of the system known as a preemptive scheduler, which has the power to preempt, or interrupt, and later resume, other tasks in the system.

  In any given system design, some operations performed by the system may not be preemptible.
  This usually applies to \nameref{def:Kernel} functions and service interrupts which, if not permitted to run to completion, would tend to produce race conditions resulting in deadlock.
\end{definition}

On modern \nameref{def:Operating_System}s, \nameref{def:Process}es provide two virtualizations:
\begin{enumerate}[noitemsep]
\item a virtualized processor
  \begin{itemize}[noitemsep]
  \item The virtual processor gives \emph{this} \nameref{def:Process} the illusion that it alone monopolizes the system, despite possibly sharing the processor among hundreds of other processes.
\end{itemize}
\item Virtual memory lets the process allocate and manage memory as if it alone owned all the memory in the system.
  \begin{itemize}[noitemsep]
  \item \nameref{def:Thread}s share the virtual memory abstraction, whereas each receives its own virtualized processor.
  \end{itemize}
\end{enumerate}

\input{./EDAF35-Operating_Systems-Sections/Process_Management/Process_Life_Cycle}


\input{./EDAF35-Operating_Systems-Sections/Process_Management/Process_Scheduling}

\input{./EDAF35-Operating_Systems-Sections/Process_Management/Process_Descriptor_Task_Struct}

\input{./EDAF35-Operating_Systems-Sections/Process_Management/Process_Creation}

\input{./EDAF35-Operating_Systems-Sections/Process_Management/Process_Termination}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
