\subsection{File Allocation Methods}\label{subsec:File_Allocation_Methods}
The direct-access nature of disks gives us flexibility in the implementation of files.
In almost every case, many files are stored on the same disk.
The main problem is how to allocate space to these files so that disk space is utilized effectively while allowing for quick access to files.

\subsubsection{Contiguous File Allocation}\label{subsubsec:Contiguous_File_Allocation}
Contiguous allocation requires that each file occupy a set of contiguous blocks on the disk.
Disk addresses define a linear ordering on the disk.

Contiguous allocation of a file is defined by the disk address of the first block and length (in blocks).
If the file is $n$ blocks long and starts at location $b$, then it occupies blocks $b, b+1, \ldots, b+n-1$.
The directory entry for each file indicates the address of the starting block and the length of the area allocated for this file.

\paragraph{Advantages of Contiguous Allocation}\label{par:Contiguous_File_Allocation_Advantages}
Accessing a file that has been allocated contiguously is easy.
\begin{itemize}[noitemsep]
\item \textbf{\nameref{subsubsec:Sequential_Access}}.
  \nameref{def:File_System} remembers the disk address of the last block referenced and reads the next block.
\item \textbf{\nameref{subsubsec:Direct_Access}} to block $i$ of a file that starts at block $b$, we can immediately access block $b + i$.
\end{itemize}

\paragraph{Disadvantages of Contiguous Allocation}\label{par:Contiguous_File_Allocation_Disadvantages}
However, this allocation methods has some problems.
One difficulty is finding space for a new file.
The system chosen to manage free space determines how this task is accomplished.
This is another case of the \nameref{def:Allocation_Problem}.

\begin{definition}[Allocation Problem]\label{def:Allocation_Problem}
  The \emph{Allocation Problem} involves how to satisfy a request of size $n$ from a list of free holes.
  If the holes are not organized, i.e.\ there are enough blocks but they are not contiguous, then the request cannot be serviced.
\end{definition}

\nameref{subpar:First_Fit} and \nameref{subpar:Best_Fit} are the most common strategies used to select a free hole from the set of available holes, however, \nameref{subpar:Worst_Fit} is also possible.
Simulations have shown that both first fit and best fit are more efficient than worst fit in terms of time and storage utilization.
However, \textbf{all these algorithms} suffer from the problem of \nameref{def:External_Fragmentation}.
As files are allocated and deleted, the free disk space is broken into little pieces.
External fragmentation exists whenever free space is broken into chunks.
Fixing this problem is only solvable by garbage collection, in this case means moving all data to another disk then copying it back.

Another problem is determining how much space is needed for a file.
When the file is created, the total amount of space it will need must be found and allocated.
\begin{itemize}[noitemsep]
\item If we allocate too little space to a file, we may find that the file cannot be extended.
\item If the total amount of space needed for a file is known in advance, preallocation may be inefficient.
\end{itemize}

To minimize these drawbacks, some operating systems use a modified contiguous-allocation scheme.
Here, a contiguous chunk of space is allocated initially.
Then, if that amount proves not to be large enough, another chunk of contiguous space, known as an \nameref{def:Extent}, is added.
The location of a fileâ€™s blocks is then recorded as a location and a block count, plus a link to the first block of the next extent.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
