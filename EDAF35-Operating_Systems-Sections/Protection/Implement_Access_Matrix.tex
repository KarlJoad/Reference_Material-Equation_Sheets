\subsection{Implementing Access Matrices}\label{subsec:Implement_Access_Matrices}
In general, an \nameref{def:Access_Matrix} will be sparse, i.e.\ most of the entries in the table will be empty.
Along with this, traditional sparse data structure techniques are not terribly useful for this.
These are because of the way the protection facilities are used.

Most systems use a combination of \nameref{def:Access_List}s and \nameref{def:Capability_List}s.
When a \nameref{def:Process} first tries to access an object, the access list is searched.
If access is denied, an exception condition occurs.
Otherwise, a capability is created and attached to the process.
Subsequent references use the capability to quickly determine access.
After the last access, the capability is destroyed.

\subsubsection{Global Table}\label{subsubsec:Global_Access_Matrix}
The simplest implementation of the access matrix is a global table consisting of a set of ordered tuples $\langle \text{domain}, \text{object}, \text{rights-set} \rangle$.
Whenever an operation $M$ is executed on an object $O_{j}$ within domain $D_{i}$, the global table is searched for a tuple $\langle D_{i}, O_{j}, R_{k} \rangle$, where $M \in R_{k}$.
If this tuple is found, the operation is allowed to continue; otherwise, an exception (or error) is raised.

This implementation suffers from several drawbacks.
The table is usually large and thus cannot be kept in main memory, so additional I/O is needed.
Virtual memory techniques are often used for managing this table (\nameref{def:Memory_Mapping}).
In addition, it is difficult to take advantage of special groupings of objects or domains.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
