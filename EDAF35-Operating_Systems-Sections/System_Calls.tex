\section{System Calls}\label{sec:System_Calls}
\begin{definition}[System Call]\label{def:System_Call}
  Software may trigger an interrupt by executing a special operation called a \emph{system call}.
  This can also be called a monitor call.
  A system call is a messaging interface between applications and the \nameref{def:Kernel}, with the applications issuing various requests and the \nameref{def:Kernel} fulfilling them or returning an error.

  System calls provide an interface to the services made available by an \nameref{def:Operating_System}.
  These services are a set of interfaces by which \nameref{def:Process}es running in \nameref{def:User}-space can interact with the system.
  These interfaces give \nameref{def:User}-level applications:
  \begin{itemize}[noitemsep]
  \item Controlled access to hardware
  \item A mechanism with which to create new \nameref{def:Process}es
  \item A mechanism to communicate with existing ones
  \item The capability to request other \nameref{def:Operating_System} resources
  \end{itemize}

  These calls are generally available as routines written in C and C++.
  Some of the lowest-level tasks (for example, tasks where hardware must be accessed directly) may be written using assembly.

  \begin{remark}[Syscall]\label{rmk:Syscall}
    In UNIX and UNIX-like systems, \nameref{def:System_Call} is usually shortened to \emph{syscall}.
  \end{remark}
\end{definition}

There are roughly 6 different types of system calls:
\begin{enumerate}[noitemsep]
\item \nameref{subsec:Process_Control}
  \begin{itemize}[noitemsep]
  \item End, Abort
  \item Load, Execute
  \item Create \nameref{def:Process}, Terminate \nameref{def:Process}
  \item Get process attributes, Set process attributes
  \item Wait for time
  \item Wait event, Signal event
  \item Allocate and Free memory
  \end{itemize}
\item \nameref{subsec:File_Manipulation}
  \begin{itemize}[noitemsep]
  \item Create file, Delete file
  \item Open, Close
  \item Read, Write, Reposition
  \item Get file attributes, Set file attributes
  \end{itemize}
\item \nameref{subsec:Device_Manipulation}
  \begin{itemize}[noitemsep]
  \item Request device, Release device
  \item Read, Write, Reposition
  \item Get device attributes, Set device attributes
  \item Logically attach or detach devices
  \end{itemize}
\item \nameref{subsec:Information_Maintenance}
  \begin{itemize}[noitemsep]
  \item Get time or date, Set time or date
  \item Get system data, Set system data
  \item Get \Nameref{Def:Process}, File, or Device attributes
  \item Set \Nameref{Def:Process}, File, or Device attributes
  \end{itemize}
\item \nameref{subsec:Communications}
  \begin{itemize}[noitemsep]
  \item Create, Delete communication connection
  \item Send, Receive messages
  \item Transfer status information
  \item Attach or Detach remote devices
  \end{itemize}
\item \nameref{subsec:Protection}
\end{enumerate}

\nameref{def:System_Call}s provide a layer between the hardware and \nameref{def:User}-space \nameref{def:Process}es.
This layer serves three primary purposes.
\begin{enumerate}[noitemsep]
\item It provides an abstracted hardware interface for \nameref{def:User}-space programs.
  When reading or writing from a file, applications do not have to be concerned with the type of disk, media, or even the type of filesystem on which the file resides.
\item \nameref{def:System_Call}s ensure system security and stability.
  With the \nameref{def:Kernel} acting as a middle-man between system resources and \nameref{def:User}-space, the \nameref{def:Kernel} can arbitrate access based on permissions, \nameref{def:User}s, and other criteria.
  This arbitration prevents applications from incorrectly using hardware, stealing other \nameref{def:Process}es’ resources, or otherwise doing harm to the system.
\item There is a single common layer between \nameref{def:User}-space and the rest of the system allows for the virtualized system provided to \nameref{def:Process}es.
\end{enumerate}

\begin{table}[h!tbp]
  \centering
  \begin{tabular}{lll}
    \toprule
    & \textbf{Windows} & \textbf{Unix} \\
    \midrule
    \nameref{subsec:Process_Control} & \mintinline{cpp}{CreateProcess()} & \mintinline{c}{fork()} \\
    & \mintinline{cpp}{ExitProcess()} & \mintinline{c}{exit()} \\
    & \mintinline{cpp}{WaitForSingleObject()} & \mintinline{c}{wait()} \\
    \midrule
    \nameref{subsec:File_Manipulation} & \mintinline{cpp}{CreateFile()} & \mintinline{c}{open()} \\
    & \mintinline{cpp}{ReadFile()} & \mintinline{c}{read()} \\
    & \mintinline{cpp}{WriteFile()} & \mintinline{c}{write()} \\
    & \mintinline{cpp}{CloseHandle()} & \mintinline{c}{close()} \\
    \midrule
    \nameref{subsec:Device_Manipulation} & \mintinline{cpp}{SetConsoleMode()} & \mintinline{c}{ioctl()} \\
    & \mintinline{cpp}{ReadConsole()} & \mintinline{c}{read()} \\
    & \mintinline{cpp}{WriteConsole()} & \mintinline{c}{write()} \\
    \midrule
    \nameref{subsec:Information_Maintenance} & \mintinline{cpp}{GetCurrentProcessID()} & \mintinline{c}{getpid()} \\
    & \mintinline{cpp}{SetTimer()} & \mintinline{c}{alarm()} \\
    & \mintinline{cpp}{Sleep()} & \mintinline{c}{sleep()} \\
    \midrule
    \nameref{subsec:Communications} & \mintinline{cpp}{CreatePipe()} & \mintinline{c}{pipe()} \\
    & \mintinline{cpp}{CreateFileMapping()} & \mintinline{c}{shm_open()} \\
    & \mintinline{cpp}{MapViewOfFile()} & \mintinline{c}{mmap()} \\
    \midrule
    \nameref{subsec:Protection} & \mintinline{cpp}{SetFileSecurity()} & \mintinline{c}{chmod()} \\
    & \mintinline{cpp}{InitializeSecurityDescriptor()} & \mintinline{c}{umask()} \\
    & \mintinline{cpp}{SetSecurityDescriptorGroup()} & \mintinline{c}{chown()} \\
    \bottomrule
  \end{tabular}
  \caption{System Calls in Unix and Windows}
  \label{tab:System_Calls_Examples}
\end{table}

\nameref{def:System_Call}s are exposed to the programmer by an \nameref{def:API}.
\begin{definition}[Application Programming Interface]\label{def:API}
  An \emph{Application Programming Interface} (\emph{API}) specifies a set of functions that are available to an application programmer.
  They specify the parameters that are passed to each function and the return values the programmer can expect.

  Typically, API calls perform \nameref{def:System_Call}s in the background, without the programmer knowing about them.
\end{definition}



\subsection{Device Manipulation}\label{subsec:Device_Manipulation}
\begin{definition}[Device]\label{def:Device}
  A \emph{device} in an \nameref{def:Operating_System} is a resource that must be controlled.
  Some of these devices are physical devices (for example, disk drives), while others can be thought of as abstract or virtual devices (for example, files).
\end{definition}

A system with multiple users may require us to first \mintinline{c}{request()} a device, to ensure exclusive use of it.
After we are finished with the device, we \mintinline{c}{release()} it.
These functions are similar to the \mintinline{c}{open()} and \mintinline{c}{close()} system calls for files.
Other operating systems allow unmanaged access to devices.
The hazard then is the potential for device contention and perhaps \nameref{def:Deadlock}.

Once the device has been requested (and allocated to us), we can \mintinline{c}{read()}, \mintinline{c}{write()}, just as we can with files.
In fact, the similarity between I/O devices and files is so great that many operating systems, including UNIX, merge the two into a combined file–device structure.
In this case, a set of system calls can be shared between both files and \nameref{def:Device}s.
Sometimes, I/O devices are identified by special file names, directory placement, or file attributes.

\subsection{Information Maintenance}\label{subsec:Information_Maintenance}
Many system calls exist simply for the purpose of transferring information between the \nameref{def:User} program and the \nameref{def:Operating_System}.
For example, most systems have a system call to return the current \mintinline{c}{time()} and \mintinline{c}{date()}.
Other system calls may return information about the system, such as the number of current users, the version number of the operating system, the amount of free memory or disk space, and so on.

Another set of system calls is helpful in debugging a program.
Many systems provide system calls to \mintinline{c}{dump()} memory.
A program \texttt{trace} lists each system call as it is executed.
In addition, the \nameref{def:Operating_System} keeps information about all its processes, and \nameref{def:System_Call}s are used to access this information.

\subsection{Communications}\label{subsec:Communications}
Both of the models discussed are common in operating systems, and most systems implement both.
\nameref{subsubsec:Message_Passing} is useful for exchanging smaller amounts of data, because no conflicts need to be avoided.
It is also easier to implement than is shared memory for intercomputer communication.
\nameref{subsubsec:Shared_Memory} allows maximum speed and convenience of communication, since it can be done at memory transfer speeds when it takes place within a computer.
Problems exist, however, in the areas of protection and synchronization between the processes sharing memory.

\subsubsection{Message Passing}\label{subsubsec:Message_Passing}
Messages can be exchanged between the processes either directly or indirectly through a common mailbox.
Before communication can take place, a connection must be opened.
The name of the other communicator must be known.
Each process has a process name, and this name is translated into an identifier by which the operating system can refer to the process.
The \mintinline{c}{get_processid()} system call does this translation.
The identifiers are then passed to general-purpose \mintinline{c}{open()} and \mintinline{c}{close()} calls provided by the file system or to specific \mintinline{c}{open_connection()} and \mintinline{c}{close_connection()} system calls, depending on the model of communication.
The recipient process usually must give its permission for communication to take place with an \mintinline{c}{accept_connection()} call.

Most processes that will be receiving connections are special-purpose \nameref{def:Daemon}s.
They execute a \mintinline{c}{wait_for_connection()} call and are awakened when a connection is made.
The source of the communication, known as the client, and the receiving \nameref{def:Daemon}, known as a server, then exchange messages by using \mintinline{c}{read_message()} and \mintinline{c}{write_message()} system calls.
The \mintinline{c}{close_connection()} call terminates the communication.

\subsubsection{Shared-Memory}\label{subsubsec:Shared_Memory}
In the shared-memory model, \mintinline{c}{shared_memory_create()} and \mintinline{c}{shared_memory_attach()} system calls are used by processes to create and gain access to regions of memory owned by other processes.
The operating system tries to prevent one process from accessing another process’s memory, so shared memory requires that two or more processes agree to remove this restriction.
They can then exchange information by reading and writing data in the shared areas.
The form of the data is determined by the processes and is not under the operating system’s control.
The processes are also responsible for ensuring that they are not writing to the same location simultaneously.

\subsection{Protection}\label{subsec:Protection}
Protection provides a mechanism for controlling access to the resources provided by a computer system.
Historically, protection was a concern only on multiprogrammed computer systems with several \nameref{def:User}s.
However, with the advent of networking and the Internet, all computer systems, from servers to mobile handheld devices, must be concerned with protection.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAF35-Operating_Systems-Reference_Sheet"
%%% End:
