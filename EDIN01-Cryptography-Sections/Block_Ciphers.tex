\section{Block Ciphers}\label{sec:Block_Ciphers}
\begin{definition}[Block Cipher]\label{def:Block_Cipher}
  A \emph{block cipher} encrypts a fixed-length block of plaintext bits $x$ to a fixed-length block of ciphertext $y$.
  This transformation is controlled by the secret key $K$, and is written $E_{K}(x) = y$.

  The secret key defines a fixed mapping of the plaintext block $x$ to the ciphertext block $y$.
  This can sometimes make block ciphers a form of \nameref{subsec:Simple_Substitution_Cipher}.

  Block ciphers are usually implemented with several \nameref{def:Round_Function}s, based on the \nameref{def:Round_Key}.
\end{definition}

\begin{definition}[Round Function]\label{def:Round_Function}
  \nameref{def:Block_Cipher}s are usually implemented as iterated ciphers, where a simple encryption function is iteratively applied for $N$ rounds.
  This is called a \emph{round function}.
  It is commonly denoted
  \begin{equation}\label{eq:Round_Function}
    h(w_{i-1}, k_{i})
  \end{equation}
  where
  \begin{itemize}[noitemsep]
  \item $i$ is the current round (current iteration).
  \item $w$ is the input plaintext block.
  \item $k$ is the \nameref{def:Round_Key} on the $i$th iteration.
  \item $h$ is the \nameref{def:Round_Function}.
  \end{itemize}

  These functions must also be invertible, namely,
  \begin{equation}\label{eq:Round_Function_Invertible}
    h^{-1} \bigl( h(w_{i-1}, k_{i}), k_{i} \bigr) = w_{i-1}
  \end{equation}

  \textbf{These functions must be efficient to compute, and be efficient to compute the inverse round function.}
\end{definition}

\begin{definition}[Round Key]\label{def:Round_Key}
  The \emph{round key} is derived from the key $K$.
  The way in which the round key is derived from $K$ is called the \emph{key schedule}.
\end{definition}

If we want to mathematically illustrate the implementation of a \nameref{def:Block_Cipher}'s encryption with a iterative cipher, it is defined as:
\begin{align*}
  w_{0} &= x \\
  w_{1} &= h(w_{0}, k_{1}) \\
  w_{2} &= h(w_{1}, k_{2}) \\
        &\vdots \\
  w_{N-1} &= h(w_{N-2}, k_{N-1}) \\
  w_{N} &= h(w_{N-1}, k_{N}) \\
\end{align*}
\begin{itemize}[noitemsep]
\item $x$ is the plaintext block.
\item $w_{i}$ are intermediate values in the implementation of the iteration.
\item $w_{N}$ is the final output from the cipher.
\item $h(w_{i-1}, k_{i})$ denotes the round function.
\item $k_{i}$ is the round key used in the $i$th round.
\end{itemize}

For the same iterative cipher, the decryption function $D_{K}(y)$ is just the application of the \nameref{def:Round_Key}s in reverse order.
\begin{align*}
  w_{N} &= y \\
  w_{N-1} &= h^{-1}(w_{N}, k_{N}) \\
  w_{N-2} &= h^{-1}(w_{N-1}, k_{N-2}) \\
        &\vdots \\
  w_{1} &= h^{-1}(w_{2}, k_{2}) \\
  w_{0} &= h^{-1}(w_{1}, k_{1}) = x \\
\end{align*}

\subsection{Examples of Iterated Ciphers}\label{subsec:Examples_Iterated_Ciphers}
\subsubsection{Feistel Ciphers/DES}\label{subsubsec:Feistel_Cipher_DES}
\begin{definition}[Feistel Cipher]\label{def:Feistel_Cipher}
  A \emph{Feistel cipher} is a type of iterated cipher that is easy to implement in both hardware and software.
  However, it is not safe to use anymore.

  An example of these is the DES encryption algorithm.

  The block being run through the \nameref{def:Round_Function} is split in half; a left and right half, denoted
  \begin{equation}\label{eq:Feistel_Cipher_Block}
    w_{i} = (L_{i}, R_{i})
  \end{equation}

  The \nameref{def:Round_Function} $h(L_{i-1}, R_{i-1}, k_{i})$ is implemented as
  \begin{equation}\label{eq:Feistel_Cipher_Round_Function_Encryption}
    \begin{aligned}
      L_{i} &= R_{i-1} \\
      R_{i} &= L_{i-1} \XOR f(R_{i-1}, k_{i})
    \end{aligned}
  \end{equation}
  where $f(R_{i-1}, k_{i})$ can be any function.

  The decryption function for the Feistel cipher is implemented as
  \begin{equation}\label{eq:Feistel_Cipher_Round_Function_Decryption}
    \begin{aligned}
      L_{i-1} &= R_{i} \XOR f(R_{i-1}, k_{i}) \\
      R_{i-1} &= L_{i}
    \end{aligned}
  \end{equation}
  and $(L_{0}, R_{0})$ gives back $x$.
\end{definition}

\subsubsection{SP Network}\label{subsubsec:SP_Network}
\begin{definition}[SP Network]\label{def:SP_Network}
  An \emph{SP network} is a iterated \nameref{def:Block_Cipher} that consists of a mix between substitutions (\emph{S}) (\nameref{subsec:Simple_Substitution_Cipher}s) and permutations (\emph{P}) or linear transformations (~\pageref{subsubsec:Transposition_Cipher}s).
  The \nameref{def:Round_Key} is added to the input to the \nameref{def:Round_Function} in a simple way ($\XOR$).

  An example of these is the AES (Advanced Encryption Scheme) cipher.
\end{definition}

\begin{definition}[S-Box]\label{def:S_Box}
  An \emph{S-Box} is the substitution portion of an \nameref{def:SP_Network}.
  They are usually taken over a small alphabet, and only have 4, 6, or 8 bits as input.
\end{definition}

\subsection{Modes of Operation}\label{subsec:Modes_of_Operation}
\begin{definition}[Mode of Operation]\label{def:Mode_of_Operation}
  A \emph{mode of operation} describes how to repeatedly apply a cipher's single-block operation to securely transform amounts of data larger than a block.
  This is helpful because, by themselves, \nameref{def:Block_Cipher}s can only encrypt/decrypt one block.
  To accomplish this, the plaintext is split up into blocks, and each block is encrypted.
  \begin{equation*}
    x_{1}, x_{2}, \ldots, x_{N}, x_{N+1}, \ldots
  \end{equation*}

  Let $X_{1} = (x_{1}, x_{2}, \ldots, x_{N})$ be the first block with length $N$.
  Let $X_{2} = (x_{N+1}, x_{N+2}, \ldots, x_{2N})$ be the second block, also with length $N$.
  The encryption is then done blockwise
  
  Most modes require a unique binary sequence, often called an \nameref{def:Initialization_Vector} (IV), for each encryption operation.

  There are 3 modes of operation that are discussed in this course:
  \begin{enumerate}[noitemsep]
  \item \nameref{subsubsec:Electronic_Codebook_Mode}
  \item \nameref{subsubsec:Cipher_Block_Chaining_Mode}
  \item \nameref{subsubsec:Counter_Mode}
  \end{enumerate}
\end{definition}

\subsection{Advanced Encryption Scheme}\label{subsec:AES}
\textbf{TODO}
\begin{definition}[Advanced Encryption Scheme]\label{def:AES}
  \textbf{TODO}
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDIN01-Cryptography-Reference_Sheet"
%%% End:
