\section{Shannon's Theory of Secrecy}\label{sec:Shannon_Theory_of_Secrecy}
\begin{definition}[Shannon's Theory of Secrecy]\label{def:Shannon_Theory_of_Secrecy}
  \emph{Shannon's Theory of Secrecy} was developed by \href{https://en.wikipedia.org/wiki/Claude_Shannon}{Claude Shannon}.
  It is an attack/defense model for a \nameref{def:Symmetric_Encryption} system.

  This model operates under the assumptions that there is \nameref{def:Unconditional_Security} and only \nameref{def:Attack-Ciphertext_Only}s.

  \begin{remark}[Flaws of this Model's Assumptions]\label{rmk:Shannon_Theory_of_Secrecy_Assumption_Flaws}
    These assumptions are very strong.
    In reality, these assumptions would correspond to the \textbf{absolute best-case scenario}.
  \end{remark}

  There is a set of \nameref{def:Encryption_Rule}s, one for each $k$, which maps \nameref{def:Plaintext} letters in a message $\mathbf{m} = m_{1}, m_{2}, \ldots, m_{i} \in \Plaintexts$ to \nameref{def:Ciphertext} letters $\mathbf{c} = c_{1}, c_{2}, \ldots, c_{i} \in \Ciphertexts$.
\end{definition}

\subsection{Attack and Security Assumptions}\label{subsec:Shannon_Attack_Security_Assumptions}
There are several possible assumptions for Eve's attack on Alice's message.
\begin{enumerate}[noitemsep]
\item \emph{\nameref{def:Attack-Ciphertext_Only}}: Eve has only the ciphertext $C$, and wants to get the key $K$ or the plaintext message $M$.
\item \emph{\nameref{def:Attack-Known_Plaintext}}: Eve has both the ciphertext $C$ and the plaintext message $M$, and wants the key $K$.
\item \emph{\nameref{def:Attack-Chosen_Plaintext}}: Eve knows $M$ and and can arbitrarily choose $M$ to get $C$ back. She wants to get the key $K$.
\item \emph{\nameref{def:Attack-Chosen_Ciphertext}}: Eve has the \nameref{def:Decryption_Rule}, $d_{K}$ and can feed in any arbitrary $C$. She is attempting to find the key $K$.
\item \emph{\nameref{def:Attack-Related_Key}}: The message $M$ is encrypted with a key $K$ similar to another.
\item \emph{\nameref{def:Attack-Side_Channel}}: Eve is attacking the implementation of the \nameref{def:Encryption_Rule}, $e_{K}$, by observing some other outputs.
  \begin{itemize}[noitemsep]
  \item The power consumed by the algorithm
  \item The network communcations occurring
  \end{itemize}
\end{enumerate}

\begin{definition}[Ciphertext-Only Attack]\label{def:Attack-Ciphertext_Only}
  In a \emph{ciphertext-only attack}, Eve has only the ciphertext $C$, and wants to get the key $K$ or the plaintext message $M$.
\end{definition}

\begin{definition}[Known-Plaintext Attack]\label{def:Attack-Known_Plaintext}
  In a \emph{known-plaintext attack}, Eve has both the ciphertext $C$ and the plaintext message $M$, and wants the key $K$.
\end{definition}

\begin{definition}[Chosen-Plaintext Attack]\label{def:Attack-Chosen_Plaintext}
  In a \emph{chosen-plaintext attack}, Eve knows $M$ and and can arbitrarily choose $M$ to get $C$ back. She wants to get the key $K$.
\end{definition}

\begin{definition}[Chosen-Ciphertext Attack]\label{def:Attack-Chosen_Ciphertext}
  In a \emph{chosen-ciphertext attack}, Eve has the \nameref{def:Decryption_Rule}, $d_{K}$ and can feed in any arbitrary $C$.
  She is attempting to find the key $K$.

  \begin{remark}[Lunchtime Attack]\label{rmk:Attack-Lunchtime}
    Sometimes the \nameref{def:Attack-Chosen_Ciphertext} is called a \emph{lunchtime attack}, because an arbitrary \nameref{def:Plaintext} can be fed through the \nameref{def:Encryption_Rule} quickly.
    This means the output can be found quickly, for example, while a coworker is having lunch.
  \end{remark}
\end{definition}

\begin{definition}[Related-Key Attack]\label{def:Attack-Related_Key}
  In a \emph{related-key attack}, the message $M$ is encrypted with a key $K$ similar to another, already broken key.
\end{definition}

\begin{definition}[Side Channel Attack]\label{def:Attack-Side_Channel}
  In a \emph{side channel attack}, Eve is attacking the implementation of the \nameref{def:Encryption_Rule}, $e_{K}$, by observing some other outputs.
  \begin{itemize}[noitemsep]
  \item The power consumed by the algorithm
  \item The network communcations occurring
  \end{itemize}
\end{definition}

\subsection{Security Scenarios}\label{subsec:Shannon_Security_Scenarios}
There are several scenarios we have for our \nameref{def:Encryption_Rule} and \nameref{def:Decryption_Rule}.
In the order of \textbf{strongest security} to \textbf{weakest security}:
\begin{enumerate}[noitemsep]
\item \emph{\nameref{def:Security-Unconditional}}: A \nameref{def:Cryptographic_Primitive} is unconditionally secure if it cannot be broken even if Eve has infinite computational power.
  \begin{itemize}[noitemsep]
  \item This means she can also perform an exhautive key search (Brute Force)
  \end{itemize}
\item \emph{\nameref{def:Security-Computational}}: A \nameref{def:Cryptographic_Primitive} is computationally secure if the best algorithm to break the key requires at least $T$ operations, where $T$ is a very large number.
\item \emph{\nameref{def:Security-Provable}}: A \nameref{def:Cryptographic_Primitive} is provably secure if the key can be reduced to a well known and well-studied problem.
  \begin{itemize}[noitemsep]
  \item Semiprime Integer Factorization is an example a key that is provably secure.
  \end{itemize}
\item \emph{\nameref{def:Security-Heuristic}}: If there is no known method of breaking the \nameref{def:Cryptographic_Primitive}, but the security cannot be proven in any sense.
\end{enumerate}

\begin{definition}[Unconditional Security]\label{def:Security-Unconditional}
  A \nameref{def:Cryptographic_Primitive} has \emph{unconditional security}, is \emph{unconditionally secure}, if it cannot be broken even if Eve has infinite computational power.
  \begin{itemize}[noitemsep]
  \item This means she can also perform an exhautive key search (Brute Force)
  \end{itemize}
\end{definition}

\begin{definition}[Computational Security]\label{def:Security-Computational}
  A \nameref{def:Cryptographic_Primitive} has \emph{computational security}, is \emph{computationally secure}, if the best algorithm to break the key requires at least $T$ operations, where $T$ is a very large number.
\end{definition}

\begin{definition}[Provable Security]\label{def:Security-Provable}
  A \nameref{def:Cryptographic_Primitive} has \emph{provable security}, is \emph{provably secure}, if the key can be reduced to a well known and well-studied problem.
  \begin{itemize}[noitemsep]
  \item Semiprime Integer Factorization is an example a key that is provably secure.
  \end{itemize}
\end{definition}

\begin{definition}[Heuristic Security]\label{def:Security-Heuristic}
  A \nameref{def:Cryptographic_Primitive} has \emph{heuristic security}, is \emph{heuristically secure}, if there is no known method of breaking the \nameref{def:Cryptographic_Primitive}, but the security cannot be proven in any sense.
\end{definition}

\begin{definition}[Perfect Secrecy]\label{def:Perfect_Secrecy}
  A cryptosystem has \emph{perfect secrecy} if \Cref{eq:Perfect_Secrecy} is true.
  \begin{equation}\label{eq:Perfect_Secrecy}
    \MutualInformation(M;C) = 0 = H(M) - H(M \Given C)
  \end{equation}
\end{definition}

\subsection{Shannon's Theory with Discrete Random Variables}\label{subsec:Shannon_Theory_Discrete_Random_Variables}
\nameref{def:Shannon_Theory_of_Secrecy} can be modelled with 3 random variables:
\begin{equation}\label{eq:Shannon_Theory_Discrete_Random_Variables}
  \begin{aligned}
    \mathbf{M} &= (M_{1}, M_{2}, \ldots, M_{N}) \text{ and } \Prob(\mathbf{M}) \\
    \mathbf{C} &= (C_{1}, C_{2}, \ldots, C_{N}) \text{ and } \Prob(\mathbf{C}) \\
    K &\in \Keyspace \text{ and } \Prob(K) \\
  \end{aligned}
\end{equation}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDIN01-Cryptography-Reference_Sheet"
%%% End:
