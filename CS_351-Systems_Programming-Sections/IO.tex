\section{Input/Output (I/O)}\label{sec:IO}
In \textsc{unix}, I/O devices include:
\begin{itemize}[noitemsep]
\item Disk
\item Terminal
\item Shared Memory
\item Printer
\item Network
\end{itemize}

This is mostly because \textsc{unix} made the design decision to try to view every component of a system as a \nameref{def:File}.

Due to the variety of I/O devices that need to be supported, there are a vast number of different mechanisms for using these devices.
But, there are a few common mechanisms, requirements, and activities:
\begin{itemize}[noitemsep]
\item Read/Write Ops
\item Metadata:
  \begin{itemize}[noitemsep]
  \item Name
  \item Position
  \item Directory Name
  \item Creation Date
  \item Last Access Date
  \item IP Address
  \item MAC Address
  \item TCP Packet Sequence Number
  \end{itemize}
\item Robustness
\item Thread-safety
\end{itemize}

There are few general concerns that we need to have about the idea of viewing everything as a \nameref{def:File}.
\begin{itemize}[noitemsep]
\item How are I/O endpoints represented?
  \begin{itemize}[noitemsep]
  \item \nameref{def:File_Descriptor}
  \end{itemize}
\item How do we perform I/O?\@
  \begin{itemize}[noitemsep]
  \item Byte at a time
  \item Give a chunk of memory and later check that the requested I/O completed?
  \end{itemize}
\item How do we perform I/O \emph{efficiently}?
  \begin{itemize}[noitemsep]
  \item Efficiency depends on what we define efficient to be. Essentially, what are we optimizing for?
  \end{itemize}
\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../CS_351-Systems_Programming-Reference_Sheet"
%%% End:
