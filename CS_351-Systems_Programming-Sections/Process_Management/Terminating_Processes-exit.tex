\subsection{Terminating Processes, \texttt{exit}}\label{subsec:Terminating_Processes-exit}
There are several possible ways for a \nameref{def:Process} to terminate.

\begin{itemize}[noitemsep]
\item The simplest way to terminate a \nameref{def:Process} is for the main process to \texttt{return}.
  If we are being pedantic, the compiler actually implicitly inserts an \texttt{exit} in this case, making all possible exits from a process use \texttt{exit}.

\item The \texttt{exit} \nameref{def:Syscall}.
  \begin{itemize}[noitemsep]
  \item This exits immediately
  \item This may prevent a normal \texttt{return}
  \end{itemize}
\end{itemize}

The standard \textsc{unix} \textbf{convention} is that exit status \texttt{0} is success, and any other value is some error code.

\subsubsection{\texttt{atexit}}\label{subsubsec:atexit}
\cinline{int atexit (void (*fn)())} is a unique function.
It registers a function that will be called after a \nameref{def:Program} has had \texttt{exit} called on it, but before it fully exits.
This registration is achieved by passing a pointer to the function that shoudl be run.
The registartion must happen some time before the \texttt{exit}.
There is no particular place this registration \textbf{MUST} happen though.

In addition, these handlers are inherited by child \nameref{def:Process}es.

\subsubsection{Zombie Processes}\label{subsubsec:Zombie_Processes}
All processes become \nameref{def:Zombie_Process} eventually, awaiting to be \nameref{def:Reap}ed.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../CS_351-Systems_Programming-Reference_Sheet"
%%% End:
