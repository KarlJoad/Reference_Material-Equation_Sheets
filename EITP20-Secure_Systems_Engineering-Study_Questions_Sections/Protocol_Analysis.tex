\section{Protocol Analysis}\label{sec:Protocol_Analysis}
\begin{questions}
\question{} What is mutual authentication?
  \begin{solution}
    Mutual authentication is where each communicating end ensures that the person they are talking to is the actual person they are intending to talk to.
  \end{solution}

\question{} Which attacks are typically applicable to an authentication protocol?
  \begin{solution}
    \begin{itemize}[noitemsep]
    \item Impersonation Attacks: One end of the communication pretends to be another principle/actor.
    \item Man-in-the-Middle Attacks: There is an actor between the 2 valid communicators, potentially alteing messages, $A \leftrightarrow \textcolor{red}{I} \leftrightarrow B$.
    \item Replay Attacks: Parts of previous messages are reused to form a new one.
    \item Reflection Attacks: A sender send their information to the intended receiver expecting a response, and the attack send the initiators message right back to them.
    \item Unknown Key-Share Attacks: Different actors in the system have diffeerent views of their peers.
    \item Oracle Attacks: Reponses in the protocol's messages are used as encryption and decryption services, essentially using the protocol to the attacker's advantage.
    \item Type Flaw Attacks: Use the absence of proper message type checking and substitute a message with a different message field.
    \item Chosen Protocol Attack: A brand new protocol is created to interact with the original protocol, creating a security hole.
    \item Internal Action Flaws: Perform an attack on the algorithm itself.
      For example, an Invalid-Curve Attack on an Elliptic Curve algorithm.
    \item Cryptanalysis: Perform dictionary attacks, attempt to factor numbers, etc. This can be done online or offline.
    \end{itemize}
  \end{solution}

\question{} What is a man-in-the-middle attack? How could you prevent it?
  \begin{solution}
    A man-in-the-middle attack is where there are 2 parties that are honestly trying to communicate with each other.
    However, the messages are not secured in a way that prevents tampering, so the attacker masquerades as the other party, receiving the valid message, forwards it onto the intended recipient after changing the source entity.
    This way both honest actors are communicating with each other (there may or may not be modifications to the messages), but it is done \emph{through} the man-in-the-middle.
    This attacker may see the information, may alter it, etc.\ but the bigger problem is that this attack is almost undetectable unless something else is done with the protocol.

    The best way to prevent it would be to find discontinuities in the message flow.
    So, if a message is supposed to take a certain amount of time from one host to the other, but it takes much longer, i.e.\ through a third host longer, then there may be a MITM attack.
    This could also be prevented by ensuring the messages are sent with the contents and recipients encrypted and/or protected by other means, preventing a potential MITM from changing information without it being known.
  \end{solution}

\question{} What is a replay attack? How could you prevent it?
  \begin{solution}
    A replay attack is where portions of previous messages are reused in new messages.
    For example, this means that if a session key is transmitted in plaintext in a protocol without any additional verification, then the attacker could reuse an old session key and send it back during another instance of the same protocol running.
    This will mean the attacker and the honest host will communicate with each other, rather than the host and the server.

    This can usually be prevented by attacking timestamp information, to ensure that the information provided is fresh.
  \end{solution}

\question{} What is a reflection attack? How could you prevent it?
  \begin{solution}
    A reflection attack is one where an attacker takes a message that someone just sent and send the message right back to the original sender.
    If the sender is expecting a response to their initial message, then the protocol might continue to function, using the original message as the response, compromising the security of the protocol itself.

    This is harder to prevent, but attaching the intended recipient to the message, and having the actual recipient compare them is the only way to prevent these.
  \end{solution}

\question{} What is a labeled multiset rewriting rule? What are $l$, $r$, $a$?
  \begin{solution}
    A labeled multiset rewriting rule is a tuple where a set of states on the left are mutated into a set of states on the right.
    This is done with an action fact that is added to the trace, allowing for tracing of the actions that have already taken place.

    \begin{equation}\label{eq:Labeled_Multiset_Rewriting_Rule}
      l \overset{a}{\rightarrow} r
    \end{equation}
    \begin{description}[noitemsep]
    \item[$l$] Left side. This is the set of states that the rule must have in order to run.
    \item[$a$] Action Fact. This is the fact that is recorded in the trace when this multiset rule is executed.
    \item[$r$] Right side. This is the set of states that the rule puts back into the multiset after execution.
    \end{description}
  \end{solution}

\question{} What is a state agent fact $St\_R\_s(A, id, \ldots)$?
  \begin{solution}
    A state agent fact is a fact regarding the state of a single agent in a protocol.
    \begin{equation}\label{eq:State_Agent_Fact}
      St\_R\_s(A, id, \ldots)
    \end{equation}
    \begin{description}[noitemsep]
    \item[$R$] The role that this agent plays in the protocol. Are they an initiator or a responder?
    \item[$s$] What step is this? 1, 2, 76, etc.?
    \item[$A$] What is this agent's name? This is typically a public piece of information.
      This also identifies the actual agent throughout the protocol's execution.
    \item[$id$] This is a unique ID that is given to each agent in the protocol execution to allow for easier tracing.
    \item[$\ldots$] An agent state fact can have as many additional pieces of information necessary.
      This can be thought of as the information that the host must carry around throughout the protocol in order to let the protocol work.
    \end{description}
  \end{solution}

\question{} What are \texttt{In} and \texttt{Out} facts? What are \texttt{Send} and \texttt{Recv} action facts? When do you have them?
  \begin{solution}
    The \texttt{In} and \texttt{Out} facts are ones that communicate messages through the network.
    Both of these only take in one (1) piece of information, the message.
    The \texttt{In} fact can only be used on the $l$ portion of \Cref{eq:Labeled_Multiset_Rewriting_Rule}.
    The \texttt{Out} fact can only be used on the $r$ portion of \Cref{eq:Labeled_Multiset_Rewriting_Rule}.

    The \texttt{Send} and \texttt{Recv} are action facts the record \emph{who} sent \emph{what}.
    Additional information could also be recorded, if it is contained within a tuple.
    These are contained in the $a$ portion of \Cref{eq:Labeled_Multiset_Rewriting_Rule}.
    \texttt{Send} is used when an actor \texttt{Out}s a message to the network.
    \texttt{Recv} is used when another actor \texttt{Ins} a message from the network.
  \end{solution}

\question{} What is a protocol rule? What is an action fact?
  \begin{solution}
    A protocol rule formalizes the \emph{roles} of the protocol.
    They define the sending and receiving of messages for use in agent state facts to keep track of each role's activities.

    An action fact is a fact that is recorded in the trace as a set of actions taken during each protocol rule's execution.
  \end{solution}

\question{} What is fresh rule? What is $Fr()$ fact?
  \begin{solution}
    A fresh rule is one that takes in an empty set of states from the multiset and outputs a new set of states to the multiset.
    It creates new, fresh terms/facts.
    It does not have any preconditions (the empty initial set) and is the only rule allowed to create new information.

    \begin{equation}\label{eq:Fresh_Rule}
      [] \rightarrow [Fr(N)]
    \end{equation}

    The $Fr()$ fact indicates that the parameter is fresh, unique, and completely random.
    These facts are assumed to be unguessable.
  \end{solution}

\question{} What is infrastructure rule? How do you write the key generation for PKI?\@ How can you generate private/public keys and publish public keys using Fr, Ltk, Out, PK facts?
  \begin{solution}
    An infrastructure rule is used to formalize the generation of cryptographic information, typically before the protocol begins execution of communications.

    \begin{equation}\label{eq:PKI_Infrastructure_Rule}
      [Fr(sk)] \overset{GenPKI(A, sk, pk(sk))}{\longrightarrow} [Ltk(A, sk), Pk(A, pk(sk)), Out(pk(sk))]
    \end{equation}
    The generation of the private secret key is essentially a random number, which is modeled by a $Fr(sk)$ fact.
    The secret key is a long-term key fact about the agent who generated it, and is ``registered'' as the secret key for this agent by the $Ltk()$ fact.
    The public key is found by running the public key fact/function $Pk()$ which ``registers'' a given public key to the given agent.
    The public key is then shared through the network by the $Out()$ fact.
  \end{solution}

\question{} What is an initialization rule? How do you write the initialization rule for a given protocol (e.g.\ a public key-based protocol)? What is Create action fact?
  \begin{solution}
    An initialization rule creates an agent/actor for a given role in a protocol.
    They are typically written like so;
    \begin{multline}\label{eq:Initialization_Rule}
      [Fr(idA), Ltk(A, skA), Pk(B, pkB)] \overset{Create(A, idA, R)}{\longrightarrow} \\ [St\_R\_1(A, idA, skA, pkB), Ltk(A, skA), Pk(B, pkB)]
    \end{multline}

    The Create action fact records the explicit creation of an agent in a given role, with their generated id.
  \end{solution}

\question{} What is the meaning of well-formedness? How could you write protocol rules that are well-formed?
  \begin{solution}
    Well-formedness is a set of requirements needed to make an executable protocol.
    To be well-formed, a protocol rule must increment the step count for a role by \emph{just} 1.
    In addition, all information present on $r$ in \Cref{eq:Labeled_Multiset_Rewriting_Rule} must be derivable from all information given by public valies, the input agent state fact(s), any fresh fact, and any \texttt{In} fact.
    To be shown mathematically, we need
    \begin{align*}
      St\_R\_r(A, id, k_{1}, \ldots, k_{n}) &\in l \\
      St\_R\_s(A, id, k'_{1}, \ldots, k'_{m}) &\in r \text{ where } m \geq n \\
    \end{align*}
    To be well-formed, all terms
    \begin{equation*}
      \lbrace k'_{1}, k'_{2}, \ldots, k'_{m} \rbrace \cup \lbrace t \vert \mathtt{Out}(t) \in r \rbrace
    \end{equation*}
    are derivable from the terms
    \begin{equation*}
      PV \cup \lbrace k_{1}, k_{2}, \ldots, k_{n} \rbrace \cup \lbrace u \vert \mathtt{Fr}(u) \in l \rbrace \cup \lbrace v \vert \mathtt{In}(v) \in l \rbrace
    \end{equation*}
    \textbf{AND}
    \begin{equation*}
      s = r+1
    \end{equation*}
  \end{solution}

\question{} How can you write protocol rules for a given protocol?
\question{} Assume that you are given a public key-based protocol. How could you write the initialization and protocol rules for it? How could you prepare the protocol and split the roles?
\question{} What is protocol instrumentation? What is a claim event $Claim\_claimtype(A,t)$?
\question{} What is secrecy?
\question{} How is the role instrumentation for secrecy? What is $Claim\_secret(A,M)$? Where do you place the hexagon for secret (M) in role instrumentation for secrecy?
\question{} What is a compromised agent? When an agent is honest? What are Honest and Rev action facts?
\question{} How can you verify if secrecy claims hold for a given protocol? (See examples in slides 31--34 of lecture 9. See also an exercise here).
\question{} What is forward secrecy?
\question{} How can you find out that a given protocol provides forward secrecy? (See examples in slides 36--37 of lecture 9).
\question{} How is the role instrumentation for authentication? What are $Claim\_commit$ and $Claim\_running$ events? Where do you place Commit and Running hexagons when A wants to agree with B?\@ Where do you place them when B wants to agree with A?\@
\question{} How do you model a protocol using Tamarin? How do you write a labeled multiset-rewriting rule in Tamarin?
\question{} What are linear and persistent facts in Tamarin? When do you use \texttt{!} or \texttt{\textasciitilde{}} or \texttt{\$} in Tamarin?
\question{} What does $\langle x, y \rangle$ mean in Tamarin?
\end{questions}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EITP20-Secure_Systems_Engineering-Study_Questions"
%%% End:
