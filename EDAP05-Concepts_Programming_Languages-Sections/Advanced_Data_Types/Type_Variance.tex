\subsubsection{Variance of Types}\label{subsubsec:Type_Variance}
\textbf{TODO!! Give Example of each, with reasoning!}
Using a \texttt{\SemanticType{Box}} Scala trait as the basis of our discussion, the code is shown below.
\inputminted[frame=lines,linenos]{scala}{./EDAP05-Concepts_Programming_Languages-Sections/Advanced_Data_Types/Code/Box.scala}

\begin{definition}[Covariance]\label{def:Type_Covariance}
  Let $\DataType$ be a type constructor with formal type parameters $\DataType_{1}, \ldots , \DataType_{k}$, such that $\SemanticType{T} = \DataType [\DataType_{1}, \ldots, \DataType_{k}]$ is a type.
  Let $i \in \lbrace 1,\ldots, k \rbrace$.

  If for all $\DataType_{i}' <: \DataType_{i}$ we can always substitute a value of type $\DataType [\DataType_{1}',\ldots, \DataType_{i}', \ldots, \DataType_{k}']$ in a context that expects a value of type $\DataType [\DataType_{1}, \ldots, \DataType_{i}, \ldots, \DataType_{k}]$ without violating type preservation then $\DataType_{i}$ is \emph{covariant} in $\SemanticType{T}$.

  Using the \SemanticType{Box} example from above, we can create an \emph{covariant} Scala trait by writing something like this,
  \inputminted[frame=lines,linenos]{scala}{./EDAP05-Concepts_Programming_Languages-Sections/Advanced_Data_Types/Code/CovariantBox.scala}
  When we vary the type parameter \SemanticType{T} towards a subtype, the type of \SemanticType{ReadBox[T]} also varies towards that of a subtype; we say that \SemanticType{T} is \textbf{covariant}.
\end{definition}

\begin{definition}[Contravariance]\label{def:Type_Contravariance}
  Let $\DataType$ be a type constructor with formal type parameters $\DataType_{1}, \ldots , \DataType_{k}$, such that $\SemanticType{T} = \DataType [\DataType_{1}, \ldots, \DataType_{k}]$ is a type.
  Let $i \in \lbrace 1,\ldots, k \rbrace$.

  If for all $\DataType_{i}' :> \DataType_{i}$ we can always substitute a value of type $\DataType [\DataType_{1}',\ldots, \DataType_{i}', \ldots, \DataType_{k}']$ in a context that expects a value of type $\DataType [\DataType_{1}, \ldots, \DataType_{i}, \ldots, \DataType_{k}]$ without violating type preservation then $\DataType_{i}$ is \emph{contravariant} in $\SemanticType{T}$.
\end{definition}

\begin{definition}[Invariance]\label{def:Type_Invariance}
  Let $\DataType$ be a type constructor with formal type parameters $\DataType_{1}, \ldots , \DataType_{k}$, such that $\SemanticType{T} = \DataType [\DataType_{1}, \ldots, \DataType_{k}]$ is a type.
  Let $i \in \lbrace 1,\ldots, k \rbrace$.


  If $\DataType_{i}$ is neither covariant nor contravariant in $\SemanticType{T}$, then $\DataType_{i}$ is \emph{invariant} in $\SemanticType{T}$.
\end{definition}

\begin{definition}[Bivariance]\label{def:Type_Bivariance}
  Let $\DataType$ be a type constructor with formal type parameters $\DataType_{1}, \ldots , \DataType_{k}$, such that $\SemanticType{T} = \DataType [\DataType_{1}, \ldots, \DataType_{k}]$ is a type.
  Let $i \in \lbrace 1,\ldots, k \rbrace$.

  If for all $\DataType_{i}' <: \DataType_{i}$ we can always substitute a value of type $\DataType [\DataType_{1}',\ldots, \DataType_{i}', \ldots, \DataType_{k}']$ in a context that expects a value of type $\DataType [\DataType_{1}, \ldots, \DataType_{i}, \ldots, \DataType_{k}]$ without violating type preservation \textbf{AND}, if for all $\DataType_{i}' :> \DataType_{i}$ we can always substitute a value of type $\DataType' [\DataType_{1}', \ldots, \DataType_{i}', \ldots, \DataType_{k}']$ in a context that expects a value of type $\DataType [\DataType_{1}, \ldots, \DataType_{i}, \ldots, \DataType_{k}]$ without violating type preservation then $\DataType_{i}$ is \emph{bivariant} in $\SemanticType{T}$.

  \begin{remark}
    If both the input and output allow for the type to be both broadened and narrowed, it is not terribly interesting to study.
    Thus, we will not be studying them in much detail in this class.
  \end{remark}
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
