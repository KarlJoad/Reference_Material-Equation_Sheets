\subsection{Introduction to Data Abstraction}\label{subsec:Intro_Data_Abstraction}
An \emph{\nameref{def:Abstract_Data_Type}} is a data structure, in the form of a record, but includes subprograms that manipulate its data.
It is an enclosure that only includes the data representations of one specific \nameref{def:Data_Type}, and the subprograms provide operations for that type.
This allows unnecessary details of the type to be hidden from units outside the enclosure.

\begin{definition}[Object]\label{def:Object}
  An instance of an \nameref{def:Abstract_Data_Type} is called an \emph{object}.
\end{definition}

\nameref{def:Abstract_Data_Type}s are used to combat program complexity by grouping things together similarly to how we would group them in the real-world as humans.

\subsubsection{Floating-Point as an Abstract Data Type}\label{subsubsec:Floating_Point_Abstract_Data_Type}
Technically, all \nameref{def:Data_Type}s are \nameref{def:Abstract_Data_Type}s.
These are implementations of information hiding, as the programmer does not usually (C/C++ are semi-counter-examples) have direct access to manipulate the bits that make up the number.
They only have the operations presented to them by the language designer and implementer.

Overall, this improved program \nameref{subsec:Reliability} and portability.

\subsubsection{User-Defined Abstract Data Types}\label{subsubsec:User_Defined_Abstract_Data_Types}
\begin{definition}[Abstract Data Type]\label{def:Abstract_Data_Type}
  An \emph{abstract data type} has 2 components:
  \begin{enumerate}[noitemsep]
  \item The enclosure that ``displays'' what operations are possible on this \nameref{def:Data_Type} is called the \nameref{def:ADT_Interface}.
  \item The code that implements the functionality specified by the interface is called the \nameref{def:ADT_Implementation}.
  \end{enumerate}

  An abstract data type is a \nameref{def:Data_Type} that satisfies the following conditions:
  \begin{itemize}[noitemsep]
  \item The representation of objects of the type is hidden from the program units that use that type, so they only direct operations possible on those objects are those provided in the abstract data type's definition. This improves:
    \begin{itemize}[noitemsep]
    \item Increases \nameref{subsec:Reliability}
    \item Clients (Units using an abstract data type) cannot manipulate the underlying representation of objects directly
    \item Objects can be changed only through the provided operations
    \item Reduces the range of code and the number of \nameref{def:Variable}s the programmer must be aware of when reading/writing a program
    \item Reduces the likelihood of naming conflicts
    \end{itemize}
  \item The declarations of the type and the protocols of the operations on objects of the abstract data type, which provide the type's interface, are contained in a single syntactic unit. This benefits the language by:
    \begin{itemize}[noitemsep]
    \item Organizing the program into logical units that can be compiled separately.
    \end{itemize}
  \item The type's interface does not depend on the underlying representation of the objects, or the implementation of the operations.
    \begin{itemize}[noitemsep]
    \item For example, if a stack is implemented with a linked list, then needs to be changed to an array-like structure, the underlying representation can be changed without affecting any clients that are using the subprograms and \nameref{def:Variable}s.
    \item Accessing and modifying data in an abstract data type is done with \emph{getters} and \emph{setters} that allow clients indirect access to the hidden data. There are 3 reasons why this is an improvement:
      \begin{enumerate}[noitemsep]
      \item Read-only access can be provided, by having a getter method, but no corresponding setter method.
      \item Constraints can be included in setters. The setter can enforce the range that a data value can take.
      \item The actual implementation of the data memvers can be changed without affecting the clients, if getters and setters are the only access.
      \end{enumerate}
    \end{itemize}
  \item Also, other program units are allowed to create \nameref{def:Variable}s of the defined abstract data type.
  \end{itemize}
\end{definition}

\begin{definition}[Interface]\label{def:ADT_Interface}
  An \emph{interface} is the programmer-usable ``contract'' that can be used for an \nameref{def:Abstract_Data_Type}.
  It ensures that all programmers who use this \nameref{def:Abstract_Data_Type} have a common set of operations that behave in a defined manner.

  An example of an interface is C and C++'s header files (\texttt{*.h} for C, and \texttt{*.hpp} for C++).

  \begin{remark}
    The \nameref{def:ADT_Interface}, usually, does not contain any code.
    The code that implements the \nameref{def:ADT_Interface} is in the \nameref{def:ADT_Implementation} file.
    However, in Java, an \nameref{def:Abstract_Data_Type} requires that the method have a \nameref{def:Subprogram_Definition} at the same time as its \nameref{def:Subprogram_Declaration}.
  \end{remark}

  \begin{remark}[Reliance on Specification]\label{rmk:ADT_Interface_Specification}
    An \nameref{def:Abstract_Data_Type}'s \nameref{def:ADT_Interface} must have a specification to ensure that the \nameref{def:Abstract_Data_Type} has the expected operations.
    This is further discussed in \Cref{subsubsec:Specification_Abstract_Datatype}.
  \end{remark}
\end{definition}

\begin{definition}[Implementation]\label{def:ADT_Implementation}
  An \emph{implementation} is the language/project designer's implementation of the ``contract'' specified by the \nameref{def:ADT_Interface}.
  For any given problem, there may be a single \nameref{def:ADT_Interface}, but there may be many different possible implementations.

  For example, an integer vector, \texttt{IntVector} that is created with default values in every element would have a single \nameref{def:ADT_Interface}, but we could \emph{implement} the \texttt{IntVector} with several different data structures.
  We could use:
  \begin{itemize}[noitemsep]
  \item An array, for quick random accesses
  \item A linked list, for efficient memory usage
  \item A binary tree for relatively efficient lookups and appending of values, ith efficient memory usage.
  \end{itemize}

  \begin{remark}[Reliance on Specification]\label{rmk:ADT_Implementation_Specification}
    An \nameref{def:Abstract_Data_Type}'s \nameref{def:ADT_Implementation} must have a specification to ensure that the \nameref{def:Abstract_Data_Type} operates as expected.
    This is further discussed in \Cref{subsubsec:Specification_Abstract_Datatype}.
  \end{remark}
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
