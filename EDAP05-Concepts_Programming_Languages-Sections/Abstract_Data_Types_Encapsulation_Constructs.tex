\section{Abstract Data Types and Encapsulation Constructs}\label{sec:Abstract_Data_Types_Encapsulation_Constructs}
\subsection{The Concept of Abstraction}\label{subsec:Concept_Abstraction}
\begin{definition}[Abstraction]\label{def:Abstraction}
  An \emph{abstraction} is a view or representation of an entity that includes only the most significant attributes.
  In a general sense, abstraction allows one to collect instances of entities into groups in which their common attributes need not be considered, and their unique attributes separate entities which may be from the same group.

  There is:
  \begin{itemize}[noitemsep]
  \item \nameref{par:Process_Abstraction}
  \item \nameref{par:Data_Abstraction}
  \end{itemize}
\end{definition}

\subsection{Introduction to Data Abstraction}\label{subsec:Intro_Data_Abstraction}
An \emph{\nameref{def:Abstract_Data_Type}} is a data structure, in the form of a record, but includes subprograms that manipulate its data.
It is an enclosure that only includes the data representations of one specific \nameref{def:Data_Type}, and the subprograms provide operations for that type.
This allows unnecessary details of the type to be hidden from units outside the enclosure.

\begin{definition}[Object]\label{def:Object}
  An instance of an \nameref{def:Abstract_Data_Type} is called an \emph{object}.
\end{definition}

\nameref{def:Abstract_Data_Type}s are used to combat program complexity by grouping things together similarly to how we would group them in the real-world as humans.

\subsubsection{Floating-Point as an Abstract Data Type}\label{subsubsec:Floating_Point_Abstract_Data_Type}
Technically, all \nameref{def:Data_Type}s are \nameref{def:Abstract_Data_Type}s.
These are implementations of information hiding, as the programmer does not usually (C/C++ are semi-counter-examples) have direct access to manipulate the bits that make up the number.
They only have the operations presented to them by the language designer and implementer.

Overall, this improved program \nameref{subsec:Reliability} and portability.

\subsubsection{User-Defined Abstract Data Types}\label{subsubsec:User_Defined_Abstract_Data_Types}
\begin{definition}[Abstract Data Type]\label{def:Abstract_Data_Type}
  An \emph{abstract data type} is a \nameref{def:Data_Type} that satisfies the following conditions:
  \begin{itemize}[noitemsep]
  \item The representation of objects of the type is hidden from the program units that use that type, so they only direct operations possible on those objects are those provided in the abstract data type's definition. This improves:
    \begin{itemize}[noitemsep]
    \item Increases \nameref{subsec:Reliability}
    \item Clients (Units using an abstract data type) cannot manipulate the underlying representation of objects directly
    \item Objects can be changed only through the provided operations
    \item Reduces the range of code and the number of \nameref{def:Variable}s the programmer must be aware of when reading/writing a program
    \item Reduces the likelihood of naming conflicts
    \end{itemize}
  \item The declarations of the type and the protocols of the operations on objects of the abstract data type, which provide the type's interface, are contained in a single syntactic unit. This benefits the language by:
    \begin{itemize}[noitemsep]
    \item Organizing the program into logical units that can be compiled separately.
    \end{itemize}
  \item The type's interface does not depend on the underlying representation of the objects, or the implementation of the operations.
    \begin{itemize}[noitemsep]
    \item For example, if a stack is implemented with a linked list, then needs to be changed to an array-like structure, the underlying representation can be changed without affecting any clients that are using the subprograms and \nameref{def:Variable}s.
    \item Accessing and modifying data in an abstract data type is done with \emph{getters} and \emph{setters} that allow clients indirect access to the hidden data. There are 3 reasons why this is an improvement:
      \begin{enumerate}[noitemsep]
      \item Read-only access can be provided, by having a getter method, but no corresponding setter method.
      \item Constraints can be included in setters. The setter can enforce the range that a data value can take.
      \item The actual implementation of the data memvers can be changed without affecting the clients, if getters and setters are the only access.
      \end{enumerate}
    \end{itemize}
  \item Also, other program units are allowed to create \nameref{def:Variable}s of the defined abstract data type.
  \end{itemize}
\end{definition}


\subsection{Design Issues for Abstract Data Types}\label{subsec:Abstract_Data_Type_Design_Issues}
\begin{itemize}[noitemsep]
\item The \nameref{def:Abstract_Data_Type} name must be externally visible, to allow for object creation
\item The \nameref{def:Abstract_Data_Type} representation must be hidden.
\item There are few built-in operations by a language for \nameref{def:Abstract_Data_Type} operations
  \begin{itemize}[noitemsep]
  \item If there are some defined, they are the most basic ones: assignment, comparison.
  \item Overloading of subprograms should be allowed
  \end{itemize}
\item The form of the container for the interface to the \nameref{def:Abstract_Data_Type}.
\item Whether \nameref{def:Abstract_Data_Type} can be parameterized.
\item What access controls are provided, and how are such controls specified?
\item Is the specification of the \nameref{def:Abstract_Data_Type} physically separate from its implementation?
\end{itemize}

\subsection{Language Examples}\label{subsec:Abstract_Data_Type_Lang_Examples}
All of the examples in this section are for the same structure.

\subsubsection{Abstract Data Types in Ada}\label{subsubsec:Abstract_Data_Types_Ada}
Ada provides an encapsulation construct that can define a single \nameref{def:Abstract_Data_Type}, including the ability to hide its representation.
These encapsulation constructs are a more general approach than a pure \nameref{def:Abstract_Data_Type}.
Thus, they fulfill more roles, but can still be used to create an \nameref{def:Abstract_Data_Type}..

\paragraph{Encapsulation}\label{par:Ada_Encapsulation}
\begin{definition}[Package]\label{def:Ada_Package}
  Ada's encapsulating constructs are called \emph{package}s.
  A package can have 2 parts, both of which can \textit{also} be called a package.
  Not all packages have both of these parts.
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Ada_Package_Specification}
  \item \nameref{def:Ada_Body_Package}
  \end{enumerate}

  A \nameref{def:Ada_Package_Specification} and its \nameref{def:Ada_Body_Package} can be compiled separately, though the \nameref{def:Ada_Package_Specification} must be compiled first.
  Client code can also be compiled before teh \nameref{def:Ada_Body_Package} is compiled or written.
\end{definition}

\begin{definition}[Package Specification]\label{def:Ada_Package_Specification}
  Ada's \emph{package specification} provides the interface of the encapsulation, and sometimes more.
\end{definition}

\begin{definition}[Body Package]\label{def:Ada_Body_Package}
  Ada's \emph{body package} provides the implementation of most, or all, of the entities named in the associated package specification.
  The \nameref{def:Reserved_Word}, \texttt{body}, is used in the header to identify it as a body package.
\end{definition}

\paragraph{Information Hiding}\label{par:Ada_Info_Hiding}
The designer of an Ada \nameref{def:Ada_Package} that defined a \nameref{def:Abstract_Data_Type} can choose the make the entire type entirely visible to clients, or to only provide the interface information.\footnote{Though, if the \nameref{def:Ada_Package} does not hide its contents, it is not truly an \nameref{def:Abstract_Data_Type}.}

There are 2 methods to hide the representation:
\begin{enumerate}[noitemsep]
\item Include 2 sections in the \nameref{def:Ada_Package_Specification}, one where the entities are visible to the clients are defined, and one that hides its contents.
  \begin{itemize}[noitemsep]
  \item The declaration appears in the visible part of the specification, providing the name of the type and the fact its representation is hidden.
  \item The representation is part of the \texttt{private} part, which is introduced with that \nameref{def:Reserved_Word}.
  \end{itemize}
\item Hide the representation by defining the \nameref{def:Abstract_Data_Type} as a \nameref{def:Pointer} and provide the pointed-to structure's definition in the \nameref{def:Ada_Body_Package}, whose contents are hidden from clients.
\end{enumerate}
These 2 methods are so wildly different because of compilation issues that can arise.

Types that are declared to be private are called \nameref{def:Ada_Private_Type}.
\begin{definition}[Private Type]\label{def:Ada_Private_Type}
  Types that are declared to be private are called \emph{private type}s.
  They are declared to be private with the \texttt{private} \nameref{def:Reserved_Word}.
\end{definition}

An alternative to \nameref{def:Ada_Private_Type}s are \nameref{def:Ada_Limited_Private_Type}s.
\begin{definition}[Limited Private Type]\label{def:Ada_Limited_Private_Type}
  \emph{Limited private type}s are an alternative to \nameref{def:Ada_Private_Type}s.
  These are more restricted, in that the are described in the private section of a \nameref{def:Ada_Package_Specification}.
  They have \emph{no} built-in operations at all.
  These are useful when the usual predefined operations of assignment and comparison are not useful.

  They are declared with the \texttt{limited private} \nameref{def:Reserved_Word}.
\end{definition}

These have built-in operations for assignment and comparisons for equality/inequality.
Any other operations must be defined in the \nameref{def:Ada_Package_Specification}.

\paragraph{Example}\label{par:Ada_Abstract_Data_Type_Example}
\inputminted[frame=lines,linenos]{ada}{./EDAP05-Concepts_Programming_Languages-Sections/Code/Class_Example-Stack-Ada-Package.ada}
\inputminted[frame=lines,linenos]{ada}{./EDAP05-Concepts_Programming_Languages-Sections/Code/Class_Example-Stack-Ada.ada}

\paragraph{Evaluation}\label{par:Ada_Abstract_Data_Type_Evaluation}
Ada was the first \textbf{commercial} language that supported \nameref{def:Abstract_Data_Type}s\footnote{There were academic languages (CLU) that supported \nameref{def:Abstract_Data_Type}s before Ada.}.
Though, their design may seem complicated and repetitious, it is very powerful, and very reliable.

\subsubsection{Abstract Data Types in C++}\label{subsubsec:Abstract_Data_Types_C++}
\paragraph{Encapsulation}\label{par:C++_Encapsulation}
\paragraph{Information Hiding}\label{par:C++_Info_Hiding}
\paragraph{Constructors and Destructors}\label{par:C++_Constructors_Destructors}
\paragraph{Example}\label{par:C++_Abstract_Data_Type_Example}
\inputminted[frame=lines,linenos]{c++}{./EDAP05-Concepts_Programming_Languages-Sections/Code/Class_Example-Stack-CPP.cpp}

If a header file is used to help modularize the program, the same program can be written this way.
\inputminted[frame=lines,linenos]{c++}{./EDAP05-Concepts_Programming_Languages-Sections/Code/Class_Example-Stack-Header-CPP.hpp}
\inputminted[frame=lines,linenos]{c++}{./EDAP05-Concepts_Programming_Languages-Sections/Code/Class_Example-Stack-Header-CPP.cpp}

\paragraph{Evaluation}\label{par:C++_Abstract_Data_Type_Evaluation}
C++ supports \nameref{def:Abstract_Data_Type}s with its class construct.
This offers similar power as Ada's \nameref{def:Ada_Package}s.
Both provide effective methods for encapsulation and information hiding of \nameref{def:Abstract_Data_Type}s.

The largest difference is that classes are \nameref{def:Data_Type}s themselves, whereas Ada \nameref{def:Ada_Package}s are more general encapsulations.
Also, Ada's \nameref{def:Ada_Package}s were designed for more than \nameref{par:Data_Abstraction}.

\subsubsection{Abstract Data Types in Objective-C}\label{subsubsec:Abstract_Data_Types_Objective_C}
Objective-C is similar to C++, in that it was designed as an extension to C to support object-oriented programming.
However, Objective-C uses the Smalltalk syntax for its method calls.

\paragraph{Encapsulation}\label{par:Objective_C_Encapsulation}
The development of the \nameref{def:Abstract_Data_Type}'s interface and actual code are separated in Objective-C.
\begin{definition}[Interface]\label{def:Objective_C_Class_Interface}
  In Objective-C, the interface portion of an \nameref{def:Abstract_Data_Type} class is defined in a container called an \emph{interface}.
  It has the following general syntax:
\begin{minted}[frame=lines,linenos]{objective-c}
@interface class-name: parent-class {
  instance-variable-declarations
}
  method-prototypes
  (+ | -) (return-type) method-name [: (formal-parameters) ];
@end
\end{minted}
  \begin{itemize}[noitemsep]
  \item The \texttt{+} indicates the method is a class method (Shared among all instances of this class).
  \item The \texttt{-} indicates the method is an instance method.
  \item The brackets around the \nameref{def:Formal_Parameter}s means the colon and parenthesized formal parameter list is optional.
  \item If the list is present, then the delimiter is the colon, \texttt{:}.
  \end{itemize}
\end{definition}

\begin{definition}[Implementation]\label{def:Objective_C_Class_Implementation}
  The implementation of the \nameref{def:Abstract_Data_Type} class defined with an \nameref{def:Objective_C_Class_Interface} is a container that implements (obviously) the actual code.
  This is generally called the \emph{implementation}.
  These implementations have the following general syntax:
\begin{minted}[frame=lines,linenos]{objective-c}
@implementation class-name
  method-definitions
@end
\end{minted}
\end{definition}

\begin{definition}[Initializers]\label{def:Objective_C_Class_Initializers}
  Objective-C does not have constructors.
  Instead, it has \emph{initializers}.
  They only provide initial values, and can be given any name.
  Since they can have any name, they \textbf{must} be called explicitly.
\end{definition}

Method calls are done with brackets.
If there are \nameref{def:Formal_Parameter}s in the called function, the \nameref{def:Actual_Parameter}s are passed with a colon, like in the function definition.
For example,
\begin{minted}[frame=lines,linenos]{objective-c}
Adder *myAdder = [[Adder alloc]init]; // Object call to initializer. This one takes no parameters
[myAdder add1: 7]; // Object call to function with parameters, passing 7
\end{minted}

An \nameref{def:Object} is creaetd by using the \texttt{alloc} \nameref{def:Reserved_Word}.,

All class instances, \nameref{def:Object}s, are \nameref{def:Heap_Dynamic_Variable}, and are referenced through \nameref{def:Reference}s.

\paragraph{Information Hiding}\label{par:Objective_C_Info_Hiding}
Objective-C uses a setup similar to C++, with \texttt{@private} and \texttt{@public} directives to specify access levels.
However, the default access level is actually a \textit{protected} level of access, rather than \textit{private} as in C++.
There is also no way to restrict access to a method.

\paragraph{Example}\label{par:Objective_C_Abstract_Data_Type_Example}
\inputminted[frame=lines,linenos]{objective-c}{./EDAP05-Concepts_Programming_Languages-Sections/Code/Class_Example-Stack-Objective_C.m}

\paragraph{Evaluation}\label{par:Objective_C_Abstract_Data_Type_Evaluation}
Objective-C's classes are also \nameref{def:Data_Type}s.
However, the support for \nameref{def:Abstract_Data_Type}s is adequate.
The complete dissimilarity between the C syntax and Smalltalk syntax is also quite confusing.

One deficiency is the lack of ability to restrict access to methods.
Another small deficiency is the requirement that constructors be called explicitly.

\subsubsection{Abstract Data Types in Java}\label{subsubsec:Abstract_Data_Types_Java}
In Java, the method body \textbf{must} appear with its corresponding method header, meaning the an \nameref{def:Abstract_Data_Type} is both declared and defined as a single syntactic unit, at the same time.
All \nameref{def:Object}s are allocated from the \nameref{def:Heap} and accessed through \nameref{def:Reference}s.

There is also no need to write destructor methods in Java, because of the implicit garbage collection it uses.

\paragraph{Example}\label{par:Java_Abstract_Data_Type_Example}
\inputminted[frame=lines,linenos]{java}{./EDAP05-Concepts_Programming_Languages-Sections/Code/Class_Example-Stack-Java.java}

\paragraph{Evaluation}\label{par:Java_Abstract_Data_Type_Evaluation}
Java is different in mostly cosmetic ways to C++.
Overall, they offer the same level of support for the design of \nameref{def:Abstract_Data_Type}s.

\subsubsection{Abstract Data Types in C\#}\label{subsubsec:Abstract_Data_Types_CSharp}
All \nameref{def:Object}s are \nameref{def:Heap_Dynamic_Variable}s.
Default constructors are defined for all classes, and assign default values to all \nameref{def:Abstract_Data_Type} \nameref{def:Variable}s present.
The programmer can define as many constructors as desired.
Destructors can be defined, but because C\# uses implicit garbage collection on nearly everything, this is usually not a big deal.

\paragraph{Encapsulation}\label{par:Objective_C_Encapsulation}
\paragraph{Information Hiding}\label{par:Objective_C_Info_Hiding}

\subsubsection{Abstract Data Types in Ruby}\label{subsubsec:Abstract_Data_Types_Ruby}
Ruby provides similar support for \nameref{def:Abstract_Data_Type}s and classes as Java and C++.

\paragraph{Encapsulation}\label{par:Ruby_Encapsulation}
In Ruby, a class definition is a compound statement.

Classes are also dynamic, in that members can be added at any time.
The removal of methods is allowed.

\paragraph{Information Hiding}\label{par:Ruby_Info_Hiding}
Access controls for methods are dynamic, so access violations are only detected during execution.
The default method access level is \texttt{public}, but it can also be \texttt{protected} or \texttt{private}.

All data members of an \nameref{def:Abstract_Data_Type} are private, and that \textbf{cannot} be changed.
\paragraph{Example}\label{par:Ruby_Abstract_Data_Type_Example}
\inputminted[frame=lines,linenos]{ruby}{./EDAP05-Concepts_Programming_Languages-Sections/Code/Class_Example-Stack-Ruby.rb}

\paragraph{Evaluation}\label{par:Ruby_Abstract_Data_Type_Evaluation}
Everything is an \nameref{def:Object} in Ruby, and arrays are arrays of references to \nameref{def:Object}s.
Ruby also has dynamic-length arrays be default, so this stack implementation is the most flexible of them all.
It can store an arbitrary number of items, and can store any type of item, including items of different \nameref{def:Data_Type}s.

\subsection{Variance of Types}\label{subsec:Type_Variance}
\begin{definition}[Covariance]\label{def:Type_Covariance}
  Let $\DataType$ be a type constructor with formal type parameters $\DataType_{1}, \ldots , \DataType_{k}$, such that $\SemanticType{T} = \DataType [\DataType_{1}, \ldots, \DataType_{k}]$ is a type.
  Let $i \in \lbrace 1,\ldots, k \rbrace$.

  If for all $\DataType_{i}' <: \DataType_{i}$ we can always substitute a value of type $\DataType [\DataType_{1}',\ldots, \DataType_{i}', \ldots, \DataType_{k}']$ in a context that expects a value of type $\DataType [\DataType_{1}, \ldots, \DataType_{i}, \ldots, \DataType_{k}]$ without violating type preservation then $\DataType_{i}$ is \emph{covariant} in $\SemanticType{T}$.
\end{definition}

\begin{definition}[Contravariance]\label{Type_Contravariance}
  Let $\DataType$ be a type constructor with formal type parameters $\DataType_{1}, \ldots , \DataType_{k}$, such that $\SemanticType{T} = \DataType [\DataType_{1}, \ldots, \DataType_{k}]$ is a type.
  Let $i \in \lbrace 1,\ldots, k \rbrace$.

  If for all $\DataType_{i}' :> \DataType_{i}$ we can always substitute a value of type $\DataType [\DataType_{1}',\ldots, \DataType_{i}', \ldots, \DataType_{k}']$ in a context that expects a value of type $\DataType [\DataType_{1}, \ldots, \DataType_{i}, \ldots, \DataType_{k}]$ without violating type preservation then $\DataType_{i}$ is \emph{contravariant} in $\SemanticType{T}$.
\end{definition}

\begin{definition}[Invariance]\label{def:Type_Invariance}
  Let $\DataType$ be a type constructor with formal type parameters $\DataType_{1}, \ldots , \DataType_{k}$, such that $\SemanticType{T} = \DataType [\DataType_{1}, \ldots, \DataType_{k}]$ is a type.
  Let $i \in \lbrace 1,\ldots, k \rbrace$.


  If $\DataType_{i}$ is neither covariant nor contravariant in $\SemanticType{T}$, then $\DataType_{i}$ is \emph{invariant} in $\SemanticType{T}$.
\end{definition}

\begin{definition}[Bivariance]\label{def:Type_Bivariance}
  Let $\DataType$ be a type constructor with formal type parameters $\DataType_{1}, \ldots , \DataType_{k}$, such that $\SemanticType{T} = \DataType [\DataType_{1}, \ldots, \DataType_{k}]$ is a type.
  Let $i \in \lbrace 1,\ldots, k \rbrace$.

  If for all $\DataType_{i}' <: \DataType_{i}$ we can always substitute a value of type $\DataType [\DataType_{1}',\ldots, \DataType_{i}', \ldots, \DataType_{k}']$ in a context that expects a value of type $\DataType [\DataType_{1}, \ldots, \DataType_{i}, \ldots, \DataType_{k}]$ without violating type preservation \textbf{AND}, if for all $\DataType_{i}' :> \DataType_{i}$ we can always substitute a value of type $\DataType' [\DataType_{1}', \ldots, \DataType_{i}', \ldots, \DataType_{k}']$ in a context that expects a value of type $\DataType [\DataType_{1}, \ldots, \DataType_{i}, \ldots, \DataType_{k}]$ without violating type preservation then $\DataType_{i}$ is \emph{bivariant} in $\SemanticType{T}$.

  \begin{remark}
    If both the input and output allow for the type to be both broadened and narrowed, it is not terribly interesting to study.
    Thus, we will not be studying them in much detail in this class.
  \end{remark}
\end{definition}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
