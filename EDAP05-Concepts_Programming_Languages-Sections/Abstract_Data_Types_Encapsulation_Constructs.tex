\section{Abstract Data Types and Encapsulation Constructs}\label{sec:Abstract_Data_Types_Encapsulation_Constructs}
\subsection{The Concept of Abstraction}\label{subsec:Concept_Abstraction}
\begin{definition}[Abstraction]\label{def:Abstraction}
  An \emph{abstraction} is a view or representation of an entity that includes only the most significant attributes.
  In a general sense, abstraction allows one to collect instances of entities into groups in which their common attributes need not be considered, and their unique attributes separate entities which may be from the same group.

  There is:
  \begin{itemize}[noitemsep]
  \item \nameref{par:Process_Abstraction}
  \item \nameref{par:Data_Abstraction}
  \end{itemize}
\end{definition}

\subsection{Introduction to Data Abstraction}\label{subsec:Intro_Data_Abstraction}
An \emph{\nameref{def:Abstract_Data_Type}} is a data structure, in the form of a record, but includes subprograms that manipulate its data.
It is an enclosure that only includes the data representations of one specific \nameref{def:Data_Type}, and the subprograms provide operations for that type.
This allows unnecessary details of the type to be hidden from units outside the enclosure.

\begin{definition}[Object]\label{def:Object}
  An instance of an \nameref{def:Abstract_Data_Type} is called an \emph{object}.
\end{definition}

\nameref{def:Abstract_Data_Type}s are used to combat program complexity by grouping things together similarly to how we would group them in the real-world as humans.

\subsubsection{Floating-Point as an Abstract Data Type}\label{subsubsec:Floating_Point_Abstract_Data_Type}
Technically, all \nameref{def:Data_Type}s are \nameref{def:Abstract_Data_Type}s.
These are implementations of information hiding, as the programmer does not usually (C/C++ are semi-counter-examples) have direct access to manipulate the bits that make up the number.
They only have the operations presented to them by the language designer and implementer.

Overall, this improved program \nameref{subsec:Reliability} and portability.

\subsubsection{User-Defined Abstract Data Types}\label{subsubsec:User_Defined_Abstract_Data_Types}
\begin{definition}[Abstract Data Type]\label{def:Abstract_Data_Type}
  An \emph{abstract data type} is a \nameref{def:Data_Type} that satisfies the following conditions:
  \begin{itemize}[noitemsep]
  \item The representation of objects of the type is hidden from the program units that use that type, so they only direct operations possible on those objects are those provided in the abstract data type's definition. This improves:
    \begin{itemize}[noitemsep]
    \item Increases \nameref{subsec:Reliability}
    \item Clients (Units using an abstract data type) cannot manipulate the underlying representation of objects directly
    \item Objects can be changed only through the provided operations
    \item Reduces the range of code and the number of \nameref{def:Variable}s the programmer must be aware of when reading/writing a program
    \item Reduces the likelihood of naming conflicts
    \end{itemize}
  \item The declarations of the type and the protocols of the operations on objects of the abstract data type, which provide the type's interface, are contained in a single syntactic unit. This benefits the language by:
    \begin{itemize}[noitemsep]
    \item Organizing the program into logical units that can be compiled separately.
    \end{itemize}
  \item The type's interface does not depend on the underlying representation of the objects, or the implementation of the operations.
    \begin{itemize}[noitemsep]
    \item For example, if a stack is implemented with a linked list, then needs to be changed to an array-like structure, the underlying representation can be changed without affecting any clients that are using the subprograms and \nameref{def:Variable}s.
    \item Accessing and modifying data in an abstract data type is done with \emph{getters} and \emph{setters} that allow clients indirect access to the hidden data. There are 3 reasons why this is an improvement:
      \begin{enumerate}[noitemsep]
      \item Read-only access can be provided, by having a getter method, but no corresponding setter method.
      \item Constraints can be included in setters. The setter can enforce the range that a data value can take.
      \item The actual implementation of the data memvers can be changed without affecting the clients, if getters and setters are the only access.
      \end{enumerate}
    \end{itemize}
  \item Also, other program units are allowed to create \nameref{def:Variable}s of the defined abstract data type.
  \end{itemize}
\end{definition}


\subsection{Design Issues for Abstract Data Types}\label{subsec:Abstract_Data_Type_Design_Issues}
\begin{itemize}[noitemsep]
\item The \nameref{def:Abstract_Data_Type} name must be externally visible, to allow for object creation
\item The \nameref{def:Abstract_Data_Type} representation must be hidden.
\item There are few built-in operations by a language for \nameref{def:Abstract_Data_Type} operations
  \begin{itemize}[noitemsep]
  \item If there are some defined, they are the most basic ones: assignment, comparison.
  \item Overloading of subprograms should be allowed
  \end{itemize}
\item The form of the container for the interface to the \nameref{def:Abstract_Data_Type}.
\item Whether \nameref{def:Abstract_Data_Type} can be parameterized.
\item What access controls are provided, and how are such controls specified?
\item Is the specification of the \nameref{def:Abstract_Data_Type} physically separate from its implementation?
\end{itemize}

\subsection{Language Examples}\label{subsec:Abstract_Data_Type_Lang_Examples}
All of the examples in this section are for the same structure.

\subsubsection{Abstract Data Types in Ada}\label{subsubsec:Abstract_Data_Types_Ada}
Ada provides an encapsulation construct that can define a single \nameref{def:Abstract_Data_Type}, including the ability to hide its representation.
These encapsulation constructs are a more general approach than a pure \nameref{def:Abstract_Data_Type}.
Thus, they fulfill more roles, but can still be used to create an \nameref{def:Abstract_Data_Type}..

\paragraph{Encapsulation}\label{par:Ada_Encapsulation}
\begin{definition}[Package]\label{def:Ada_Package}
  Ada's encapsulating constructs are called \emph{package}s.
  A package can have 2 parts, both of which can \textit{also} be called a package.
  Not all packages have both of these parts.
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Ada_Package_Specification}
  \item \nameref{def:Ada_Body_Package}
  \end{enumerate}

  A \nameref{def:Ada_Package_Specification} and its \nameref{def:Ada_Body_Package} can be compiled separately, though the \nameref{def:Ada_Package_Specification} must be compiled first.
  Client code can also be compiled before teh \nameref{def:Ada_Body_Package} is compiled or written.
\end{definition}

\begin{definition}[Package Specification]\label{def:Ada_Package_Specification}
  Ada's \emph{package specification} provides the interface of the encapsulation, and sometimes more.
\end{definition}

\begin{definition}[Body Package]\label{def:Ada_Body_Package}
  Ada's \emph{body package} provides the implementation of most, or all, of the entities named in the associated package specification.
  The \nameref{def:Reserved_Word}, \texttt{body}, is used in the header to identify it as a body package.
\end{definition}

\paragraph{Information Hiding}\label{par:Ada_Info_Hiding}
The designer of an Ada \nameref{def:Ada_Package} that defined a \nameref{def:Abstract_Data_Type} can choose the make the entire type entirely visible to clients, or to only provide the interface information.\footnote{Though, if the \nameref{def:Ada_Package} does not hide its contents, it is not truly an \nameref{def:Abstract_Data_Type}.}

There are 2 methods to hide the representation:
\begin{enumerate}[noitemsep]
\item Include 2 sections in the \nameref{def:Ada_Package_Specification}, one where the entities are visible to the clients are defined, and one that hides its contents.
  \begin{itemize}[noitemsep]
  \item The declaration appears in the visible part of the specification, providing the name of the type and the fact its representation is hidden.
  \item The representation is part of the \texttt{private} part, which is introduced with that \nameref{def:Reserved_Word}.
  \end{itemize}
\item Hide the representation by defining the \nameref{def:Abstract_Data_Type} as a \nameref{def:Pointer} and provide the pointed-to structure's definition in the \nameref{def:Ada_Body_Package}, whose contents are hidden from clients.
\end{enumerate}
These 2 methods are so wildly different because of compilation issues that can arise.

Types that are declared to be private are called \nameref{def:Ada_Private_Type}.
\begin{definition}[Private Type]\label{def:Ada_Private_Type}
  Types that are declared to be private are called \emph{private type}s.
  They are declared to be private with the \texttt{private} \nameref{def:Reserved_Word}.
\end{definition}

\paragraph{Example}\label{par:Ada_Abstract_Data_Type_Example}
\paragraph{Evaluation}\label{par:Ada_Abstract_Data_Type_Evaluation}

\subsubsection{Abstract Data Types in C++}\label{subsubsec:Abstract_Data_Types_C++}
\paragraph{Encapsulation}\label{par:C++_Encapsulation}
\paragraph{Information Hiding}\label{par:C++_Info_Hiding}
\paragraph{Constructors and Destructors}\label{par:C++_Constructors_Destructors}
\paragraph{Example}\label{par:C++_Abstract_Data_Type_Example}
\paragraph{Evaluation}\label{par:C++_Abstract_Data_Type_Evaluation}

\subsubsection{Abstract Data Types in Objective-C}\label{subsubsec:Abstract_Data_Types_Objective_C}
\paragraph{Encapsulation}\label{par:Objective_C_Encapsulation}
\paragraph{Information Hiding}\label{par:Objective_C_Info_Hiding}
\paragraph{Example}\label{par:Objective_C_Abstract_Data_Type_Example}
\paragraph{Evaluation}\label{par:Objective_C_Abstract_Data_Type_Evaluation}

\subsubsection{Abstract Data Types in Java}\label{subsubsec:Abstract_Data_Types_Java}
\paragraph{Example}\label{par:Java_Abstract_Data_Type_Example}
\paragraph{Evaluation}\label{par:Java_Abstract_Data_Type_Evaluation}

\subsubsection{Abstract Data Types in C\#}\label{subsubsec:Abstract_Data_Types_CSharp}
\paragraph{Encapsulation}\label{par:Objective_C_Encapsulation}
\paragraph{Information Hiding}\label{par:Objective_C_Info_Hiding}

\subsubsection{Abstract Data Types in Ruby}\label{subsubsec:Abstract_Data_Types_Ruby}
\paragraph{Encapsulation}\label{par:Ruby_Encapsulation}
\paragraph{Information Hiding}\label{par:Ruby_Info_Hiding}
\paragraph{Example}\label{par:Ruby_Abstract_Data_Type_Example}
\paragraph{Evaluation}\label{par:Ruby_Abstract_Data_Type_Evaluation}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
