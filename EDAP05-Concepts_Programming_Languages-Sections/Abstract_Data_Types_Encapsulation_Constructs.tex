\section{Abstract Data Types and Encapsulation Constructs}\label{sec:Abstract_Data_Types_Encapsulation_Constructs}
\subsection{The Concept of Abstraction}\label{subsec:Concept_Abstraction}
\begin{definition}[Abstraction]\label{def:Abstraction}
  An \emph{abstraction} is a view or representation of an entity that includes only the most significant attributes.
  In a general sense, abstraction allows one to collect instances of entities into groups in which their common attributes need not be considered, and their unique attributes separate entities which may be from the same group.

  There is:
  \begin{itemize}[noitemsep]
  \item \nameref{par:Process_Abstraction}, which is discussed elsewhere, with subprograms.
  \item \nameref{par:Data_Abstraction}.
  \end{itemize}
\end{definition}

\subsection{Introduction to Data Abstraction}\label{subsec:Intro_Data_Abstraction}
An \emph{\nameref{def:Abstract_Data_Type}} is a data structure, in the form of a record, but includes subprograms that manipulate its data.
It is an enclosure that only includes the data representations of one specific \nameref{def:Data_Type}, and the subprograms provide operations for that type.
This allows unnecessary details of the type to be hidden from units outside the enclosure.

\begin{definition}[Object]\label{def:Object}
  An instance of an \nameref{def:Abstract_Data_Type} is called an \emph{object}.
\end{definition}

\nameref{def:Abstract_Data_Type}s are used to combat program complexity by grouping things together similarly to how we would group them in the real-world as humans.

\subsubsection{Floating-Point as an Abstract Data Type}\label{subsubsec:Floating_Point_Abstract_Data_Type}
Technically, all \nameref{def:Data_Type}s are \nameref{def:Abstract_Data_Type}s.
These are implementations of information hiding, as the programmer does not usually (C/C++ are semi-counter-examples) have direct access to manipulate the bits that make up the number.
They only have the operations presented to them by the language designer and implementer.

Overall, this improved program \nameref{subsec:Reliability} and portability.

\subsubsection{User-Defined Abstract Data Types}\label{subsubsec:User_Defined_Abstract_Data_Types}
\begin{definition}[Abstract Data Type]\label{def:Abstract_Data_Type}
  An \emph{abstract data type} has 2 components:
  \begin{enumerate}[noitemsep]
  \item The enclosure that ``displays'' what operations are possible on this \nameref{def:Data_Type} is called the \nameref{def:ADT_Interface}.
  \item The code that implements the functionality specified by the interface is called the \nameref{def:ADT_Implementation}.
  \end{enumerate}

  An abstract data type is a \nameref{def:Data_Type} that satisfies the following conditions:
  \begin{itemize}[noitemsep]
  \item The representation of objects of the type is hidden from the program units that use that type, so they only direct operations possible on those objects are those provided in the abstract data type's definition. This improves:
    \begin{itemize}[noitemsep]
    \item Increases \nameref{subsec:Reliability}
    \item Clients (Units using an abstract data type) cannot manipulate the underlying representation of objects directly
    \item Objects can be changed only through the provided operations
    \item Reduces the range of code and the number of \nameref{def:Variable}s the programmer must be aware of when reading/writing a program
    \item Reduces the likelihood of naming conflicts
    \end{itemize}
  \item The declarations of the type and the protocols of the operations on objects of the abstract data type, which provide the type's interface, are contained in a single syntactic unit. This benefits the language by:
    \begin{itemize}[noitemsep]
    \item Organizing the program into logical units that can be compiled separately.
    \end{itemize}
  \item The type's interface does not depend on the underlying representation of the objects, or the implementation of the operations.
    \begin{itemize}[noitemsep]
    \item For example, if a stack is implemented with a linked list, then needs to be changed to an array-like structure, the underlying representation can be changed without affecting any clients that are using the subprograms and \nameref{def:Variable}s.
    \item Accessing and modifying data in an abstract data type is done with \emph{getters} and \emph{setters} that allow clients indirect access to the hidden data. There are 3 reasons why this is an improvement:
      \begin{enumerate}[noitemsep]
      \item Read-only access can be provided, by having a getter method, but no corresponding setter method.
      \item Constraints can be included in setters. The setter can enforce the range that a data value can take.
      \item The actual implementation of the data memvers can be changed without affecting the clients, if getters and setters are the only access.
      \end{enumerate}
    \end{itemize}
  \item Also, other program units are allowed to create \nameref{def:Variable}s of the defined abstract data type.
  \end{itemize}
\end{definition}

\begin{definition}[Interface]\label{def:ADT_Interface}
  An \emph{interface} is the programmer-usable ``contract'' that can be used for an \nameref{def:Abstract_Data_Type}.
  It ensures that all programmers who use this \nameref{def:Abstract_Data_Type} have a common set of operations that behave in a defined manner.

  An example of an interface is C and C++'s header files (\texttt{*.h} for C, and \texttt{*.hpp} for C++).

  \begin{remark}
    The \nameref{def:ADT_Interface}, usually, does not contain any code.
    The code that implements the \nameref{def:ADT_Interface} is in the \nameref{def:ADT_Implementation} file.
    However, in Java, an \nameref{def:Abstract_Data_Type} requires that the method have a \nameref{def:Subprogram_Definition} at the same time as its \nameref{def:Subprogram_Declaration}.
  \end{remark}

  \begin{remark}[Reliance on Specification]\label{rmk:ADT_Interface_Specification}
    An \nameref{def:Abstract_Data_Type}'s \nameref{def:ADT_Interface} must have a specification to ensure that the \nameref{def:Abstract_Data_Type} has the expected operations.
    This is further discussed in \Cref{subsubsec:Specification_Abstract_Datatype}.
  \end{remark}
\end{definition}


\subsection{Design Issues for Abstract Data Types}\label{subsec:Abstract_Data_Type_Design_Issues}
\begin{itemize}[noitemsep]
\item The \nameref{def:Abstract_Data_Type} name must be externally visible, to allow for object creation
\item The \nameref{def:Abstract_Data_Type} representation must be hidden.
\item There are few built-in operations by a language for \nameref{def:Abstract_Data_Type} operations
  \begin{itemize}[noitemsep]
  \item If there are some defined, they are the most basic ones: assignment, comparison.
  \item Overloading of subprograms should be allowed
  \end{itemize}
\item The form of the container for the interface to the \nameref{def:Abstract_Data_Type}.
\item Whether \nameref{def:Abstract_Data_Type} can be parameterized.
\item What access controls are provided, and how are such controls specified?
\item Is the specification of the \nameref{def:Abstract_Data_Type} physically separate from its implementation?
\end{itemize}

\end{definition}











\input{./EDAP05-Concepts_Programming_Languages-Sections/Abstract_Data_Types/Type_Variance}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
