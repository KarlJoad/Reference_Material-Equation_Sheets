\section{Object-Oriented Programming}\label{sec:Object_Oriented_Programming}
\subsection{Introduction}\label{subsec:OOP_Intro}
\begin{definition}[Object-Oriented Programming]\label{def:Object_Oriented_Programming}
  \emph{Object-oriented programming} (\emph{OOP}) is a programming paradigm designed around the manipulation of \nameref{def:Object}s that accurately simulate real-life situations.
  These languages must provide 3 key language features:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Abstract_Data_Type}
  \item \nameref{def:OOP_Inheritance}
  \item Dynamic binding of method calls to methods.
  \end{enumerate}

  The use of an object-oriented language allows for \nameref{def:Abstract_Data_Type}s to be reused.
  This allows for programmers to reuse large portions of code and only having to change the parts that are necessary.
  This increases productivity and increases \nameref{subsec:Reliability}.
\end{definition}

\subsection{Inheritance}\label{subsec:OOP_Inheritance}
The use of \nameref{def:OOP_Inheritance} allows for \nameref{def:Abstract_Data_Type}s to be reused between pieces of software.
This, in turn, means code is reused, but some of it must be specialized.
Additionally, some of the underlying problem has categories of objects that are related, both as siblings (similar to each other) and as parents and children (having a descendant relationship).

\begin{definition}[Class]\label{def:OOP_Class}
  A \emph{class} is the \nameref{def:Abstract_Data_Type} of \nameref{def:Object_Oriented_Programming} languages.
  They are the building blocks of the programming paradigm.

  Classes have 2 kinds of \nameref{def:Variable}s:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:OOP_Class_Variable}
  \item \nameref{def:OOP_Instance_Variable}
  \end{enumerate}

  They also have 2 kinds of \nameref{def:OOP_Method}s:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:OOP_Class_Method}
  \item \nameref{def:OOP_Instance_Method}
  \end{enumerate}
\end{definition}

\begin{definition}[Object]\label{def:OOP_Object}
  An \emph{object} in an \nameref{def:Object_Oriented_Programming} setting is an instance of a \nameref{def:OOP_Class}.
\end{definition}

\begin{definition}[Subclass]\label{def:OOP_Subclass}
  A \nameref{def:OOP_Class} that is derived from another \nameref{def:OOP_Class} is called a \emph{subclass} or \emph{derived class}.
\end{definition}

\begin{definition}[Superclass]\label{def:OOP_Superclass}
  A \nameref{def:OOP_Class} from which other \nameref{def:OOP_Class}es are derived is called a \emph{superclass}, or \emph{parent class}.
\end{definition}

A \nameref{def:OOP_Subclass} can differ from its \nameref{def:OOP_Superclass} in several ways.
\begin{enumerate}[noitemsep]
\item The \nameref{def:OOP_Superclass} can define some of its \nameref{def:Variable}s or \nameref{def:OOP_Method}s to have private access, which means they won't be visible to the \nameref{def:OOP_Subclass}.
\item The \nameref{def:OOP_Subclass} can add \nameref{def:Variable}s and/or \nameref{def:OOP_Method}s to those inherited from the \nameref{def:OOP_Superclass}.
\item The \nameref{def:OOP_Subclass} can modify the behavior of one or more of its inherited \nameref{def:OOP_Method}s. A modified \nameref{def:OOP_Method} has the same name, and often the same protocol, as the original.
\end{enumerate}

\begin{definition}[Method]\label{def:OOP_Method}
  A \emph{method} is a subprogram that defines the operations of/on \nameref{def:OOP_Object}s of a \nameref{def:OOP_Class}.
\end{definition}

\begin{definition}[Message]\label{def:OOP_Message}
  The calls to \nameref{def:OOP_Method}s are sometimes called \emph{message}s.
  Passing a message is different than calling a traditional subprogram.
  A message is sent to an \nameref{def:OOP_Object} that is a request to execute a \nameref{def:OOP_Method}.
  These \nameref{def:OOP_Method}s can operate on themselves, or on other \nameref{def:OOP_Object}s.
\end{definition}

\begin{definition}[Message Interface]\label{def:OOP_Message_Interface}
  Thus, the entire collection of \nameref{def:OOP_Method}s is called the \emph{message interface}, or \emph{message protocol} of the \nameref{def:OOP_Object}.
\end{definition}

\begin{definition}[Override]\label{def:OOP_Override}
  A new \nameref{def:OOP_Subclass}'s \nameref{def:OOP_Method} can \emph{override} a \nameref{def:OOP_Superclass}'s \nameref{def:OOP_Method}.
  This is then called an \emph{overriden method}.

  Overriding a \nameref{def:OOP_Method} is useful because it allows us to provide an operation in the \nameref{def:OOP_Subclass} that is similar to the one in the \nameref{def:OOP_Superclass}, but specialized for \nameref{def:OOP_Object}s of the \nameref{def:OOP_Subclass}.
\end{definition}

\begin{definition}[Instance Method]\label{def:OOP_Instance_Method}
  An \emph{instance \nameref{def:OOP_Method}} is a \nameref{def:OOP_Method} that \textbf{only} operates on instances of the \nameref{def:OOP_Class}.
\end{definition}

\begin{definition}[Instance Variable]\label{def:OOP_Instance_Variable}
  An \emph{instance \nameref{def:Variable}} is a unique set of \nameref{def:Variable}s defined by the initializing \nameref{def:OOP_Class}, and stores that \nameref{def:OOP_Object}'s state.
\end{definition}

\begin{definition}[\nameref*{def:OOP_Class} Variable]\label{def:OOP_Class_Variable}
  \emph{\nameref{def:OOP_Class} \nameref{def:Variable}}s belong to and operate on the \nameref{def:OOP_Class} itself, rather than just the \nameref{def:OOP_Object}s of a \nameref{def:OOP_Class}.
  This means there is only \textbf{one} copy for the whole \nameref{def:OOP_Class}, rather than a copy for every instance of this \nameref{def:OOP_Class}.

  For example, a counter of the number of instantiated \nameref{def:OOP_Object}s of that \nameref{def:OOP_Class} would require a class variable.
\end{definition}

\begin{definition}[\nameref*{def:OOP_Class} Method]\label{def:OOP_Class_Method}
  A \emph{\nameref{def:OOP_Class} \nameref{def:OOP_Method}} performs operations on the \nameref{def:OOP_Class} as a whole, rather than the individual \nameref{def:OOP_Object}s of that \nameref{def:OOP_Class}.
  This means there is only \textbf{one} copy for the whole \nameref{def:OOP_Class}, rather than a copy for every instance of this \nameref{def:OOP_Class}.
\end{definition}

\begin{definition}[Inheritance]\label{def:OOP_Inheritance}
  \emph{Inheritance} is the act of making a \nameref{def:OOP_Superclass} and deriving (inheriting) a \nameref{def:OOP_Subclass} from it.
  This creates a new \nameref{def:OOP_Class} as the original, but is slightly different.

  \begin{remark}
    The ability to reuse code through \nameref{def:OOP_Inheritance} means that dependencies between these \nameref{def:Abstract_Data_Type}s can form.
    This technically defeats the purpose of \nameref{def:Abstract_Data_Type}s' independence of each other.
    However, increasing the reusability without introducing dependencies may not be possible.
    In addition, these dependencies may make solving the issue in the problem domain easier.
  \end{remark}
\end{definition}

\begin{definition}[Single Inheritance]\label{def:OOP_Single_Inheritance}
  In \emph{single \nameref{def:OOP_Inheritance}}, a \nameref{def:OOP_Class} can \textbf{only} have 1 parent \nameref{def:OOP_Superclass}.
  However, any \nameref{def:OOP_Superclass} can have an infinite number of derived, child, \nameref{def:OOP_Subclass}es.

  When a relationship between \nameref{def:OOP_Class}es that use single \nameref{def:OOP_Inheritance} is visualized, a derivation tree is made.
\end{definition}

\begin{definition}[Multiple Inheritance]\label{def:OOP_Multiple_Inheritance}
  In \emph{multiple \nameref{def:OOP_Inheritance}}, a \nameref{def:OOP_Class} can have multiple parent \nameref{def:OOP_Superclass}es.
  Any \nameref{def:OOP_Superclass} can also have an infinite number of derived, child, \nameref{def:OOP_Subclass}es.

  When a relationship between \nameref{def:OOP_Class}es that uses multiple \nameref{def:OOP_Inheritance} it can be visualized as a derivation graph.
\end{definition}

\subsection{Dynamic Binding}\label{subsec:OOP_Dynamic_Binding}
\begin{definition}[Dynamic Dispatch]\label{def:OOP_Dynamic_Dispatch}
  \emph{Dynamic dispatch} is a way to dynamically bind \nameref{def:OOP_Message}s to \nameref{def:OOP_Method} definitions.
\end{definition}

\begin{definition}[Polymorphic]\label{def:OOP_Polymorphic}
  The reference to a \nameref{def:OOP_Subclass} is \emph{polymorphic} if it could also point to something in the \nameref{def:OOP_Superclass}.
  Thus, during runtime, the correct reference must be resolved through polymorphism and executed through \nameref{def:OOP_Dynamic_Dispatch}.
  For example, in Java
\begin{minted}[frame=lines,linenos]{java}
public class A {
  public draw() { ... }
}
public class B extends A {
  @Override
  public draw() { ... }
}
public static void main(String[] args) {
  A myA = new A();
  B myB = new B();
  myA.draw(); // Draws the thing defined by instructions in class A's draw() method
  myB.draw(); // Draws the thing defined by instructions in class B's draw() method
  // We need to determine if we should call B's draw() or A's draw in this case
\end{minted}
\end{definition}

In some cases, a \nameref{def:OOP_Class} sit so high in the hierarchy that it is never instantiated to an \nameref{def:OOP_Object}.
In that case, its functionality can be stripped out, and the \nameref{def:OOP_Class} can turn into an \nameref{def:OOP_Abstract_Class}, with \nameref{def:OOP_Abstract_Method}s.

\begin{definition}[Abstract \nameref*{def:OOP_Method}]\label{def:OOP_Abstract_Method}
  An \emph{abstract \nameref{def:OOP_Method}} (pure virtual \nameref{def:OOP_Method} in C++) is a \nameref{def:OOP_Method} that is missing its body.
  However, because the \nameref{def:OOP_Method} definition is still present, all \nameref{def:OOP_Subclass}es \textbf{are required} to implement the body/functionality of the abstract \nameref{def:OOP_Method}, turning it into a concrete \nameref{def:OOP_Method}.
\end{definition}

\begin{definition}[Abstract \nameref*{def:OOP_Class}]\label{def:OOP_Abstract_Class}
  An \emph{abstract \nameref{def:OOP_Class}} (abstract base \nameref{def:OOP_Class} in C++) is a \nameref{def:OOP_Class} that contains one or more \nameref{def:OOP_Abstract_Method}s.
  \textbf{These usually cannot be instantiated}.
  
  Any \nameref{def:OOP_Subclass} of an abstract class must provide implementations of all the inherited \nameref{def:OOP_Abstract_Method}s.
\end{definition}

\subsection{Design Issues for Object-Oriented Languages}\label{subsec:OOP_Design_Issues}
\subsubsection{Exclusivity of Objects}\label{subsubsec:OOP_Object_Exclusivity}
There are 3 main schools of thought/implementation when it comes to the implementation of \nameref{def:OOP_Object}s in an \nameref{def:Object_Oriented_Programming} language.
\begin{enumerate}[noitemsep]
\item \textbf{EVERYTHING} is an \nameref{def:OOP_Object}. Basic scalar types, collections, programs, everything is an \nameref{def:OOP_Object}. In the purest version of this model, all \nameref{def:OOP_Class}es are treated the same way.
  \begin{itemize}[noitemsep]
  \item The benefits of this are the uniformity and elegance of the language. It is incredibly regular, where everything looks the same and behaves similarly, without exception.
  \item The disadvantages of this is mainly the cost of executing everything as an \nameref{def:OOP_Object}. There are \nameref{def:OOP_Message}s and the method calls which are slower than simpler, primitive, operations.
  \end{itemize}
\item Keep the original, traditional collection of types, but add the object typing model on top.
  \begin{itemize}[noitemsep]
  \item The benefits of this is that the language retains its speed of execution on the primitive types.
  \item The drawbacks of this is the confusing syntax and semantics that can be output by this.
  \end{itemize}
\item Use an imperative type structure for the \nameref{def:Primitive_Data_Type}s, but all structured types as objects.
  \begin{itemize}[noitemsep]
  \item The benefit of this is the execution speed of operations is relatively similar
  \item The downsides are the complications that can appear in the language, and the need for \emph{wrapper \nameref{def:OOP_Class}es} that allow these non\nameref{def:OOP_Object} types and \nameref{def:OOP_Object}s to interact.
  \end{itemize}
\end{enumerate}

\subsubsection{Are Subclasses Subtypes?}\label{subsubsec:OOP_Subclasses_Subtypes}
\subsubsection{Single and Multiple Inheritance}\label{subsubsec:OOP_Single_Multiple_Inheritance}
\subsubsection{Allocation and Deallocation of Objects}\label{subsubsec:OOP_Object_Allocation_Deallocation}
\subsubsection{Dynamic and Static Binding}\label{subsubsec:OOP_Dynamic_Static_Binding}
\subsubsection{Nested Classes}\label{subsubsec:OOP_Nested_Classes}
\subsubsection{Initialization of Objects}\label{subsubsec:OOP_Object_Initialization}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
