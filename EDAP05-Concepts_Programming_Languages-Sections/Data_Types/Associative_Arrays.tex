\subsection{Associative Arrays}\label{subsec:Associative_Arrays}
\begin{definition}[Associative Array]\label{def:Associative_Array}
  An \emph{associative array} is an unordered collection of data elements that are indexed by an equal number of values, called \emph{keys}.
  The user-defined keys must be stored in the structure, along with the values to be stored.

  To store the keys, they must be \emph{hashed}.
  This is done with a hash function.

  \begin{remark}[Alternative Names]
    There are many alternative names for \nameref{def:Associative_Array}s.
    \begin{itemize}[noitemsep]
    \item Hashtable
    \item Hashmap
    \item \nameref{def:Associative_Array}
    \item Dictionary
    \end{itemize}
  \end{remark}

  \begin{remark}[Improving Capabilities]
    What the associative array/dictionary/hashtable are allowed to store depends on the language.
    In Python and Ruby, objects and \nameref{def:Primitive_Data_Type}s can be stored.
    In PHP, integers or strings can be keys.
    In Ruby, any object can be a key.
  \end{remark}
\end{definition}

\subsubsection{Structure and Operations}\label{subsubsec:Structure_and_Ops_Associative_Arrays}
The code examples here are done in Perl, but it is similar in most other languages.
For more specific code, you will have to visit the language's documentation.
\inputminted[frame=lines,linenos]{perl}{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Code/Associative_Array_Structure_Operations.pl}

The size of a Perl \nameref{def:Associative_Array} is dynamic and will grow and shrink as needed.

\nameref{def:Associative_Array}s are very useful if there is a lot of searching that needs to be done, because the hashing of the key, then the search term allows for $O(1)$ lookup speeds for an element located anywhere in the \nameref{def:Associative_Array}.

\subsubsection{Implementing \nameref*{subsec:Associative_Arrays}}\label{subsubsec:Implementing_Associative_Arrays}
The implementation for an \nameref{def:Associative_Array} differs between languages.
However, in all languages, eventually the \nameref{def:Associative_Array} can get ``full''.
This is when the collision chance of 2 hashes modulo the length of the structure gets too high.
This means that if an element is already stored, and something new were hashed and modulo-d the length of the structure, there is a very high probability that the new element would ``collide'' with the old one.

To handle this, \nameref{def:Associative_Array}s are grown.
Every key-value pair will need to have their key recalculated.
This is a slightly time-costly operation, $O(n)$, but the spatial-cost is much higher, because there are 2 potentially very large arrays in memory at the same time.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
