\section{Expressions}\label{sec:Expressions}
\begin{definition}[Expression]\label{def:Expression}
  An \emph{expression} is a combination of one or more \nameref{def:Operand}s and operators that the programming language interprets (according to its particular rules of precedence and of association) and computes to produce another value.
\end{definition}

\begin{definition}[Operand]\label{def:Operand}
  An \emph{operand} is a:
  \begin{itemize}[noitemsep]
  \item Constant
  \item Variable
  \item Another \nameref{def:Expression}
  \item Result from function calls
  \end{itemize}
\end{definition}

\subsection{Arithmetic Expressions}\label{subsec:Arithmetic_Expressions}
One of the main goals of high-level languages was to have automatic evaluation of \nameref{def:Expression}s similar to those in math, science, and engineering.
Most of these characteristics came from mathematics directly.

\subsubsection{Arity}\label{subsubsec:Operator_Arity} % Not in textbook, from video
\begin{definition}[Arity]\label{def:Arity}
  \emph{Arity} is the number of \nameref{def:Operand}s that must be present to evaluate that \nameref{def:Expression}.
  In most programming languages, there are 3:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Arity-Unary}
  \item \nameref{def:Arity-Binary}
  \item \nameref{def:Arity-Ternary}
  \end{enumerate}
\end{definition}

\begin{definition}[Unary]\label{def:Arity-Unary}
  A \emph{unary} operation requires a single \nameref{def:Operand}.
  For example, negation, \texttt{-x}
\end{definition}

\begin{definition}[Binary]\label{def:Arity-Binary}
  A \emph{binary} operation requires 2 \nameref{def:Operand}s.
  For example, addition, \texttt{y + z}

  \begin{remark}
    These are usually use \nameref{def:Fixity-Infix} notation.
  \end{remark}
\end{definition}

\begin{definition}[Ternary]\label{def:Arity-Ternary}
  A \emph{ternary} operation requires 3 \nameref{def:Operand}s.
  For example, \verb|w = if x ? y : z|.

  \begin{remark}
    As far as I know, the only ternary operator is a single-line if statement.
  \end{remark}
\end{definition}

\subsubsection{Fixity}\label{subsubsec:Operator_Fixity} % Not in textbook, from video
\begin{definition}[Fixity]\label{def:Fixity}
  \emph{Fixity} is the position of an operation relative to an \nameref{def:Operand}.
  There are 3 possible positions:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Fixity-Prefix}
  \item \nameref{def:Fixity-Infix}
  \item \nameref{def:Fixity-Suffix}
  \end{enumerate}
\end{definition}

\begin{definition}[Prefix]\label{def:Fixity-Prefix}
  \emph{Prefix} notation has the operators before the \nameref{def:Operand}s that it operates on.
  For example:
  \begin{itemize}[noitemsep]
  \item \texttt{-x}
  \item \texttt{+ x y}
  \end{itemize}
\end{definition}

\begin{definition}[Infix]\label{def:Fixity-Infix}
  \emph{Infix} notation has the operators between the \nameref{def:Operand}s that it operates on.
  This necessitates that the expression uses at least 2 \nameref{def:Operand}s, making this a potential \nameref{def:Arity-Binary} operator.
  For example:
  \begin{itemize}[noitemsep]
  \item \texttt{x+y}
  \end{itemize}
\end{definition}

\begin{definition}[Suffix]\label{def:Fixity-Suffix}
  \emph{Postfix} or \emph{suffix} notation has the operator after the \nameref{def:Operand}s that it operates on.
  For example:
  \begin{itemize}[noitemsep]
  \item \texttt{x!}
  \item \texttt{x y +}
  \end{itemize}
\end{definition}

\subsubsection{Operator Evaluation Order}\label{subsubsec:Operator_Evaluation_Order}
\paragraph{Precedence}\label{par:Operator_Evaluation_Order-Precedence}
\begin{definition}[Operator Precedence Rules]\label{def:Operator_Precedence_Rules}
  \emph{Operator precedence rules} partially define the order in which operators of different precedence levels are evaluated.
  This is based on the hierarchy or operator priorities, as defined by the language designer.

  \begin{remark}
    \nameref{def:Operator_Associativity_Rules} also define the order in which operators are evaluated in an \nameref{def:Expression}.
  \end{remark}
\end{definition}

There may be unary addition, called the \emph{identity operator}, because it usually no associated operation.
Unary ``subtraction'' changes the sign of the operand, negating it.

\begin{table}[h!]
  \centering
  \begin{tabular}{c|cc}
    \toprule
    & Ruby & C-Based Languages \\
    \midrule
    Highest & \texttt{**} & postfix \texttt{++}, \texttt{--} \\
    & Unary \texttt{+}, \texttt{-} & Prefix \texttt{++}, \texttt{--}, Unary \texttt{+}, \texttt{-} \\
    & \texttt{*}, \texttt{/}, \texttt{\%} & \texttt{*}, \texttt{/}, \texttt{\%} \\
    Lowest & Binary \texttt{+}, \texttt{-} & Binary \texttt{+}, \texttt{-} \\
    \bottomrule
  \end{tabular}
  \caption{Precedence of Arithmetic Operators}
  \label{tab:Operator_Evaluation_Order-Precedence}
\end{table}

\paragraph{Associativity}\label{par:Operator_Evaluation_Order-Associativity}
\begin{definition}[Operator Associativity Rules]\label{def:Operator_Associativity_Rules}
  \emph{Operator associativity rules} partially define the order in which operators of \textbf{the same} precedence levels are evaluated.
  There can be:
  \begin{itemize}[noitemsep]
  \item Left associativity: When evaluating an expression, parentheses that determine the order of evaluation are accumulated to the left, meaning the left-hand side is evaluated first.
  \item Right associativity: When evaluating an expression, parentheses that determine the order of evaluation are accumulated to the right, meaning the right-hand side is evaluated first.
  \item Nonassociativity: When evaluating an expression, parentheses that determine the order of evaluation are unknown and must be \textbf{explicitly} specified.
  \end{itemize}

  \begin{remark}
    There are very few operators that are right-associative.
    As far as I know, only the exponentiation operator that can be right associative.
  \end{remark}
\end{definition}

\begin{table}[h!]
  \centering
  \begin{tabular}{cc}
    \toprule
    Language & Associativity Rule \\
    Ruby & Left: \texttt{*}, \texttt{/}, \texttt{+}, \texttt{-} \\
             & Right: \texttt{**} \\
    C-Based languages & Left: \texttt{*}, \texttt{/}, \texttt{\%}, Binary \texttt{+}, Binary \texttt{-} \\
             & Right: \texttt{++}, \texttt{--}, Unary \texttt{+}, Unary \texttt{-} \\
    Ada & Left: All except \texttt{**} \\
             & Right: None \\
             & Nonassociative: \texttt{**} \\
    \bottomrule
  \end{tabular}
  \caption{Associativity of Arithmetic Operators}
  \label{tab:Operator_Evaluation_order-Associativity}
\end{table}

\begin{remark*}
  \textbf{This section only applies to integer arithmetic operators.}
  Floating-point arithmetic is different because of the way numbers are represented and their finite precision.
\end{remark*}

\paragraph{Parentheses}\label{par:Operator_Evaluation_Order-Parentheses}
Parentheses can alter the \nameref{def:Operator_Precedence_Rules} and \nameref{def:Operator_Associativity_Rules}.
A parenthesized part of an expression has precedence over its adjacent unparenthesized parts.

For example, the addition will be done first here
\begin{equation*}
  (A + B) * C
\end{equation*}

\paragraph{Ruby Expressions}\label{par:Operator_Evaluation_Order-Ruby_Expressions}
Everything (literally everything, including literals) is an object in Ruby.
Ruby supports the arithmetic and logic operations that are included in C-based languages, but they are slightly different.
For example, the expression \texttt{a + b} is a call to the \texttt{+} method of the \texttt{a} object, and passes a reference to the \texttt{b} object as a parameter to the \texttt{+} method.
This means that the operator can be overloaded by the programmer, which is useful for user-defined \nameref{def:Data_Type}s.

\paragraph{LISP Expressions}\label{par:Operator_Evaluation_Order-LISP_Expressions}
LISP is similar to Ruby in that arithmetic and logic operations are computed by subprograms.
However, in LISP and its descendants, the subprograms (operators) \textbf{must} be called explicitly.
For example, to write $A + B * C$ in LISP\footnote{When a LISP list is interpreted as code, the first element is the function name, and the rest are passed parameters.}.
\begin{minted}[frame=lines,linenos]{lisp}
(+ A (* B C)) ; Computes A + B * C
\end{minted}

\paragraph{Conditional Expressions}\label{par:Operator_Evaluation_Order-Conditional_Expressions}
Conditional expressions can be used as an expression with the \nameref{def:Arity-Ternary} variant.
For example,
\begin{minted}[frame=lines,linenos]{c}
if (count == 0) {
  average = 0;
} else {
  average = sum / count;
}
\end{minted}
is equivalent to
\begin{minted}[frame=lines,linenos]{c}
average = (count == 0) ? 0 : sum / count;
\end{minted}

\subsubsection{Operand Evaluation Order}\label{subsubsec:Operand_Evaluation_Order}
How do we determine and what steps must be taken to get the value of the \nameref{def:Operand} used in the current \nameref{def:Expression}?

\paragraph{Side Effects}\label{par:Operand_Evaluation-Side_Effects}
\begin{definition}[Side Effect]\label{def:Function_Side_Effect}
  A \emph{side effect} of a function is when the function changes either one of its parameters or a \nameref{def:Global_Variable}.
\end{definition}

\begin{definition}[Pure]\label{def:Function_Pure}
  A function can be called \emph{pure} when the function \textbf{does not} change its parameters or a \nameref{def:Global_Variable}.

  \begin{remark}
    These are used in both mathematics and \nameref{def:Functional_Programming_Language}s.
  \end{remark}
\end{definition}
If a function has \nameref{def:Function_Side_Effect}s, then the order in which the \nameref{def:Operand}s are evaluated may affect the operation.

There are 2 possible solutions to this:
\begin{enumerate}[noitemsep]
\item Language designer can disallow functional \nameref{def:Function_Side_Effect}s, essentially making all functions used in an \nameref{def:Expression} \nameref{def:Function_Pure}.
  \begin{itemize}[noitemsep]
  \item However, implementing this is difficult in \nameref{def:Imperative_Programming_Language}s
  \item Eliminates some flexibility for the programmer
  \item Access to \nameref{def:Global_Variable}s would have to be disallowed, which the compiler may want to do to improve speed.
  \end{itemize}
\item Language definition could state that \nameref{def:Operand}s in \nameref{def:Expression}s are to be evaluated in a particular order and demand implementors guarantee that order.
  \begin{itemize}[noitemsep]
  \item Some code optimization techniques that reorder the \nameref{def:Operand} evaluations could no longer be used.
  \end{itemize}
\end{enumerate}

\paragraph{Referential Transparency and Side Effects}\label{par:Operand_Evaluation-Referential_Transparency_Side_Effects}
\begin{definition}[Referential Transparency]\label{def:Referential_Transparency}
  A program has \emph{referential transparency} if any 2 \nameref{def:Expression}s in the program that have the same value can be substituted for another, without affecting the action of the program.

  \begin{remark}
    A function/program that has \nameref{def:Referential_Transparency} should also be a \nameref{def:Function_Pure} program/function.
  \end{remark}

  \begin{remark}
    In a \nameref{def:Functional_Programming_Language} \textbf{\emph{ALL}} functions/programs have \nameref{def:Referential_Transparency}, by definition.
  \end{remark}
\end{definition}

There are several advantages:
\begin{itemize}[noitemsep]
\item Semantics of referentially transparent programs are easier to understand.
\item A programmed function is equivalent to a mathematical function in that it is \nameref{def:Function_Pure}.
\end{itemize}

\subsection{Relational and Boolean Expressions}\label{subsec:Relational_Boolean_Expressions}
\subsubsection{Relational Expressions}\label{subsubsec:Relational_Expressions}
\subsubsection{Boolean Expressions}\label{subsubsec:Boolean_Expressions}

\subsection{Short-Circuit Evaluation}\label{subsec:Short_Circuit_Evaluation}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
