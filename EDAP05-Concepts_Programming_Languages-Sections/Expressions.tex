\section{Expressions}\label{sec:Expressions}
\begin{definition}[Expression]\label{def:Expression}
  An \emph{expression} is a combination of one or more \nameref{def:Operand}s and operators that the programming language interprets (according to its particular rules of precedence and of association) and computes to produce another value.
\end{definition}

\begin{definition}[Operand]\label{def:Operand}
  An \emph{operand} is a:
  \begin{itemize}[noitemsep]
  \item Constant
  \item Variable
  \item Another \nameref{def:Expression}
  \item Result from function calls
  \end{itemize}
\end{definition}

\subsection{Arithmetic Expressions}\label{subsec:Arithmetic_Expressions}
One of the main goals of high-level languages was to have automatic evaluation of \nameref{def:Expression}s similar to those in math, science, and engineering.
Most of these characteristics came from mathematics directly.

\subsubsection{Arity}\label{subsubsec:Operator_Arity} % Not in textbook, from video
\begin{definition}[Arity]\label{def:Arity}
  \emph{Arity} is the number of \nameref{def:Operand}s that must be present to evaluate that \nameref{def:Expression}.
  In most programming languages, there are 3:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Arity-Unary}
  \item \nameref{def:Arity-Binary}
  \item \nameref{def:Arity-Ternary}
  \end{enumerate}
\end{definition}

\begin{definition}[Unary]\label{def:Arity-Unary}
  A \emph{unary} operation requires a single \nameref{def:Operand}.
  For example, negation, \texttt{-x}
\end{definition}

\begin{definition}[Binary]\label{def:Arity-Binary}
  A \emph{binary} operation requires 2 \nameref{def:Operand}s.
  For example, addition, \texttt{y + z}

  \begin{remark}
    These are usually use \nameref{def:Fixity-Infix} notation.
  \end{remark}
\end{definition}

\begin{definition}[Ternary]\label{def:Arity-Ternary}
  A \emph{ternary} operation requires 3 \nameref{def:Operand}s.
  For example, \verb|w = if x ? y : z|.

  \begin{remark}
    As far as I know, the only ternary operator is a single-line if statement.
  \end{remark}
\end{definition}

\subsubsection{Fixity}\label{subsubsec:Operator_Fixity} % Not in textbook, from video
\begin{definition}[Fixity]\label{def:Fixity}
  \emph{Fixity} is the position of an operation relative to an \nameref{def:Operand}.
  There are 3 possible positions:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Fixity-Prefix}
  \item \nameref{def:Fixity-Infix}
  \item \nameref{def:Fixity-Suffix}
  \end{enumerate}
\end{definition}

\begin{definition}[Prefix]\label{def:Fixity-Prefix}
  \emph{Prefix} notation has the operators before the \nameref{def:Operand}s that it operates on.
  For example:
  \begin{itemize}[noitemsep]
  \item \texttt{-x}
  \item \texttt{+ x y}
  \end{itemize}
\end{definition}

\begin{definition}[Infix]\label{def:Fixity-Infix}
  \emph{Infix} notation has the operators between the \nameref{def:Operand}s that it operates on.
  This necessitates that the expression uses at least 2 \nameref{def:Operand}s, making this a potential \nameref{def:Arity-Binary} operator.
  For example:
  \begin{itemize}[noitemsep]
  \item \texttt{x+y}
  \end{itemize}
\end{definition}

\begin{definition}[Suffix]\label{def:Fixity-Suffix}
  \emph{Postfix} or \emph{suffix} notation has the operator after the \nameref{def:Operand}s that it operates on.
  For example:
  \begin{itemize}[noitemsep]
  \item \texttt{x!}
  \item \texttt{x y +}
  \end{itemize}
\end{definition}

\subsubsection{Operator Evaluation Order}\label{subsubsec:Operator_Evaluation_Order}
\paragraph{Precedence}\label{par:Operator_Evaluation_Order-Precedence}
\paragraph{Associativity}\label{par:Operator_Evaluation_Order-Associativity}
\paragraph{Parentheses}\label{par:Operator_Evaluation_Order-Parentheses}
\paragraph{Ruby Expressions}\label{par:Operator_Evaluation_Order-Ruby_Expressions}
\paragraph{LISP Expressions}\label{par:Operator_Evaluation_Order-LISP_Expressions}
\paragraph{Conditional Expressions}\label{par:Operator_Evaluation_Order-Conditional_Expressions}

\subsubsection{Operand Evaluation Order}\label{subsubsec:Operand_Evaluation_Order}
\paragraph{Side Effects}\label{par:Operand_Evaluation-Side_Effects}
\paragraph{Referential Transparency and Side Effects}\label{par:Operand_Evaluation-Referential_Transparency_Side_Effects}

\subsection{Relational and Boolean Expressions}\label{subsec:Relational_Boolean_Expressions}
\subsubsection{Relational Expressions}\label{subsubsec:Relational_Expressions}
\subsubsection{Boolean Expressions}\label{subsubsec:Boolean_Expressions}

\subsection{Short-Circuit Evaluation}\label{subsec:Short_Circuit_Evaluation}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
