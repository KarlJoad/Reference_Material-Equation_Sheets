\section{Data Types}\label{sec:Data_Types}
\begin{definition}[Data Type]\label{def:Data_Type}
  A \emph{data type} defines a collection of data values and a set of predefined operations on those values.
  The data types present in a language used for a particular problem should closely mirror the objects in the real-world the program is solving.
\end{definition}

User-defined data types allow for:
\begin{itemize}[noitemsep]
\item Improved readability with better named \nameref{def:Data_Type}s.
\item Improved modifiability with programmers having to change just one common data type somewhere for a large change throughout a program.
\end{itemize}

If we take user-defined \nameref{def:Data_Type}s further, we end up with \emph{abstract data types}.
These force an interface for a particular data type, which is then visible to the user, and the data and background operations are hidden away.

Because of the wide variety of \nameref{def:Data_Type}s present today, it is more useful to think about \nameref{def:Variable}s in terms of \nameref{def:Descriptor}

\begin{definition}[Descriptor]\label{def:Descriptor}
  A \emph{descriptor} is the collection of attributes of a \nameref{def:Variable}.
  In an implementation, a descriptor is an area of \nameref{def:Memory} that stores the attributes of a \nameref{def:Variable}.
  
  There are a 2 cases for these:
  \begin{enumerate}[noitemsep]
  \item If all attributes are static, then they are known at compile-time, and the \nameref{def:Compiler} can use the symbol table to construct everything.
  \item If all attributes are dynamic, then the symbol table and all attributes must be stored in \nameref{def:Memory} during program execution.
  \end{enumerate}

  Descriptors are used for \nameref{def:Type_Checking} and building the code for \nameref{def:Variable_Memory_Allocation} and \nameref{def:Variable_Memory_Deallocation} operations.
\end{definition}

\subsection{Primitive Data Types}\label{subsec:Primitive_Data_Types}
\begin{definition}[Primitive Data Type]\label{def:Primitive_Data_Type}
  \emph{Primitive data type}s are \nameref{def:Data_Type}s that are \textbf{not} defined in terms of other data types.
  Nearly all programming languages provide these.
  Some are reflections of hardware, like integers, and others require only little software support for their impmlementation, floating-point numbers for instance.
\end{definition}

\subsubsection{Numeric Types}\label{subsubsec:Numeric_Primitive_Data_Types}
This section will discuss the 4 main types of numeric \nameref{def:Data_Type}s present in most programming languages.

\begin{definition}[Numeric Data Type]\label{def:Numeric_Data_Type}
  \emph{Numeric data type}s are \nameref{def:Data_Type}s that handle numbers.
\end{definition}

\paragraph{Integer}\label{par:Integer_Numeric_Primitive_Data_Type}
Integers are the most common \nameref{def:Numeric_Data_Type}.
Many languages support several sizes.
Java supports 4: \texttt{byte}, \texttt{short}, \texttt{int}, and \texttt{long}.
There can be unsigned integers as well.

If there are signed integers, the negative integers are stored in \nameref{def:Memory} in \nameref{def:Integer_Twos_Complement}.
\begin{definition}[Twos Complement]\label{def:Integer_Twos_Complement}
  \emph{Twos complement} is a way to store negative integers.
  To find the twos complement:
  \begin{enumerate}[noitemsep]
  \item The magnitude of the integer is found in binary
  \item The logical complement of that is computed
  \item One (1) is added to the logical complement
  \end{enumerate}
  
  \begin{remark}
    Using \nameref{def:Integer_Twos_Complement} is similar to adding by a negative number to an integer instead of performing subtraction.
  \end{remark}
\end{definition}

\paragraph{Floating-Point}\label{par:Floating_Point_Numeric_Primitive_Data_Type}
\begin{definition}[Floating-Point]\label{def:Floating_Point}
  \emph{Floating-point} \nameref{def:Data_Type}s model real (fractional/rational) numbers.
  However, these representations are only approximations for many real values.
  For example, $\pi$ cannot be represented in floating-point notation.

  Most programming languages implement 2 types of floating-point \nameref{def:Data_Type}s.
  \begin{enumerate}[noitemsep]
  \item \texttt{float}: The standard size, 32 bits (4 bytes). Represent the real number as a decimal and exponent, like scientific notation.
    \begin{itemize}[noitemsep]
    \item The first bit is a \emph{sign bit} (1 for negative)
    \item The next 8 bits are for the \emph{exponent}, normalized so that a real number raised to $-127$, i.e. $x^{-127}$, has an exponent bit value of 0.
      \begin{itemize}[noitemsep]
      \item This does mean that $x^{128}$ would have a bit-valued exponent of $255$.
      \end{itemize}
    \item The last 23 bits are for the fraction, called the \emph{mantissa}. This is the fractional portion of the scientific notation, represented in binary, with the first 1 of the bit sequence left off.
    \end{itemize}
  \item \texttt{double}: Used in cases where larger/smaller fractions or larger/smaller exponents are needed, 64 bits (8 bytes).
    \begin{itemize}[noitemsep]
    \item The first bit is a \emph{sign bit} (1 for negative)
    \item The next 11 bits are for the \emph{exponent}, normalized so that a real number raised to $-1023$, i.e. $x^{-1023}$, has an exponent bit value of 0.
      \begin{itemize}[noitemsep]
      \item This does mean that $x^{1024}$ would have a bit-valued exponent of $2048$.
      \end{itemize}
    \item The last 52 bits are for the fraction, called the \emph{mantissa}. This is the fractional portion of the scientific notation, represented in binary, with the first 1 of the bit sequence left off.
    \end{itemize}
  \end{enumerate}
\end{definition}

\nameref{def:Floating_Point} numbers are are specified in IEEE Floating-Point Standard 754.

\begin{definition}[Floating-Point Precision]\label{def:Floating_Point_Precision}
  \emph{Precision} is the accuracy of the fraction part of the \nameref{def:Floating_Point} number, and how well it represents the real number's value.
\end{definition}

\begin{definition}[Floating-Point Range]\label{def:Floating_Point_Range}
  \emph{Range} is a combination of the range of fractions and the range of the exponents.
\end{definition}

\paragraph{Complex}\label{par:Complex_Numeric_Primitive_Data_Type}
Some programming languages support complex numbers natively, and they also support complex-number mathematical operations natively.
The imaginary portion of the number is typically denoted with \texttt{j} or \texttt{J}.

\paragraph{Decimal}\label{par:Decimal_Numeric_Primitive_Data_Type}
In a computer, decimal numbers are stored in \nameref{def:Binary_Coded_Decimal}.
There is also special hardware to support hardware-level mathematical operations on these types of numbers.
If this hardware is not present, the calculations can be simulated in software.

\begin{definition}[Binary Coded Decimal]\label{def:Binary_Coded_Decimal}
  \emph{Binary Coded Decimal}, or \emph{BCD}, is a way to represent decimal numbers with perfect accuracy, albeit at the expense of some space.
  There is a one-to-one mapping of the binary representations of these numbers to decimal, and anything greater than 9 is discarded.
  \begin{table}[h!]
    \centering
    \begin{tabular}{cc}
      \toprule
      Decimal & \nameref{def:Binary_Coded_Decimal} \\
      \midrule
      0 & 0000 \\
      1 & 0001 \\
      2 & 0010 \\
      3 & 0011 \\
      4 & 0100 \\
      5 & 0101 \\
      6 & 0110 \\
      7 & 0111 \\
      8 & 1000 \\
      9 & 1001 \\
      \midrule
      X & 1010 \\
      X & 1011 \\
      X & 1100 \\
      X & 1101 \\
      X & 1110 \\
      X & 1111 \\
      \bottomrule
    \end{tabular}
    \caption{Binary Coded Decimal}
    \label{tab:Binary_Coded_Decimal}
  \end{table}

  \begin{remark}
    These numbers are usually stored 2 per byte, because each only takes 4 bits.
  \end{remark}
\end{definition}

\subsubsection{Boolean Types}\label{subsubsec:Boolean_Primitive_Data_Types}
\begin{definition}[Boolean Data Type]\label{def:Boolean_Data_Type}
  \emph{Boolean data type}s only store 2 values: \texttt{true} and \texttt{false}.
  Some older language implementations did not support these, but most do today.
  If a language does not support a boolean data type, then 0 is considered false, and 1 is considered true.

  \begin{remark}[Storage in Memory]\label{rmk:Boolean_Storage_in_Memory}
    Although a single bit can represent a \nameref{def:Boolean_Data_Type}, single bits of \nameref{def:Memory} cannot be efficiently access on many machines.
    Thus, \nameref{def:Boolean_Data_Type}s are usually stored in a single byte.
  \end{remark}
\end{definition}

\subsubsection{Character Types}\label{subsubsec:Character_Primitive_Data_Types}
Characters are stored in \nameref{def:Memory} as numeric encodings.
These are usually single characters, \textbf{not multiple characters together (strings)}.

Characters were originally handled by ASCII, but now there are several encodings, with Unicode being more commonly used now.
Unicode supports all human languages, glyphs, and other characters, like emojis.
The first 128 characters of Unicode match up with ASCII for intercompatibility.

ASCII required 8 bits, Unicode (UTF-16) uses 16.

\subsection{Character String Types}\label{subsec:Character_String_Types}
\begin{definition}[Character String Type]\label{def:Character_String_Type}
  A \emph{character string type} is one in which the values consist of sequences of characters.
\end{definition}

\subsubsection{Design Issues}\label{subsubsec:Character_String_Types_Design_Issues}
There are 2 questions that need to be answered when designing a language implementation when it comes to strings.
\begin{itemize}[noitemsep]
\item Should strings be a special kind of character array or a primitive type?
\item Should strings have static or dynamic lengths?
\end{itemize}

\subsubsection{Strings and Their Operations}\label{subsubsec:String_Types_and_Ops}
The most common string operations are:
\begin{itemize}[noitemsep]
\item Assignment
  \begin{itemize}[noitemsep]
  \item What happens when a string is longer than expected? C/C++'s \texttt{strcpy} function
  \end{itemize}
\item Concatenation
\item Substring Reference
  \begin{itemize}[noitemsep]
  \item Discussed more in the context of arrays, where substring references are called slices.
  \end{itemize}
\item Comparison
  \begin{itemize}[noitemsep]
  \item How do we compare 2 strings, where one is longer than the other?
  \end{itemize}
\item Pattern Matching
\end{itemize}

In C and C++, strings are terminated with the null character, \texttt{00}.
This way we do not need to track the length of a string.

Object-Oriented Languages (Java, Ruby, C\#) use classes to represent strings.
The only field in these objects is a constant string.

Python supports strings as a primitive type, and supports array-like operations on them.

Some languages have \nameref{def:Regular_Expression}s built in, like Perl, JavaScript, Ruby, and PHP.\@
Others have libraries that handle \nameref{def:Regular_Expression}s.

\begin{definition}[Regular Expression]\label{def:Regular_Expression}
    A \emph{regular expression}, sometimes called a \emph{regex} is a way to define a sequence of characters to form strings.
\end{definition}

\subsubsection{String Length Options}\label{subsubsec:String_Type_Length_Options}
\begin{definition}[Static Length String]\label{def:Static_Length_String}
  A \emph{static length string} has its length set at the time of string creation.
  It is static, in that the length cannot be changed later in the program's execution.
\end{definition}

\begin{definition}[Dynamic Length String]\label{def:Dynamic_Length_String}
  A \emph{dynamic length string} has its length set at the time of string creation.
  However, strings can change their length, and there is no set maximum size they can have.
\end{definition}

\begin{definition}[Limited Dynamic Length String]\label{def:Limited_Dynamic_Length_String}
  A \emph{dynamic length string} has its length set at the time of string creation.
  However, the string can be redefined later in the program, so long as the new string is the same length or shorter than when the string \nameref{def:Variable} was defined.
\end{definition}

\subsubsection{Evaluation}\label{subsubsec:String_Type_Evaluation}
Primitive string type implementations would require there to be predefined functions for many string operations.
If there aren't, then programming in that language becomes more cumbersome.

\nameref{def:Dynamic_Length_String}s are the most flexible, but the overhead of their implementation should be weighed against that flexibility.

\subsubsection{Implementation of Character String Types}\label{subsubsec:Implementation_of_Character_String_Types}
Software is used to implement string storage, retrieval, and manipulation.
When a language uses character arrays to store character string types, the language usually supplies few operations.

A \nameref{def:Descriptor} for a \nameref{def:Static_Length_String} has 3 fields:
\begin{enumerate}[noitemsep]
\item Name of the type
\item The type's length in characters
\item Address of the first character
\end{enumerate}

A \nameref{def:Descriptor} for a \nameref{def:Limited_Dynamic_Length_String} has 4 fields:
\begin{enumerate}[noitemsep]
\item Name of the type
\item The type's maximum length in characters
\item The length of the currently stored string
\item The address of the first character
\end{enumerate}

A \nameref{def:Descriptor} for a \nameref{def:Dynamic_Length_String} is more difficult to handle because of its dynamic nature.
There are 3 approaches to storing these:
\begin{enumerate}[noitemsep]
\item Strings stored in a linked list. If the string gets longer, individual nodes can be allocated from anywhere in the \nameref{def:Heap}.
  \begin{itemize}[noitemsep]
  \item A drawback of this is that extra storage of the links
  \item The necessary complexity of string operations
  \end{itemize}
\item Store strings as arrays of pointers to individual characters on the \nameref{def:Heap}
  \begin{itemize}[noitemsep]
  \item This uses more memory, but processing is faster than the linked list approach.
  \end{itemize}
\item Store complete strings in adjacent cells, and when a new longer string comes along, store the whole thing in a new area in the \nameref{def:Heap} and deallocate the old location.
  \begin{itemize}[noitemsep]
  \item Less storage required compared to the linked list approach
  \item Allocation and deallocation of the string is more difficult
  \end{itemize}
\end{enumerate}

\subsection{User-Defined Ordinal Types}\label{subsec:User_Defined_Ordinal_Types}
\begin{definition}[Ordinal Type]\label{def:Ordinal_Type}
  An \emph{ordinal type} is a \nameref{def:Variable_Type} in which the range of possible values can be associated with the set of positive integers.

  For example, in Java, the primitive ordinal types are: \texttt{int}, \texttt{char}, and \texttt{boolean}.

  \begin{remark}
    There are 2 \nameref*{subsec:User_Defined_Ordinal_Types} that are supported by most programming languages:
    \begin{itemize}[noitemsep]
    \item \nameref{subsubsec:Enumeration_Types}
    \item \nameref{subsubsec:Subrange_Types}
    \end{itemize}
  \end{remark}
\end{definition}

\subsubsection{Enumeration Types}\label{subsubsec:Enumeration_Types}
\begin{definition}[Enumeration Type]\label{def:Enumeration_Type}
  An \emph{enumeration type} is one in which all of the possible values, which are named constants, are provided (enumerated) in the definition.
  Enumeration types provide a way of defining and grouping collections of named constants, called \emph{enumeration constants}.

  This is an example of an enumeration type in C\#:
\begin{minted}[frame=lines,linenos]{csharp}
enum days {Mon, Tue, Wed, Thu, Fri, Sat, Sun};
\end{minted}

  \begin{remark}
    Typically, each of the numeration constants is implicitly assigned an integer literal, though they can be given integer literals explicitly too.
  \end{remark}
\end{definition}

The design issues for \nameref{def:Enumeration_Type}s are:
\begin{itemize}[noitemsep]
\item Is an enumeration constant allowed to appear in more than one \nameref{def:Enumeration_Type} definition, and if so, how is the type of an occurance of that enumeration constant in the program checked?
\item Are enumeration constants coerced to integers?
\item Are any other types coerced to an \nameref{def:Enumeration_Type}?
\end{itemize}

\paragraph{Designs}\label{par:Enumeration_Types_Designs}
In languages without native support of \nameref{def:Enumeration_Type}s, they are simulated with integer values.
For example,
\begin{minted}[frame=lines,linenos]{c}
int red = 0, blue = 1;
\end{minted}

However, this can lead to unexpected behavior.
For example, the variables \texttt{red} and \texttt{blue} can be added together.
In essence, there would be no \nameref{def:Type_Checking}.
The value for those variables could be overwritten somewhere.
Though, that issue would be solved by making the variable a constant instead.

C and Pascal introduced the use of \nameref{def:Enumeration_Type}s.
These implicitly use default values, integers, as the enumeration constants.
However, the values can be set explicitly, by the programmer.
With these \nameref{def:Enumeration_Type}s, we have and avoid these issues:
\begin{minted}[frame=lines,linenos]{c}
enum colors {red, blue, green, yellow, black};
colors myColor = blue, yourColor = red;
myColor++; // Valid code, sets myColor from blue to green
myColor = 4; // Illegal
myColor = (colors) 4; // Legal because 4 is being typecast
\end{minted}

These help prevent some issues, but not all.

The next iteration was in Ada.
They allowed for \emph{overloaded literals} in their \nameref{def:Enumeration_Type}s.
This means there were enumeration constants shared between 2 \nameref{def:Enumeration_Type}s in the same referencing environment.
In this case, the value must be determinable from the context of the \nameref{def:Enumeration_Type}.
Sometimes, a mroe explicit specification must be used.
Additionally, because the enumerations constants were \textbf{not} coerced to integers, nor were the \textbf{enumeration variables}, the range of operations and range of values for the enumeration constants was limited.
This allowed the compiler to pick up many more errors.

\begin{remark*}
  None of the relatively recent scripting kinds of languages include \nameref{def:Enumeration_Type}s.
  These include Perl, JavaScript, PHP, Python, Ruby, and Lua.
\end{remark*}

\paragraph{Evaluation}\label{par:Enumeration_Types_Evaluation}
Enhancements to both \nameref{subsec:Readability} and \nameref{subsec:Reliability}.
\begin{itemize}[noitemsep]
\item \nameref{subsec:Readability} is enhanced by better named values
\item \nameref{subsec:Reliability} is enhanced by being able to perform \nameref{def:Type_Checking} on the \nameref{def:Enumeration_Type}s.
  \begin{itemize}[noitemsep]
  \item No arithmetic operations allowed on \nameref{def:Enumeration_Type}s.
  \item No enumeration variable can be assigned a value outside the \nameref{def:Enumeration_Type}'s assigned range.
  \end{itemize}
\end{itemize}

\subsubsection{Subrange Types}\label{subsubsec:Subrange_Types}
\begin{definition}[Subrange Type]\label{def:Subrange_Type}
  A \emph{subrange type} is a contiguous sequence of an \nameref{def:Ordinal_Type}.
  For example, this is a subrange: \texttt{12..14}.
\end{definition}

\paragraph{Ada's Design}\label{par:Adas_Subrange_Types_Design}
Ada included \nameref{def:Subrange_Type}s in \nameref{def:Ada_Subtype}s.

\begin{definition}[Subtype]\label{def:Ada_Subtype}
  A \emph{subtype} in Ada is an extension, usually constrained, version of existing types.
  For example,
\begin{minted}[frame=lines,linenos]{ada}
type Days is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
subtype Weekdays is Days range Mon..Fri;
Day1 : Days;
Day2 : Weekdays;
...
Day2 := Day1; -- Will only work if Day1 has Mon-Fri, fails if Day1 = Sat or Sun
\end{minted}
\end{definition}

The compiler generates range-checking code for every assignment to the subrange type.
Subranges require run-time range checking.

\paragraph{Evaluation}\label{par:Subrange_Types_Evaluation}
\nameref{def:Subrange_Type}s improve \nameref{subsec:Readability} by making it clear that \nameref{def:Variable}s of \nameref{def:Ada_Subtype}s can only store a certain range of values.
\nameref{subsec:Reliability} is increased with \nameref{def:Subrange_Type}s because assigning a value to a subrange variable outside its range is detected as an error.

\subsubsection{Implementation of \nameref*{subsec:User_Defined_Ordinal_Types}}\label{subsubsec:Implementation_User_Defined_Ordinal_Types}
\nameref{def:Enumeration_Type}s are usually implemented on integers.
However, without restrictions on ranges of values and possible operations, this does \textbf{not} improve \nameref{subsec:Reliability}.

\nameref{def:Subrange_Type}s are implemented the same way as their parent types, except range checks are implicity included by the compiler in every assignment of a variable or expression to a subrange variable.

\subsection{List Types}\label{subsec:List_Types}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
