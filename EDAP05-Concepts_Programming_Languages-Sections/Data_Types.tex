\section{Data Types}\label{sec:Data_Types}
\begin{definition}[Data Type]\label{def:Data_Type}
  A \emph{data type} defines a collection of data values and a set of predefined operations on those values.
  The data types present in a language used for a particular problem should closely mirror the objects in the real-world the program is solving.

  They can be mathematically defined as
  \begin{equation}\label{eq:Data_Type}
    v : \DataType
  \end{equation}
  where $v$ is a value and $\DataType$ is a type.

  \begin{remark}[Has the Type]\label{rmk:Has_the_Type}
    To say ``$v$ has the type $\DataType$''
    \begin{equation}\label{eq:Has_the_Type}
      v \in \DataType
    \end{equation}
  \end{remark}
\end{definition}

User-defined data types allow for:
\begin{itemize}[noitemsep]
\item Improved readability with better named \nameref{def:Data_Type}s.
\item Improved modifiability with programmers having to change just one common data type somewhere for a large change throughout a program.
\end{itemize}

If we take user-defined \nameref{def:Data_Type}s further, we end up with \emph{abstract data types}.
These force an interface for a particular data type, which is then visible to the user, and the data and background operations are hidden away.

Because of the wide variety of \nameref{def:Data_Type}s present today, it is more useful to think about \nameref{def:Variable}s in terms of \nameref{def:Descriptor}.

\begin{definition}[Descriptor]\label{def:Descriptor}
  A \emph{descriptor} is the collection of attributes of a \nameref{def:Variable}.
  In an implementation, a descriptor is an area of \nameref{def:Memory} that stores the attributes of a \nameref{def:Variable}.
  
  There are a 2 cases for these:
  \begin{enumerate}[noitemsep]
  \item If all attributes are static, then they are known at compile-time, and the \nameref{def:Compiler} can use the symbol table to construct everything.
  \item If all attributes are dynamic, then the symbol table and all attributes must be stored in \nameref{def:Memory} during program execution.
  \end{enumerate}

  Descriptors are used for \nameref{def:Type_Checking} and building the code for \nameref{def:Variable_Memory_Allocation} and \nameref{def:Variable_Memory_Deallocation} operations.
\end{definition}

\begin{definition}[Type Error]\label{def:Type_Error}
  A \emph{type error} is an attempt to perform an operation that requires an input value of type $\tau$ with a value $v$ even though $v : \tau$ does not hold.
\end{definition}

\begin{definition}[Type Preservation]\label{def:Type_Preservation}
  A type system has the \emph{type preservation} (or \emph{subject reduction}) property if for any $e \EvaluatesTo v$, $e : \DataType$ implies $v : \DataType$.

  There are 3 properties we want to have a type preserving type system to have:
  \begin{enumerate}[noitemsep]
  \item \emph{Type Preservation}: The predictions of the type system agree with the evaluation rules.
  \item \emph{Progress}: The type system only assigns a type if the evaluation rules will not get ``stuck'' due to a missing semantic rule. This is not the same as guaranteeing that the program itself terminates, meaning but it does guarantee that the language implementation will never run into a situation in which it doesn't know what to do next.
  \item \emph{Termination}: We want the type system to be decidable, that is, we want an automatic mechanism that performs type checking.
  \end{enumerate}
\end{definition}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Primitive_Data_Types}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Character_String_Types}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/User_Defined_Ordinal_Types}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/List_Types}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Arrays}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Associative_Arrays}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Record_Types}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Tuple_Types}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Union_Types}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Pointer_Reference_Types}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Data_Types/Type_Equivalence}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
