\section{Data Types}\label{sec:Data_Types}
\begin{definition}[Data Type]\label{def:Data_Type}
  A \emph{data type} defines a collection of data values and a set of predefined operations on those values.
  The data types present in a language used for a particular problem should closely mirror the objects in the real-world the program is solving.
\end{definition}

User-defined data types allow for:
\begin{itemize}[noitemsep]
\item Improved readability with better named \nameref{def:Data_Type}s.
\item Improved modifiability with programmers having to change just one common data type somewhere for a large change throughout a program.
\end{itemize}

If we take user-defined \nameref{def:Data_Type}s further, we end up with \emph{abstract data types}.
These force an interface for a particular data type, which is then visible to the user, and the data and background operations are hidden away.

Because of the wide variety of \nameref{def:Data_Type}s present today, it is more useful to think about \nameref{def:Variable}s in terms of \nameref{def:Descriptor}

\begin{definition}[Descriptor]\label{def:Descriptor}
  A \emph{descriptor} is the collection of attributes of a \nameref{def:Variable}.
  In an implementation, a descriptor is an area of \nameref{def:Memory} that stores the attributes of a \nameref{def:Variable}.
  
  There are a 2 cases for these:
  \begin{enumerate}[noitemsep]
  \item If all attributes are static, then they are known at compile-time, and the \nameref{def:Compiler} can use the symbol table to construct everything.
  \item If all attributes are dynamic, then the symbol table and all attributes must be stored in \nameref{def:Memory} during program execution.
  \end{enumerate}

  Descriptors are used for \nameref{def:Type_Checking} and building the code for \nameref{def:Variable_Memory_Allocation} and \nameref{def:Variable_Memory_Deallocation} operations.
\end{definition}

\subsection{Primitive Data Types}\label{subsec:Primitive_Data_Types}
\begin{definition}[Primitive Data Type]\label{def:Primitive_Data_Type}
  \emph{Primitive data type}s are \nameref{def:Data_Type}s that are \textbf{not} defined in terms of other data types.
  Nearly all programming languages provide these.
  Some are reflections of hardware, like integers, and others require only little software support for their impmlementation, floating-point numbers for instance.
\end{definition}

\subsubsection{Numeric Types}\label{subsubsec:Numeric_Primitive_Data_Types}
This section will discuss the 4 main types of numeric \nameref{def:Data_Type}s present in most programming languages.

\begin{definition}[Numeric Data Type]\label{def:Numeric_Data_Type}
  \emph{Numeric data type}s are \nameref{def:Data_Type}s that handle numbers.
\end{definition}

\paragraph{Integer}\label{par:Integer_Numeric_Primitive_Data_Type}
Integers are the most common \nameref{def:Numeric_Data_Type}.
Many languages support several sizes.
Java supports 4: \texttt{byte}, \texttt{short}, \texttt{int}, and \texttt{long}.
There can be unsigned integers as well.

If there are signed integers, the negative integers are stored in \nameref{def:Memory} in \nameref{def:Integer_Twos_Complement}.
\begin{definition}[Twos Complement]\label{def:Integer_Twos_Complement}
  \emph{Twos complement} is a way to store negative integers.
  To find the twos complement:
  \begin{enumerate}[noitemsep]
  \item The magnitude of the integer is found in binary
  \item The logical complement of that is computed
  \item One (1) is added to the logical complement
  \end{enumerate}
  
  \begin{remark}
    Using \nameref{def:Integer_Twos_Complement} is similar to adding by a negative number to an integer instead of performing subtraction.
  \end{remark}
\end{definition}

\paragraph{Floating-Point}\label{par:Floating_Point_Numeric_Primitive_Data_Type}
\begin{definition}[Floating-Point]\label{def:Floating_Point}
  \emph{Floating-point} \nameref{def:Data_Type}s model real (fractional/rational) numbers.
  However, these representations are only approximations for many real values.
  For example, $\pi$ cannot be represented in floating-point notation.

  Most programming languages implement 2 types of floating-point \nameref{def:Data_Type}s.
  \begin{enumerate}[noitemsep]
  \item \texttt{float}: The standard size, 32 bits (4 bytes). Represent the real number as a decimal and exponent, like scientific notation.
    \begin{itemize}[noitemsep]
    \item The first bit is a \emph{sign bit} (1 for negative)
    \item The next 8 bits are for the \emph{exponent}, normalized so that a real number raised to $-127$, i.e. $x^{-127}$, has an exponent bit value of 0.
      \begin{itemize}[noitemsep]
      \item This does mean that $x^{128}$ would have a bit-valued exponent of $255$.
      \end{itemize}
    \item The last 23 bits are for the fraction, called the \emph{mantissa}. This is the fractional portion of the scientific notation, represented in binary, with the first 1 of the bit sequence left off.
    \end{itemize}
  \item \texttt{double}: Used in cases where larger/smaller fractions or larger/smaller exponents are needed, 64 bits (8 bytes).
    \begin{itemize}[noitemsep]
    \item The first bit is a \emph{sign bit} (1 for negative)
    \item The next 11 bits are for the \emph{exponent}, normalized so that a real number raised to $-1023$, i.e. $x^{-1023}$, has an exponent bit value of 0.
      \begin{itemize}[noitemsep]
      \item This does mean that $x^{1024}$ would have a bit-valued exponent of $2048$.
      \end{itemize}
    \item The last 52 bits are for the fraction, called the \emph{mantissa}. This is the fractional portion of the scientific notation, represented in binary, with the first 1 of the bit sequence left off.
    \end{itemize}
  \end{enumerate}
\end{definition}

\nameref{def:Floating_Point} numbers are are specified in IEEE Floating-Point Standard 754.

\begin{definition}[Floating-Point Precision]\label{def:Floating_Point_Precision}
  \emph{Precision} is the accuracy of the fraction part of the \nameref{def:Floating_Point} number, and how well it represents the real number's value.
\end{definition}

\begin{definition}[Floating-Point Range]\label{def:Floating_Point_Range}
  \emph{Range} is a combination of the range of fractions and the range of the exponents.
\end{definition}

\paragraph{Complex}\label{par:Complex_Numeric_Primitive_Data_Type}
Some programming languages support complex numbers natively, and they also support complex-number mathematical operations natively.
The imaginary portion of the number is typically denoted with \texttt{j} or \texttt{J}.

\paragraph{Decimal}\label{par:Decimal_Numeric_Primitive_Data_Type}
In a computer, decimal numbers are stored in \nameref{def:Binary_Coded_Decimal}.
There is also special hardware to support hardware-level mathematical operations on these types of numbers.
If this hardware is not present, the calculations can be simulated in software.

\begin{definition}[Binary Coded Decimal]\label{def:Binary_Coded_Decimal}
  \emph{Binary Coded Decimal}, or \emph{BCD}, is a way to represent decimal numbers with perfect accuracy, albeit at the expense of some space.
  There is a one-to-one mapping of the binary representations of these numbers to decimal, and anything greater than 9 is discarded.
  \begin{table}[h!]
    \centering
    \begin{tabular}{cc}
      \toprule
      Decimal & \nameref{def:Binary_Coded_Decimal} \\
      \midrule
      0 & 0000 \\
      1 & 0001 \\
      2 & 0010 \\
      3 & 0011 \\
      4 & 0100 \\
      5 & 0101 \\
      6 & 0110 \\
      7 & 0111 \\
      8 & 1000 \\
      9 & 1001 \\
      \midrule
      X & 1010 \\
      X & 1011 \\
      X & 1100 \\
      X & 1101 \\
      X & 1110 \\
      X & 1111 \\
      \bottomrule
    \end{tabular}
    \caption{Binary Coded Decimal}
    \label{tab:Binary_Coded_Decimal}
  \end{table}

  \begin{remark}
    These numbers are usually stored 2 per byte, because each only takes 4 bits.
  \end{remark}
\end{definition}

\subsubsection{Boolean Types}\label{subsubsec:Boolean_Primitive_Data_Types}
\begin{definition}[Boolean Data Type]\label{def:Boolean_Data_Type}
  \emph{Boolean data type}s only store 2 values: \texttt{true} and \texttt{false}.
  Some older langauge implementations did not support these, but most do today.
  If a language does not support a boolean data type, then 0 is considered false, and 1 is considered true.

  \begin{remark}[Storage in Memory]\label{rmk:Boolean_Storage_in_Memory}
    Although a single bit can represent a \nameref{def:Boolean_Data_Type}, single bits of \nameref{def:Memory} cannot be efficiently access on many machines.
    Thus, \nameref{def:Boolean_Data_Type}s are usually stored in a single byte.
  \end{remark}
\end{definition}

\subsubsection{Character Types}\label{subsubsec:Character_Primitive_Data_Types}
Characters are stored in \nameref{def:Memory} as numeric encodings.
These are usually single characters, \textbf{not multiple characters together (strings)}.

Characters were originally handled by ASCII, but now there are several encodings, with Unicode being more commonly used now.
Unicode supports all human languages, glyphs, and other characters, like emojis.
The first 128 characters of Unicode match up with ASCII for intercompatibility.

ASCII required 8 bits, Unicode (UTF-16) uses 16.

\subsection{Character String Types}\label{subsec:Character_String_Types}
\begin{definition}[Character String Type]\label{def:Character_String_Type}
  A \emph{character string type} is one in which the values consist of sequences of characters.
\end{definition}

\subsubsection{Design Issues}\label{subsubsec:Character_String_Types_Design_Issues}
There are 2 questions that need to be answered when designing a language implementation when it comes to strings.
\begin{itemize}[noitemsep]
\item Should strings be a special kind of character array or a primitive type?
\item Should strings have static or dynamic lengths?
\end{itemize}

\subsubsection{Strings and Their Operations}\label{subsubsec:String_Types_and_Ops}
The most common string operations are:
\begin{itemize}[noitemsep]
\item Assignment
  \begin{itemize}[noitemsep]
  \item What happens when a string is longer than expected? C/C++'s \texttt{strcpy} function
  \end{itemize}
\item Concatenation
\item Substring Reference
  \begin{itemize}[noitemsep]
  \item Discussed more in the context of arrays, where substring references are called slices.
  \end{itemize}
\item Comparison
  \begin{itemize}[noitemsep]
  \item How do we compare 2 strings, where one is longer than the other?
  \end{itemize}
\item Pattern Matching
\end{itemize}

In C and C++, strings are terminated with the null character, \texttt{00}.
This way we do not need to track the length of a string.

Object-Oriented Languages (Java, Ruby, C\#) use classes to represent strings.
The only field in these objects is a constant string.

Python supports strings as a primitive type, and supports array-like operations on them.

Some languages have \nameref{def:Regular_Expression}s built in, like Perl, JavaScript, Ruby, and PHP.\@
Others have libraries that handle \nameref{def:Regular_Expression}s.

\begin{definition}[Regular Expression]\label{def:Regular_Expression}
    A \emph{regular expression}, sometimes called a \emph{regex} is a way to define a sequence of characters to form strings.
\end{definition}

\subsubsection{String Length Options}\label{subsubsec:String_Type_Length_Options}
\begin{definition}[Static Length String]\label{def:Static_Length_String}
  A \emph{static length string} has its length set at the time of string creation.
  It is static, in that the length cannot be changed later in the program's execution.
\end{definition}

\begin{definition}[Dynamic Length String]\label{def:Dynamic_Length_String}
  A \emph{dynamic length string} has its length set at the time of string creation.
  However, strings can change their length, and there is no set maximum size they can have.
\end{definition}

\begin{definition}[Limited Dynamic Length String]\label{def:Limited_Dynamic_Length_String}
  A \emph{dynamic length string} has its length set at the time of string creation.
  However, the string can be redefined later in the program, so long as the new string is the same length or shorter than when the string \nameref{def:Variable} was defined.
\end{definition}

\subsubsection{Evaluation}\label{subsubsec:String_Type_Evaluation}
Primitive string type implementations would require there to be predefined functions for many string operations.
If there aren't, then programming in that language becomes more cumbersome.

\nameref{def:Dynamic_Length_String}s are the most flexible, but the overhead of their implementation should be weighed against that flexibility.

\subsubsection{Implementation of Character String Types}\label{subsubsec:Implementation_of_Character_String_Types}
Software is used to implement string storage, retrieval, and manipulation.
When a language uses character arrays to store character string types, the language usually supplies few operations.

A \nameref{def:Descriptor} for a \nameref{def:Static_Length_String} has 3 fields:
\begin{enumerate}[noitemsep]
\item Name of the type
\item The type's length in characters
\item Address of the first character
\end{enumerate}

A \nameref{def:Descriptor} for a \nameref{def:Limited_Dynamic_Length_String} has 4 fields:
\begin{enumerate}[noitemsep]
\item Name of the type
\item The type's maximum length in characters
\item The length of the currently stored string
\item The address of the first character
\end{enumerate}

A \nameref{def:Descriptor} for a \nameref{def:Dynamic_Length_String} is more difficult to handle because of its dynamic nature.
There are 3 approaches to storing these:
\begin{enumerate}[noitemsep]
\item Strings stored in a linked list. If the string gets longer, individual nodes can be allocated from anywhere in the \nameref{def:Heap}.
  \begin{itemize}[noitemsep]
  \item A drawback of this is that extra storage of the links
  \item The necessary complexity of string operations
  \end{itemize}
\item Store strings as arrays of pointers to individual characters on the \nameref{def:Heap}
  \begin{itemize}[noitemsep]
  \item This uses more memory, but processing is faster than the linked list approach.
  \end{itemize}
\item Store complete strings in adjacent cells, and when a new longer string comes along, store the whole thing in a new area in the \nameref{def:Heap} and deallocate the old location.
  \begin{itemize}[noitemsep]
  \item Less storage required compared to the linked list approach
  \item Allocation and deallocation of the string is more difficult
  \end{itemize}
\end{enumerate}

\subsection{User-Defined Ordinal Types}\label{subsec:User_Defined_Ordinal_Types}
\subsubsection{Enumeration Types}\label{subsubsec:Enumeration_Types}
\paragraph{Designs}\label{par:Enumeration_Types_Designs}
\paragraph{Evaluation}\label{par:Enumeration_Types_Evaluation}

\subsubsection{Subrange Types}\label{subsubsec:Subrange_Types}
\paragraph{Ada's Design}\label{par:Adas_Subrange_Types_Design}
\paragraph{Evaluation}\label{par:Subrange_Types_Evaluation}

\subsubsection{Implementation of \nameref*{subsec:User_Defined_Ordinal_Types}}\label{subsubsec:Implementation_User_Defined_Ordinal_Types}

\subsection{List Types}\label{subsec:List_Types}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
