\section{Data Types}\label{sec:Data_Types}
\begin{definition}[Data Type]\label{def:Data_Type}
  A \emph{data type} defines a collection of data values and a set of predefined operations on those values.
  The data types present in a language used for a particular problem should closely mirror the objects in the real-world the program is solving.

  They can be mathematically defined as
  \begin{equation}\label{eq:Data_Type}
    v : \DataType
  \end{equation}
  where $v$ is a value and $\tau$ is a type.

  \begin{remark}[Has the Type]\label{rmk:Has_the_Type}
    To say ``$v$ has the type $\tau$''
    \begin{equation}\label{eq:Has_the_Type}
      v \in \DataType
    \end{equation}
  \end{remark}
\end{definition}

User-defined data types allow for:
\begin{itemize}[noitemsep]
\item Improved readability with better named \nameref{def:Data_Type}s.
\item Improved modifiability with programmers having to change just one common data type somewhere for a large change throughout a program.
\end{itemize}

If we take user-defined \nameref{def:Data_Type}s further, we end up with \emph{abstract data types}.
These force an interface for a particular data type, which is then visible to the user, and the data and background operations are hidden away.

Because of the wide variety of \nameref{def:Data_Type}s present today, it is more useful to think about \nameref{def:Variable}s in terms of \nameref{def:Descriptor}.

\begin{definition}[Descriptor]\label{def:Descriptor}
  A \emph{descriptor} is the collection of attributes of a \nameref{def:Variable}.
  In an implementation, a descriptor is an area of \nameref{def:Memory} that stores the attributes of a \nameref{def:Variable}.
  
  There are a 2 cases for these:
  \begin{enumerate}[noitemsep]
  \item If all attributes are static, then they are known at compile-time, and the \nameref{def:Compiler} can use the symbol table to construct everything.
  \item If all attributes are dynamic, then the symbol table and all attributes must be stored in \nameref{def:Memory} during program execution.
  \end{enumerate}

  Descriptors are used for \nameref{def:Type_Checking} and building the code for \nameref{def:Variable_Memory_Allocation} and \nameref{def:Variable_Memory_Deallocation} operations.
\end{definition}

\begin{definition}[Type Error]\label{def:Type_Error}
  A \emph{type error} is an attempt to perform an operation that requires an input value of type $\tau$ with a value $v$ even though $v : \tau$ does not hold.
\end{definition}

\begin{definition}[Type Preservation]\label{def:Type_Preservation}
  A type system has the \emph{type preservation} (or \emph{subject reduction}) property if for any $e \EvaluatesTo v$, $e : \DataType$ implies $v : \DataType$.

  There are 3 properties we want to have a type preserving type system to have:
  \begin{enumerate}[noitemsep]
  \item \emph{Type Preservation}: The predictions of the type system agree with the evaluation rules.
  \item \emph{Progress}: The type system only assigns a type if the evaluation rules will not get ``stuck'' due to a missing semantic rule. This is not the same as guaranteeing that the program itself terminates, meaning but it does guarantee that the language implementation will never run into a situation in which it doesn't know what to do next.
  \item \emph{Termination}: We want the type system to be decidable, that is, we want an automatic mechanism that performs type checking.
  \end{enumerate}
\end{definition}

\subsection{Primitive Data Types}\label{subsec:Primitive_Data_Types}
\begin{definition}[Primitive Data Type]\label{def:Primitive_Data_Type}
  \emph{Primitive data type}s are \nameref{def:Data_Type}s that are \textbf{not} defined in terms of other data types.
  Nearly all programming languages provide these.
  Some are reflections of hardware, like integers, and others require only little software support for their impmlementation, floating-point numbers for instance.
\end{definition}

\subsubsection{Numeric Types}\label{subsubsec:Numeric_Primitive_Data_Types}
This section will discuss the 4 main types of numeric \nameref{def:Data_Type}s present in most programming languages.

\begin{definition}[Numeric Data Type]\label{def:Numeric_Data_Type}
  \emph{Numeric data type}s are \nameref{def:Data_Type}s that handle numbers.
\end{definition}

\paragraph{Integer}\label{par:Integer_Numeric_Primitive_Data_Type}
Integers are the most common \nameref{def:Numeric_Data_Type}.
Many languages support several sizes.
Java supports 4: \texttt{byte}, \texttt{short}, \texttt{int}, and \texttt{long}.
There can be unsigned integers as well.

If there are signed integers, the negative integers are stored in \nameref{def:Memory} in \nameref{def:Integer_Twos_Complement}.
\begin{definition}[Twos Complement]\label{def:Integer_Twos_Complement}
  \emph{Twos complement} is a way to store negative integers.
  To find the twos complement:
  \begin{enumerate}[noitemsep]
  \item The magnitude of the integer is found in binary
  \item The logical complement of that is computed
  \item One (1) is added to the logical complement
  \end{enumerate}
  
  \begin{remark}
    Using \nameref{def:Integer_Twos_Complement} is similar to adding by a negative number to an integer instead of performing subtraction.
  \end{remark}
\end{definition}

\paragraph{Floating-Point}\label{par:Floating_Point_Numeric_Primitive_Data_Type}
\begin{definition}[Floating-Point]\label{def:Floating_Point}
  \emph{Floating-point} \nameref{def:Data_Type}s model real (fractional/rational) numbers.
  However, these representations are only approximations for many real values.
  For example, $\pi$ cannot be represented in floating-point notation.

  Most programming languages implement 2 types of floating-point \nameref{def:Data_Type}s.
  \begin{enumerate}[noitemsep]
  \item \texttt{float}: The standard size, 32 bits (4 bytes). Represent the real number as a decimal and exponent, like scientific notation.
    \begin{itemize}[noitemsep]
    \item The first bit is a \emph{sign bit} (1 for negative)
    \item The next 8 bits are for the \emph{exponent}, normalized so that a real number raised to $-127$, i.e. $x^{-127}$, has an exponent bit value of 0.
      \begin{itemize}[noitemsep]
      \item This does mean that $x^{128}$ would have a bit-valued exponent of $255$.
      \end{itemize}
    \item The last 23 bits are for the fraction, called the \emph{mantissa}. This is the fractional portion of the scientific notation, represented in binary, with the first 1 of the bit sequence left off.
    \end{itemize}
  \item \texttt{double}: Used in cases where larger/smaller fractions or larger/smaller exponents are needed, 64 bits (8 bytes).
    \begin{itemize}[noitemsep]
    \item The first bit is a \emph{sign bit} (1 for negative)
    \item The next 11 bits are for the \emph{exponent}, normalized so that a real number raised to $-1023$, i.e. $x^{-1023}$, has an exponent bit value of 0.
      \begin{itemize}[noitemsep]
      \item This does mean that $x^{1024}$ would have a bit-valued exponent of $2048$.
      \end{itemize}
    \item The last 52 bits are for the fraction, called the \emph{mantissa}. This is the fractional portion of the scientific notation, represented in binary, with the first 1 of the bit sequence left off.
    \end{itemize}
  \end{enumerate}
\end{definition}

\nameref{def:Floating_Point} numbers are are specified in IEEE Floating-Point Standard 754.

\begin{definition}[Floating-Point Precision]\label{def:Floating_Point_Precision}
  \emph{Precision} is the accuracy of the fraction part of the \nameref{def:Floating_Point} number, and how well it represents the real number's value.
\end{definition}

\begin{definition}[Floating-Point Range]\label{def:Floating_Point_Range}
  \emph{Range} is a combination of the range of fractions and the range of the exponents.
\end{definition}

\paragraph{Complex}\label{par:Complex_Numeric_Primitive_Data_Type}
Some programming languages support complex numbers natively, and they also support complex-number mathematical operations natively.
The imaginary portion of the number is typically denoted with \texttt{j} or \texttt{J}.

\paragraph{Decimal}\label{par:Decimal_Numeric_Primitive_Data_Type}
In a computer, decimal numbers are stored in \nameref{def:Binary_Coded_Decimal}.
There is also special hardware to support hardware-level mathematical operations on these types of numbers.
If this hardware is not present, the calculations can be simulated in software.

\begin{definition}[Binary Coded Decimal]\label{def:Binary_Coded_Decimal}
  \emph{Binary Coded Decimal}, or \emph{BCD}, is a way to represent decimal numbers with perfect accuracy, albeit at the expense of some space.
  There is a one-to-one mapping of the binary representations of these numbers to decimal, and anything greater than 9 is discarded.
  \begin{table}[h!]
    \centering
    \begin{tabular}{cc}
      \toprule
      Decimal & \nameref{def:Binary_Coded_Decimal} \\
      \midrule
      0 & 0000 \\
      1 & 0001 \\
      2 & 0010 \\
      3 & 0011 \\
      4 & 0100 \\
      5 & 0101 \\
      6 & 0110 \\
      7 & 0111 \\
      8 & 1000 \\
      9 & 1001 \\
      \midrule
      X & 1010 \\
      X & 1011 \\
      X & 1100 \\
      X & 1101 \\
      X & 1110 \\
      X & 1111 \\
      \bottomrule
    \end{tabular}
    \caption{Binary Coded Decimal}
    \label{tab:Binary_Coded_Decimal}
  \end{table}

  \begin{remark}
    These numbers are usually stored 2 per byte, because each only takes 4 bits.
  \end{remark}
\end{definition}

\subsubsection{Boolean Types}\label{subsubsec:Boolean_Primitive_Data_Types}
\begin{definition}[Boolean Data Type]\label{def:Boolean_Data_Type}
  \emph{Boolean data type}s only store 2 values: \texttt{true} and \texttt{false}.
  Some older language implementations did not support these, but most do today.
  If a language does not support a boolean data type, then 0 is considered false, and 1 is considered true.

  \begin{remark}[Storage in Memory]\label{rmk:Boolean_Storage_in_Memory}
    Although a single bit can represent a \nameref{def:Boolean_Data_Type}, single bits of \nameref{def:Memory} cannot be efficiently access on many machines.
    Thus, \nameref{def:Boolean_Data_Type}s are usually stored in a single byte.
  \end{remark}
\end{definition}

\subsubsection{Character Types}\label{subsubsec:Character_Primitive_Data_Types}
Characters are stored in \nameref{def:Memory} as numeric encodings.
These are usually single characters, \textbf{not multiple characters together (strings)}.

Characters were originally handled by ASCII, but now there are several encodings, with Unicode being more commonly used now.
Unicode supports all human languages, glyphs, and other characters, like emojis.
The first 128 characters of Unicode match up with ASCII for intercompatibility.

ASCII required 8 bits, Unicode (UTF-16) uses 16.

\subsection{Character String Types}\label{subsec:Character_String_Types}
\begin{definition}[Character String Type]\label{def:Character_String_Type}
  A \emph{character string type} is one in which the values consist of sequences of characters.
\end{definition}

\subsubsection{Design Issues}\label{subsubsec:Character_String_Types_Design_Issues}
There are 2 questions that need to be answered when designing a language implementation when it comes to strings.
\begin{itemize}[noitemsep]
\item Should strings be a special kind of character array or a primitive type?
\item Should strings have static or dynamic lengths?
\end{itemize}

\subsubsection{Strings and Their Operations}\label{subsubsec:String_Types_and_Ops}
The most common string operations are:
\begin{itemize}[noitemsep]
\item Assignment
  \begin{itemize}[noitemsep]
  \item What happens when a string is longer than expected? C/C++'s \texttt{strcpy} function
  \end{itemize}
\item Concatenation
\item Substring Reference
  \begin{itemize}[noitemsep]
  \item Discussed more in the context of arrays, where substring references are called slices.
  \end{itemize}
\item Comparison
  \begin{itemize}[noitemsep]
  \item How do we compare 2 strings, where one is longer than the other?
  \end{itemize}
\item Pattern Matching
\end{itemize}

In C and C++, strings are terminated with the null character, \texttt{00}.
This way we do not need to track the length of a string.

Object-Oriented Languages (Java, Ruby, C\#) use classes to represent strings.
The only field in these objects is a constant string.

Python supports strings as a primitive type, and supports array-like operations on them.

Some languages have \nameref{def:Regular_Expression}s built in, like Perl, JavaScript, Ruby, and PHP.\@
Others have libraries that handle \nameref{def:Regular_Expression}s.

\begin{definition}[Regular Expression]\label{def:Regular_Expression}
    A \emph{regular expression}, sometimes called a \emph{regex} is a way to define a sequence of characters to form strings.
\end{definition}

\subsubsection{String Length Options}\label{subsubsec:String_Type_Length_Options}
\begin{definition}[Static Length String]\label{def:Static_Length_String}
  A \emph{static length string} has its length set at the time of string creation.
  It is static, in that the length cannot be changed later in the program's execution.
\end{definition}

\begin{definition}[Dynamic Length String]\label{def:Dynamic_Length_String}
  A \emph{dynamic length string} has its length set at the time of string creation.
  However, strings can change their length, and there is no set maximum size they can have.
\end{definition}

\begin{definition}[Limited Dynamic Length String]\label{def:Limited_Dynamic_Length_String}
  A \emph{dynamic length string} has its length set at the time of string creation.
  However, the string can be redefined later in the program, so long as the new string is the same length or shorter than when the string \nameref{def:Variable} was defined.
\end{definition}

\subsubsection{Evaluation}\label{subsubsec:String_Type_Evaluation}
Primitive string type implementations would require there to be predefined functions for many string operations.
If there aren't, then programming in that language becomes more cumbersome.

\nameref{def:Dynamic_Length_String}s are the most flexible, but the overhead of their implementation should be weighed against that flexibility.

\subsubsection{Implementation of Character String Types}\label{subsubsec:Implementation_of_Character_String_Types}
Software is used to implement string storage, retrieval, and manipulation.
When a language uses character arrays to store character string types, the language usually supplies few operations.

A \nameref{def:Descriptor} for a \nameref{def:Static_Length_String} has 3 fields:
\begin{enumerate}[noitemsep]
\item Name of the type
\item The type's length in characters
\item Address of the first character
\end{enumerate}

A \nameref{def:Descriptor} for a \nameref{def:Limited_Dynamic_Length_String} has 4 fields:
\begin{enumerate}[noitemsep]
\item Name of the type
\item The type's maximum length in characters
\item The length of the currently stored string
\item The address of the first character
\end{enumerate}

A \nameref{def:Descriptor} for a \nameref{def:Dynamic_Length_String} is more difficult to handle because of its dynamic nature.
There are 3 approaches to storing these:
\begin{enumerate}[noitemsep]
\item Strings stored in a linked list. If the string gets longer, individual nodes can be allocated from anywhere in the \nameref{def:Heap}.
  \begin{itemize}[noitemsep]
  \item A drawback of this is that extra storage of the links
  \item The necessary complexity of string operations
  \end{itemize}
\item Store strings as arrays of pointers to individual characters on the \nameref{def:Heap}
  \begin{itemize}[noitemsep]
  \item This uses more memory, but processing is faster than the linked list approach.
  \end{itemize}
\item Store complete strings in adjacent cells, and when a new longer string comes along, store the whole thing in a new area in the \nameref{def:Heap} and deallocate the old location.
  \begin{itemize}[noitemsep]
  \item Less storage required compared to the linked list approach
  \item Allocation and deallocation of the string is more difficult
  \end{itemize}
\end{enumerate}

\subsection{User-Defined Ordinal Types}\label{subsec:User_Defined_Ordinal_Types}
\begin{definition}[Ordinal Type]\label{def:Ordinal_Type}
  An \emph{ordinal type} is a \nameref{def:Variable_Type} in which the range of possible values can be associated with the set of positive integers.

  For example, in Java, the primitive ordinal types are: \texttt{int}, \texttt{char}, and \texttt{boolean}.

  \begin{remark}
    There are 2 \nameref*{subsec:User_Defined_Ordinal_Types} that are supported by most programming languages:
    \begin{itemize}[noitemsep]
    \item \nameref{subsubsec:Enumeration_Types}
    \item \nameref{subsubsec:Subrange_Types}
    \end{itemize}
  \end{remark}
\end{definition}

\subsubsection{Enumeration Types}\label{subsubsec:Enumeration_Types}
\begin{definition}[Enumeration Type]\label{def:Enumeration_Type}
  An \emph{enumeration type} is one in which all of the possible values, which are named constants, are provided (enumerated) in the definition.
  Enumeration types provide a way of defining and grouping collections of named constants, called \emph{enumeration constants}.

  This is an example of an enumeration type in C\#:
\begin{minted}[frame=lines,linenos]{csharp}
enum days {Mon, Tue, Wed, Thu, Fri, Sat, Sun};
\end{minted}

  \begin{remark}
    Typically, each of the numeration constants is implicitly assigned an integer literal, though they can be given integer literals explicitly too.
  \end{remark}
\end{definition}

The design issues for \nameref{def:Enumeration_Type}s are:
\begin{itemize}[noitemsep]
\item Is an enumeration constant allowed to appear in more than one \nameref{def:Enumeration_Type} definition, and if so, how is the type of an occurance of that enumeration constant in the program checked?
\item Are enumeration constants coerced to integers?
\item Are any other types coerced to an \nameref{def:Enumeration_Type}?
\end{itemize}

\paragraph{Designs}\label{par:Enumeration_Types_Designs}
In languages without native support of \nameref{def:Enumeration_Type}s, they are simulated with integer values.
For example,
\begin{minted}[frame=lines,linenos]{c}
int red = 0, blue = 1;
\end{minted}

However, this can lead to unexpected behavior.
For example, the variables \texttt{red} and \texttt{blue} can be added together.
In essence, there would be no \nameref{def:Type_Checking}.
The value for those variables could be overwritten somewhere.
Though, that issue would be solved by making the variable a constant instead.

C and Pascal introduced the use of \nameref{def:Enumeration_Type}s.
These implicitly use default values, integers, as the enumeration constants.
However, the values can be set explicitly, by the programmer.
With these \nameref{def:Enumeration_Type}s, we have and avoid these issues:
\begin{minted}[frame=lines,linenos]{c}
enum colors {red, blue, green, yellow, black};
colors myColor = blue, yourColor = red;
myColor++; // Valid code, sets myColor from blue to green
myColor = 4; // Illegal
myColor = (colors) 4; // Legal because 4 is being typecast
\end{minted}

These help prevent some issues, but not all.

The next iteration was in Ada.
They allowed for \emph{overloaded literals} in their \nameref{def:Enumeration_Type}s.
This means there were enumeration constants shared between 2 \nameref{def:Enumeration_Type}s in the same referencing environment.
In this case, the value must be determinable from the context of the \nameref{def:Enumeration_Type}.
Sometimes, a mroe explicit specification must be used.
Additionally, because the enumerations constants were \textbf{not} coerced to integers, nor were the \textbf{enumeration variables}, the range of operations and range of values for the enumeration constants was limited.
This allowed the compiler to pick up many more errors.

\begin{remark*}
  None of the relatively recent scripting kinds of languages include \nameref{def:Enumeration_Type}s.
  These include Perl, JavaScript, PHP, Python, Ruby, and Lua.
\end{remark*}

\paragraph{Evaluation}\label{par:Enumeration_Types_Evaluation}
Enhancements to both \nameref{subsec:Readability} and \nameref{subsec:Reliability}.
\begin{itemize}[noitemsep]
\item \nameref{subsec:Readability} is enhanced by better named values
\item \nameref{subsec:Reliability} is enhanced by being able to perform \nameref{def:Type_Checking} on the \nameref{def:Enumeration_Type}s.
  \begin{itemize}[noitemsep]
  \item No arithmetic operations allowed on \nameref{def:Enumeration_Type}s.
  \item No enumeration variable can be assigned a value outside the \nameref{def:Enumeration_Type}'s assigned range.
  \end{itemize}
\end{itemize}

\subsubsection{Subrange Types}\label{subsubsec:Subrange_Types}
\begin{definition}[Subrange Type]\label{def:Subrange_Type}
  A \emph{subrange type} is a contiguous sequence of an \nameref{def:Ordinal_Type}.
  For example, this is a subrange: \texttt{12..14}.
\end{definition}

\paragraph{Ada's Design}\label{par:Adas_Subrange_Types_Design}
Ada included \nameref{def:Subrange_Type}s in \nameref{def:Ada_Subtype}s.

\begin{definition}[Subtype]\label{def:Ada_Subtype}
  A \emph{subtype} in Ada is an extension, usually constrained, version of existing types.
  For example,
\begin{minted}[frame=lines,linenos]{ada}
type Days is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
subtype Weekdays is Days range Mon..Fri;
Day1 : Days;
Day2 : Weekdays;
...
Day2 := Day1; -- Will only work if Day1 has Mon-Fri, fails if Day1 = Sat or Sun
\end{minted}
\end{definition}

The compiler generates range-checking code for every assignment to the subrange type.
Subranges require run-time range checking.

\paragraph{Evaluation}\label{par:Subrange_Types_Evaluation}
\nameref{def:Subrange_Type}s improve \nameref{subsec:Readability} by making it clear that \nameref{def:Variable}s of \nameref{def:Ada_Subtype}s can only store a certain range of values.
\nameref{subsec:Reliability} is increased with \nameref{def:Subrange_Type}s because assigning a value to a subrange variable outside its range is detected as an error.

\subsubsection{Implementation of \nameref*{subsec:User_Defined_Ordinal_Types}}\label{subsubsec:Implementation_User_Defined_Ordinal_Types}
\nameref{def:Enumeration_Type}s are usually implemented on integers.
However, without restrictions on ranges of values and possible operations, this does \textbf{not} improve \nameref{subsec:Reliability}.

\nameref{def:Subrange_Type}s are implemented the same way as their parent types, except range checks are implicity included by the compiler in every assignment of a variable or expression to a subrange variable.

\subsection{List Types}\label{subsec:List_Types}
Lists were first supported in LISP.\@
\begin{definition}[List]\label{def:List}
  A \emph{list} is a data structure heavily used in \nameref{def:Functional_Programming_Language}s.
  They are similar to arrays in other languages, but they may lazily evaluated and may be infinite.

  \begin{remark}
    Lists, because of their (potentially, depends on the language) inherently infinite nature, have always been part of \nameref{def:Functional_Programming_Language}s, but are making their way to \nameref{def:Imperative_Programming_Language}s too.
  \end{remark}
\end{definition}

\begin{remark*}
  \theauthor{} went a little ham on this section because he uses Emacs and writes ELisp to customize it.
  He is also \emph{really} interested in \nameref{def:Functional_Programming_Language}s.
\end{remark*}

Lists in Scheme, LISP, and Common LISP are written as such:
\begin{minted}[frame=lines,linenos]{lisp}
(A B C D) ; List of 4 elements
(A (B C) D) ; List of 3 elements, with the middle being a 2 element nested list
\end{minted}

In LISP and its descendants, data and code have the same syntactic form, meaning this could be interpreted as a function call to \texttt{A} with \texttt{B} and \texttt{C} being parameters; or as a list of 3 elements.
\begin{minted}[frame=lines,linenos]{lisp}
(A B C)
\end{minted}

Lists in Scheme, LISP, and Common LISP can be considered linked-lists with immutable nodes.
This means there are operations to get the current node's data and to get the next nodes in the rest of the list.
\begin{minted}[frame=lines,linenos]{scheme}
; The ' in front of a list means to interpret the list as data and not a function call
(CAR '(A B C)) ; Returns the element A
(CDR '(A B C)) ; Returns the list (B C)
\end{minted}

There are 2 ways these lists can be constructed:
\begin{enumerate}[noitemsep]
\item \texttt{CONS} takes 2 parameters and returns a list with the first parameter as the first element and the second parameter as the remainder of the list.
\begin{minted}[frame=lines,linenos]{common-lisp}
(CONS 'A '(B C)) ; Returns (A B C)
\end{minted}
\item \texttt{LIST} takes any number of parameters and returns a new list with the parameters as the new list's elements
\begin{minted}[frame=lines,linenos]{common-lisp}
(LIST 'A 'B '(C D)) ; Returns (A B (C D))
\end{minted}
\end{enumerate}

The empty list \texttt{()} is also denoted as \texttt{nil}.
\texttt{nil} also serves as the \texttt{false} value of the language, and everything else is \texttt{true}.

\begin{definition}[List Comprehension]\label{def:List_Comprehension}
  A \emph{list comprehension} is an idea from set notation and set theory.
  Essentially, a list comprehension applies a function to every element in a given \nameref{def:Array}/\nameref{def:List}, and a new \nameref{def:Array}/\nameref{def:List} is constructed from the results.

  2 examples of this are shown below, the first in Haskell, the second in Python 3.
\begin{minted}[frame=lines,linenos]{haskell}
[n * n | n <- [1..10]]
\end{minted}
\begin{minted}[frame=lines,linenos]{python3}
[x * x for x in range(1, 11, 1)]
\end{minted}
\end{definition}
\subsection{Arrays}\label{subsec:Arrays}
\begin{definition}[Array]\label{def:Array}
  An \emph{array} is a homogeneous aggregate of data elements in which an individual element is identified by its position in the aggregate, relative to the first element.
  The individual elements of an array are of the same \nameref{def:Data_Type}.
  References to individual array elements are specified using subscript expressions
\end{definition}

\subsubsection{Design Issues}\label{subsubsec:Arrays-Design_Issues}
\begin{itemize}[noitemsep]
\item What types are legal for subscripts?
\item Are subscripting expressions in element references range checked?
\item When are subscript ranges bound?
\item When does array allocation take place?
\item Are jagged and/or rectangular multidimensional arrays allowed, or both?
\item Can arrays be initialized when they have their storage allocated?
\item What king of slices are allowed, if any?
\end{itemize}

\subsubsection{Arrays and Indices}\label{subsubsec:Arrays-Arrays_and_Indices}
Specific elements in an array are referenced by means of the name of the aggregate and a dynamic selector, known as \emph{subscript}s or \emph{indices}.
If all of the subscripts used are constants, the selector is static; otherwise, it is dynamic.
Arrays are sometimes called \emph{finite mapping}s, because they map \nameref{def:Memory} cells to values, with a finite length.

Most languages use brackets, \texttt{[} and \texttt{]}, to denote the array indices.
However, some languages use parentheses.

The type of the subscripts are usually integers, but Ada also allows any \nameref{def:Ordinal_Type} to be used as a subscript.
Some languages check the bounds of the array accesses through subscripts, though some don't.
Some languages allow the index to be a negative integer, in which case, it is the index of that element starting from the end as 0.

\subsubsection{Subscript Bindings}\label{subsubsec:Arrays-Subscript_Bindings}
The binding of the subscript type to an \nameref{def:Array} variable is usually static, but the value ranges are sometimes dynamic.
Some languages have an implicit lower bound on the subscript range, usually 0.
However, some languages allow for negative subscripting, which starts their indexing from the end of the \nameref{def:Array}

\subsubsection{Array Categories}\label{subsubsec:Arrays-Categories}
There are 5 categories of arrays, based on the binding to subscript ranges, the binding to storage, and from where the storage is allocated.
\begin{enumerate}[noitemsep]
\item \nameref{def:Static_Array}
\item \nameref{def:Fixed_Stack_Dynamic_Array}
\item \nameref{def:Stack_Dynamic_Array}
\item \nameref{def:Fixed_Heap_Dynamic_Array}
\item \nameref{def:Heap_Dynamic_Array}
\end{enumerate}

\begin{definition}[Static Array]\label{def:Static_Array}
  A \emph{static array} is one in which the subscript ranges are statically bound and the storage allocation is static.
  Meaning the entire array, other than the values it contains are created before runtime.

  The advantages and disadvantages of this are:
  \begin{itemize}[nosep,noitemsep]
  \item Advantages
    \begin{itemize}[nosep,noitemsep]
    \item Efficiency, there is no dynamic allocation or deallocation overhead required.
    \end{itemize}
  \item Disadvantages
    \begin{itemize}[nosep,noitemsep]
    \item Flexibility, the storage for the array is fixed for the entire execution of the program.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{definition}[Fixed Stack-Dynamic Array]\label{def:Fixed_Stack_Dynamic_Array}
  In a \emph{fixed stack-dynamic array}, the subscript ranges are statically bound, but the storage allocation is done at declaration elaboration time during runtime.

  The advantages and disadvantages of this are:
  \begin{itemize}[nosep,noitemsep]
  \item Advantages
    \begin{itemize}[nosep,noitemsep]
    \item If 2 subprograms both have large arrays, they can use the same space, so long as only a single one is running at a time.
    \end{itemize}
  \item Disadvantages
    \begin{itemize}[nosep,noitemsep]
    \item The time required to allocate and deallocate the array.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{definition}[Stack-Dynamic Array]\label{def:Stack_Dynamic_Array}
  In a \emph{stack-dynamic array}, the subscript ranges and storage allocation are done during declaration elaboration time during program execution.
  However, once the subscript ranges are bound and the storage allocatec, they are both fixed throughout the lifetime of the array.

  The advantages and disadvantages of this are:
  \begin{itemize}[nosep,noitemsep]
  \item Advantages
    \begin{itemize}[nosep,noitemsep]
    \item Flexibility, the size of the array doesn't need to be known until just before the array is used.
    \end{itemize}
  \item Disadvantages
    \begin{itemize}[nosep,noitemsep]
    \item The time required to allocate and deallocate the array.
    \item Determine the subscript ranges and bind them.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{definition}[Fixed Heap-Dynamic Array]\label{def:Fixed_Heap_Dynamic_Array}
  A \emph{fixed heap-dynamic array} is similar to a \nameref{def:Fixed_Stack_Dynamic_Array}, in that subscript ranges and storage binding are done on demand at runtime, and are fixed throughout the array's lifetime.
  However, the storage is allocated from the heap instead of the stack.

  The advantages and disadvantages of this are:
  \begin{itemize}[nosep,noitemsep]
  \item Advantages
    \begin{itemize}[nosep,noitemsep]
    \item Flexibility, the array can be any size to fit any problem.
    \end{itemize}
  \item Disadvantages
    \begin{itemize}[nosep,noitemsep]
    \item The allocation and deallocation time is much longer on the heap compared to the stack.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{definition}[Heap-Dynamic Array]\label{def:Heap_Dynamic_Array}
  A \emph{heap-dynamic array} is one in which the binding of subscript ranges and storage allocation is done during program execution, \textbf{and can change any number of times during the array's lifetime}.

  The advantages and disadvantages of this are:
  \begin{itemize}[nosep,noitemsep]
  \item Advantages
    \begin{itemize}[nosep,noitemsep]
    \item Flexibility, arrays can grow and shrink during program execution to fit the needs of the problem.
    \end{itemize}
  \item Disadvantages
    \begin{itemize}[nosep,noitemsep]
    \item Allocation and deallocation take longer on the heap.
    \item Allocation and deallocation may happen several times during a program's execution.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{definition}[Length]\label{def:Array-Length}
  The \emph{length} of an \nameref{def:Array} is defined to be the number of storage elements present in it.
  This means that a list that is declared to have 10 elements, but none assigned, has a length of 10.

  \begin{remark}[The Empty Array]\label{rmk:Array-Length-Empty_Array}
    \emph{The empty array} is defined to have a length of 0.
  \end{remark}
\end{definition}

\begin{definition}[Sparse]\label{def:Array-Sparse}
  If an array is \emph{sparse}, it means that not all elements present in an array are filled with user-input data.
  For example, if you have an array with \nameref{def:Array-Length} 10 in JavaScript, you can add an element to position 50, to create an array that now has \nameref{def:Array-Length} 51, with only 11 elements.
\end{definition}

\subsubsection{Array Initialization}\label{subsubsec:Arrays-Initialization}
Some languages allow the programmer to initialize the \nameref{def:Array} with values when the storage is allocated.
\begin{minted}[frame=lines,linenos]{fortran}
Integer, Dimension (3) :: List = (/0, 5, 5/)
\end{minted}
However, C/C++, Java, and C\# do not allow programmer-specification length of an \nameref{def:Array} during declaration/initialization.
\begin{minted}[frame=lines,linenos]{c}
int list [] = {4, 5, 7, 83};
\end{minted}

In C and C++, a \nameref{def:Character_String_Type} or string, is a character array with the last element being a null terminator ASCII \texttt{00}.

Ada allows for initialization to specific indices in an array during storage allocation.
\begin{minted}[frame=lines,linenos]{ada}
List : array (1..5) of Integer := (1, 4, 5, 7 ,9);
Bunch : array (1..5) of Integer := (1 => 17, 3 => 34, others => 0);
\end{minted}
Because of this feature, the \texttt{others} clause initializes all other elements with a ``default'' value.

\subsubsection{Array Operations}\label{subsubsec:Arrays-Operations}
\begin{definition}[Array Operation]\label{def:Array_Operation}
  An \emph{array operation} is one that operates on an \nameref{def:Array} as a whole.
  The most common operations are:
  \begin{itemize}[noitemsep]
  \item Assignment
  \item Concatenation
  \item Comparison for Equality
  \item \nameref{subsubsec:Arrays-Slices}
  \end{itemize}
\end{definition}

Some programming languages offer built-in support for these common operations, but some don't.
There is also no standard set of symbols used to perform these operations.

\subsubsection{Rectangular and Jagged Arrays}\label{subsubsec:Arrays-Rectangular_Jagged}
\begin{definition}[Rectangular Array]\label{def:Array-Rectangular}
  A \emph{rectangular \nameref{def:Array}} is an multidimensional \nameref{def:Array} in which all of the rows have the same number of elements, and all the columns have the same number of elements.
  Rectangular \nameref{def:Array}s model rectangular tables and square matrices exactly.
\end{definition}

\begin{definition}[Jagged Array]\label{def:Array-Jagged}
  A \emph{jagged \nameref{def:Array}} is a multidimensional \nameref{def:Array} in which the lengths of the rows do not need to be the same.
  This applies to all \nameref{def:Array}s in higher dimensions as well.
  These are made possible with having an array, where each element is itself, an \nameref{def:Array}.
\end{definition}

\subsubsection{Slices}\label{subsubsec:Arrays-Slices}
\begin{definition}[Slice]\label{def:Slice}
  A \emph{slice} of an \nameref{def:Array} is some substructure of that \nameref{def:Array}.
  A slice is \textbf{not} a new \nameref{def:Data_Type}, rather, it a mechanism for addressing a portion of an \nameref{def:Array} as a single unit.
\end{definition}

\subsubsection{Evaluation}\label{subsubsec:Arrays-Evaluation}
\subsubsection{Implementation of Array Types}\label{subsubsec:Arrays-Implementation}

\subsection{Associative Arrays}\label{subsec:Associative_Arrays}
\begin{definition}[Associative Array]\label{def:Associative_Array}
  An \emph{associative array} is an unordered collection of data elements that are indexed by an equal number of values, called \emph{keys}.
  The user-defined keys must be stored in the structure, along with the values to be stored.

  To store the keys, they must be \emph{hashed}.
  This is done with a hash function.

  \begin{remark}[Alternative Names]
    There are many alternative names for \nameref{def:Associative_Array}s.
    \begin{itemize}[noitemsep]
    \item Hashtable
    \item Hashmap
    \item \nameref{def:Associative_Array}
    \item Dictionary
    \end{itemize}
  \end{remark}

  \begin{remark}[Improving Capabilities]
    What the associative array/dictionary/hashtable are allowed to store depends on the language.
    In Python and Ruby, objects and \nameref{def:Primitive_Data_Type}s can be stored.
    In PHP, integers or strings can be keys.
    In Ruby, any object can be a key.
  \end{remark}
\end{definition}

\subsubsection{Structure and Operations}\label{subsubsec:Structure_and_Ops_Associative_Arrays}
The code examples here are done in Perl, but it is similar in most other languages.
For more specific code, you will have to visit the language's documentation.
\begin{minted}[frame=lines,linenos]{perl}
# Defining an associative array
%salaries = ("Gary" => 75000, "Perry" => 57000, "Mary" => 55750);

# Switch from % for hash to $ for single values in the hash
# That should be a dollar sign, not a Stirling Pound symbol

# Changing a value in the associative array
$salaries{"Perry"} = 58850;

# Removing a key-value pair from the associative array
delete $salaries{"Gary"};
\end{minted}

The size of a Perl \nameref{def:Associative_Array} is dynamic and will grow and shrink as needed.

\nameref{def:Associative_Array}s are very useful if there is a lot of searching that needs to be done, because the hashing of the key, then the search term allows for $O(1)$ lookup speeds for an element located anywhere in the \nameref{def:Associative_Array}.

\subsubsection{Implementing \nameref*{subsec:Associative_Arrays}}\label{subsubsec:Implementing_Associative_Arrays}
The implementation for an \nameref{def:Associative_Array} differs between languages.
However, in all languages, eventually the \nameref{def:Associative_Array} can get ``full''.
This is when the collision chance of 2 hashes modulo the length of the structure gets too high.
This means that if an element is already stored, and something new were hashed and modulo-d the length of the structure, there is a very high probability that the new element would ``collide'' with the old one.

To handle this, \nameref{def:Associative_Array}s are grown.
Every key-value pair will need to have their key recalculated.
This is a slightly time-costly operation, $O(n)$, but the spatial-cost is much higher, because there are 2 potentially very large arrays in memory at the same time.

\subsection{Record Types}\label{subsec:Record_Data_Types}
\begin{definition}[Record]\label{def:Record_Data_Type}
  A \emph{record} is an aggregate of data elements in which the individual elements are identified by names and accessed through offsets from the beginning of the structure, similar to arrays.
  The offset from the head of the record to reach any \nameref{def:Record_Data_Type_Field} is known statically, because the sizes and \nameref{def:Variable_Type}s are known at compile time.

  Records are used to model a collection of data in which the individual elements, the \nameref{def:Record_Data_Type_Field}s are not of the same \nameref{def:Variable_Type} or size.

  \begin{remark}[Clarification]
    An important clarification here is that the \nameref{def:Record_Data_Type}, defined in \Cref{def:Record_Data_Type} is \textbf{NOT} a record in a database \textbf{in any way}.
  \end{remark}

  \begin{remark}
    A \nameref{def:Record_Data_Type} is similar to a heterogeneous array, but they differ in one key way.
    A heterogeneous array is an array of pointers to areas of \nameref{def:Memory} that may be discontinuous.
    However, all the \nameref{def:Record_Data_Type_Field}s in a \nameref{def:Record_Data_Type} all reside in adjacent \nameref{def:Memory} locations.
  \end{remark}

  \begin{remark}[\nameref*{def:Record_Data_Type} vs. Object]
    A \nameref{def:Record_Data_Type} and an object are quite similar.
    However, the differences between them depend on the language.
  \end{remark}
\end{definition}

\begin{definition}[Field]\label{def:Record_Data_Type_Field}
  A \emph{field} is an element a \nameref{def:Record_Data_Type}.
  These are fixed length, with fixed \nameref{def:Variable_Type}, meaning the \nameref{def:Memory} address can be statically calculated to reach any \nameref{def:Record_Data_Type_Field} in the \nameref{def:Record_Data_Type}.

  Fields are referenced by their identifier, rather than an index.
\end{definition}

\subsubsection{Definitions of \nameref*{def:Record_Data_Type}s}\label{subsubsec:Definitions_of_Records}
There are 2 design questions that need to be asked when defining \nameref{def:Record_Data_Type}s.
\begin{enumerate}[noitemsep]
\item What is the syntactic form of references to \nameref{def:Record_Data_Type_Field}s?
\item Are elliptical references allowed?
\end{enumerate}

Below are 2 blocks of code, the first from COBOL, the second from Ada.
Both describe an employee.

\begin{minted}[frame=lines,linenos]{cobol}
01  EMPLOYEE-RECORD.
    02 EMPLOYEE-NAME.
       05 FIRST      PICTURE IS X(20).
       05 MIDDLE     PICTURE IS X(20).
       05 LAST       PICTURE IS X(20).
    02 HOURLY-RATE   PICTURE IS 99V99.
\end{minted}
The numbers \texttt{01}, \texttt{02}, and \texttt{05} are \emph{level numbers}, which indicate relative hierarchical values.
Any line that is followed by a line with a higher-level number is itself a record.
\texttt{PICTURE} clauses show the formats of the storage locations.
\texttt{X(20)} is a 20 character alphanumeric string and \texttt{99V99} is a 4 decimal digit number with the dcimal in the middle.

However, Ada does not have the level numbers like COBOL, so they allow for nesting \nameref{def:Record_Data_Type} structures inside \nameref{def:Record_Data_Type} declarations.
\begin{minted}[frame=lines,linenos]{ada}
type Employee_Name_Type is record
   First : String (1..20);
   Middle : String (1..20);
   Last : String (1..20);
end record;
type Employee_Record_Type is record   Employee_Name: Employee_Name_Type;
   Hourly_Rate: Float;
end record;
Employee_Record: Employee_Record_Type;
\end{minted}

In Java and C\#, \nameref{def:Record_Data_Type}s can be defined as data classes, whith nested \nameref{def:Record_Data_Type}s defined as nested classes.
Lua's tables serve this purpose.

\subsubsection{References to \nameref*{def:Record_Data_Type} \nameref*{def:Record_Data_Type_Field}s}\label{subsubsec:References_to_Record_Fields}
There are many ways to refer to individual \nameref{def:Record_Data_Type_Field}s.
We will look at the way COBOL referenced \nameref{def:Record_Data_Type_Field}s, and the \nameref{def:Record_Data_Type_Field_Access-Dot_Notation}.

\begin{definition}[Dot Notation]\label{def:Record_Data_Type_Field_Access-Dot_Notation}
  Most programming languages use \emph{dot notation} for \nameref{def:Record_Data_Type_Field} references, where components necessary to reach the \nameref{def:Record_Data_Type_Field} are connected with periods.
  The outermost \nameref{def:Record_Data_Type} goes on the left, and gets more specific as it grows to the right.
\end{definition}

There are 2 examples below of accessing the middle name of the Employee \nameref{def:Record_Data_Type}s we made in the previous section.

\begin{minted}[frame=lines,linenos]{cobol}
MIDDLE OF EMPLOYEE-NAME OF EMLOYEE-RECORD
\end{minted}

\begin{minted}[frame=lines,linenos]{ada}
Employee_Record.Employee_Name.Middle;
\end{minted}

There are 2 ways to make a reference to a \nameref{def:Record_Data_Type} \nameref{def:Record_Data_Type_Field}.
\begin{enumerate}[noitemsep]
\item \nameref{def:Fully_Qualified_Reference}s
\item \nameref{def:Elliptical_Reference}s
\end{enumerate}

\begin{definition}[Fully Qualified Reference]\label{def:Fully_Qualified_Reference}
  A \emph{fully qualified reference} to a record field is one in which to access a \nameref{def:Record_Data_Type_Field}, the programmer \textbf{MUST} specify all intermediate \nameref{def:Record_Data_Type}s to go through.

  An alternative to fully qualified reference is the \nameref{def:Elliptical_Reference}.
\end{definition}

\begin{definition}[Elliptical Reference]\label{def:Elliptical_Reference}
  An \emph{elliptical reference} allows a programmer to specify the \nameref{def:Record_Data_Type_Field} and omit any to all parent \nameref{def:Record_Data_Type}s; so long as the resulting reference in unambiguous in the referencing environment (the \nameref{def:Variable_Scope}).

  These are a programmer convenience, but are \textbf{incredibly} difficult to compile, because of the alaborate data structures and procedures required to correctly identify the referenced field.
  There is also a slight loss of \nameref{subsec:Readability}.
\end{definition}

\subsubsection{Evaluation of \nameref*{subsec:Record_Data_Types}}\label{subsubsec:Evaluation_of_Record_Types}
\nameref{def:Record_Data_Type}s are valuable to programming and programming languages.
Their design is straightforward and use is safe.

\nameref{def:Record_Data_Type}s and \nameref{def:Array}s are quite similar, but differ in some key ways
\begin{itemize}[noitemsep]
\item \nameref{def:Array}s:
  \begin{itemize}[noitemsep]
  \item All data values have the same \nameref{def:Variable_Type}. This allows for easy subscripting of \nameref{def:Memory} addresses
  \end{itemize}
\item \nameref{def:Record_Data_Type}
  \begin{itemize}[noitemsep]
  \item When the collection of data values is heterogeneous
  \item The different data \nameref{def:Record_Data_Type_Field}s are not processes the same way
  \item The \nameref{def:Record_Data_Type_Field}s are not processed in any particular order
  \item \nameref{def:Record_Data_Type_Field}s are like named subscripts
  \item Since \nameref{def:Record_Data_Type_Field} names are static, they provide efficient access to fields.
  \end{itemize}
\end{itemize}

\subsubsection{Implementation of \nameref*{subsec:Record_Data_Types}}\label{subsubsec:Implementation_of_Record_Types}
The \nameref{def:Record_Data_Type_Field}s of \nameref{def:Record_Data_Type}s are stored in adjacent \nameref{def:Memory} locations.
But because each \nameref{def:Record_Data_Type_Field} may be of a different size, the offset address, relative to the beginning of the \nameref{def:Record_Data_Type} is associated with each field.
These are calculated at compile-time.
This way, there are no runtime calculations that need to be done.

\subsection{Tuple Types}\label{subsec:Tuple_Types}
\begin{definition}[Tuple]\label{def:Tuple}
  A \emph{tuple} is a \nameref{def:Variable_Type} that is similar to a \nameref{def:Record_Data_Type}, except the elements are \textbf{not} named.

  \begin{remark}
    \nameref{def:Tuple}s can be used to return multiple values from a function in languages that do not natively support that.
  \end{remark}

  \begin{remark}
    Python natively supports these.
    These behave similarly to \nameref{def:List}s, but are immutable.
  \end{remark}
\end{definition}

\begin{minted}[frame=lines,linenos]{python3}
myTuple = (3, 5.8, 'apple')
\end{minted}

\subsection{Union Types}\label{subsec:Union_Types}
\begin{definition}[Union]\label{def:Union_Type}
  A \emph{union} is a \nameref{def:Data_Type} whose \nameref{def:Variable}s may store different \nameref{def:Variable_Type} \nameref{def:Variable_Value}s at different times during program execution.
  \textbf{However, ONLY ONE value is stored at a time.}

  This means that in a C-program, which uses \nameref{def:Free_Union}s will only hold one thing at a time, and \textbf{based on the field that you call in the union, the program will interpret the bit pattern differently}.
  This site gives a good exposition of this point: \href{https://www.tutorialspoint.com/cprogramming/c_unions.htm}{Greater Exposition}.

  The union will allocate the maximum space required by all the \nameref{def:Variable_Type}s of the union, and only use the parts it needs, based on what \nameref{def:Variable_Type}s are actually in use.
\end{definition}

\subsubsection{Design Issues}\label{subsubsec:Union_Types-Design_Issues}
\begin{itemize}[noitemsep]
\item Should \nameref{def:Type_Checking} be required?
  \begin{itemize}[noitemsep]
  \item This \nameref{def:Type_Checking} will have to be dynamic, running during program execution.
  \end{itemize}
\item Should \nameref{def:Union_Type}s be embedded in \nameref{def:Record_Data_Type}?
\end{itemize}

\subsubsection{Discriminated vs. Free Unions}\label{subsubsec:Union_Types-Discriminated_vs_Free}
The \texttt{union} construct in C/C++ is used to specify \nameref{def:Union_Type} structures.
These are called \nameref{def:Free_Union}s.
These stand in stark contrast to \nameref{def:Discriminated_Union}s.
\begin{definition}[Free Union]\label{def:Free_Union}
  A \emph{free union} is a \nameref{def:Union_Type} that have \textbf{\textit{NO}} \nameref{def:Type_Checking} enforced on their use.
  For example, this C snippet:
\begin{minted}[frame=lines,linenos]{c}
union flexType {
    int intEl;
    float floatEl;.
};
union flexType el1;
float x;
...
el1.intEl = 27;
x = el1.floatEl; // NOT type checked, because current type of el1 cannot be determined
\end{minted}
  The last assignment is not type checked, because the the current \nameref{def:Variable_Type} of \texttt{el1} cannot be checked.
  So, \texttt{27} is assigned to the \texttt{float} variable \texttt{x}, which is nonsense.
\end{definition}

\begin{definition}[Discriminated Union]\label{def:Discriminated_Union}
  A \emph{discriminated union} makes use of a \emph{tag} or \emph{discriminant} as a \nameref{def:Data_Type} indicator.
  These allow for the \nameref{def:Type_Checking} of \nameref{def:Union_Type}s during runtime.
\end{definition}

\subsubsection{Ada \nameref*{subsec:Union_Types}}\label{subsubsec:Ada_Union_Types}
Ada allows the use to specify variables for a variant \nameref{def:Record_Data_Type} that will only store one of the possible \nameref{def:Variable_Type} values in the variant.

\begin{definition}[Constrained Variant Variable]\label{def:Union_Type-Constrained_Variant_Variable}
  A \emph{constrained variant variable} is when a language allows the programmer to specify the types present in a variant \nameref{def:Data_Type}, allowing for static \nameref{def:Type_Checking}.
  These enforce that variants can only be changed by assigning the entire record at a time.

  This is shown in the code snippet below.
\begin{minted}[frame=lines,linenos]{ada}
type Shape is (Circle, Triangle, Rectangle); -- Construct enumeration for types of shapes possible
type Colors is (Red, Green, Blue); -- Construct enumeration for colors
type Figure (Form : Shape) is record -- Figure has variant Form records of type Shape (from enumeration)
    Filled : Boolean;
    Color : Colors;
    case Form is
        when Circle =>
            Diameter : Float;
        when Triangle =>
            Left_Side : Integer;
            Right_Side : Integer;
            Angle : Float;
        when Rectangle =>
            Side_1 : Integer;
            Side_2 : Integer;
    end case
end record;
...
Figure_1 : Figure; -- Unconstrained variant record of the record type Figure, and has no initial values
Figure_2 : Figure(Form => Triangle); -- Constrain the variant record to a Triangle
-- Figure_1's type can be changed by the assignment of a whole record
Figure_1 := (Filled => True,
             Color => Blue,
             Form => Rectangle,
             Side_1 => 12,
             Side_2 => 3);
\end{minted}
\end{definition}

\subsubsection{Evaluation}\label{subsubsec:Union_Types-Evaluation}
\nameref{def:Union_Type}s are potentially unsafe constructs in some languages, because they cannot be type checked.
C and C++ are not strongly typed for this reason.
However, Ada, ML, Haskell, and F\# are strongly typed, because they can perform \nameref{def:Type_Checking} on \nameref{def:Union_Type}s.
Some languages, like Java and C\# do not even include the ability to construct a \nameref{def:Union_Type}.

\subsubsection{Implementation of \nameref*{subsec:Union_Types}}\label{subsubsec:Union_Types-Implementation}
\nameref{def:Union_Type}s are implemented by using the same address for a single \nameref{def:Union_Type}, no matter its variant.
Enough storage is allocated for the largest possible variant.
Then, depending on the variant, the space will be used according to how the \nameref{def:Union_Type} was defined.
The tag of the \nameref{def:Union_Type} variant is stored in its \nameref{def:Descriptor}.

\subsection{Type Equivalence}\label{subsec:Type_Equivalence}
This section does not deal with \nameref{def:Type_Compatibility}, which works for scalar \nameref{def:Data_Type}s, but rather \nameref{def:Type_Equivalence}.
\begin{definition}[Type Compatibility]\label{def:Type_Compatibility}
  \emph{Type compatibility} dictates the \nameref{def:Data_Type} of operands that are acceptable for eacch of the operations of the language.
  This is called compatibility because there are cases when the \nameref{def:Data_Type} of the operand can be implicitly converted by the compiler or run-time system to make the operand acceptable to the operator.

  An example of this is the addition of an integer number and a real number.
  The integer number is typecast to a real number, then the addition is performed.
\end{definition}

\nameref{def:Type_Compatibility} rules are strict for predefined scalar types.
However, structured \nameref{def:Data_Type}s such as \nameref{def:Array}s, \nameref{def:Record_Data_Type}, and others require more complex rules.
Since \nameref{def:Data_Type} coercion is unlikely, the question is if the 2 \nameref{def:Data_Type}s are equivalent.

\begin{definition}[Type Equivalence]\label{def:Type_Equivalence}
  \emph{Type equivalence} is a strict form of \nameref{def:Type_Compatibility}.
  It is when an operand of one \nameref{def:Data_Type} can be substituted for another operand of the same type, without \nameref{def:Data_Type} coercion.

  The design of type equivalence rules influence the design of \nameref{def:Data_Type}s and operations provided for values of those types.

  There are 2 approaches to determining \nameref{def:Type_Equivalence}:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Type_Equivalence-Name}
  \item \nameref{def:Type_Equivalence-Structure}
  \end{enumerate}

  There is a general algorithm for determining if two \nameref{def:Data_Type}s are equivalent.
  ``$\ldots$ when all constant expressions are replaced by their values and all type names are replaced by their definitions.
  In the case of recursive types, the expansion is the infinite limit of the partial expansions $\ldots$''.
  Meaning you replace everything you can, and if there is an infinite recursion somewhere, you cut it off eventually, usually when you pass the same point again.

  There are 4 types of equivalence that can be established.
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Type_Equivalence-Primitive}
  \item \nameref{def:Type_Equivalence-Structure}
  \item \nameref{def:Type_Equivalence-Reference}
  \item \nameref{def:Type_Equivalence-User_Defined}
  \end{enumerate}
\end{definition}

Different languages use different approaches and combinations of these types of \nameref{def:Type_Equivalence}.
You would have to look at the language's specification to find out exactly what is used where.
Additionally, object-oriented languages present their own, unique, type of \nameref{def:Type_Compatibility} with object compatibility and its relationship to the inheritance hierarchy.

\begin{definition}[Name Type Equivalence]\label{def:Type_Equivalence-Name}
  \emph{Name type equivalence} means that 2 \nameref{def:Variable}s have \nameref{def:Type_Equivalence} if they are defined in:
  \begin{itemize}[noitemsep]
  \item The same declaration
  \item In Declarations that use the same \nameref{def:Data_Type} name
  \end{itemize}

  This is easier to implement, but more restrictive.
  In a strict interpretation, a \nameref{def:Variable} whose \nameref{def:Variable_Type} is a subrange of the integers would \textbf{not} be equivalent to an integer \nameref{def:Variable_Type} \nameref{def:Variable}.
  For example,
\begin{minted}[frame=lines,linenos]{ada}
type Indextype is 1..100;
count : Integer;
index : Indextype;
\end{minted}
  \texttt{count} and \texttt{index} could \textbf{not} be substituted for each other.

  \begin{remark}
    To use \nameref{def:Type_Equivalence-Name}, all \nameref{def:Variable_Type}s must have names.
    If the language supports anonymous \nameref{def:Data_Type}s, then they must be given internal names by the compiler/interpreter.
  \end{remark}
\end{definition}

\begin{definition}[Primitive Equivalence]\label{def:Type_Equivalence-Primitive}
  \emph{Primitive equivalence} directly compares two values by comparing their bit patterns in memory.
\end{definition}

\begin{definition}[Structure Type Equivalence]\label{def:Type_Equivalence-Structure}
  \emph{Structure type equivalence} means 2 \nameref{def:Variable}s have \nameref{def:Type_Equivalence} if their types have identical structures.
  The entire structure's \nameref{def:Variable_Type}s must be compared to determine equivalence.
  This may potentially invole recursing through the structure or iterating over the structure.
  However, this is more flexible than \nameref{def:Type_Equivalence-Name}, but more difficult to implement.

  Ada, with its hyper-strict \nameref{def:Type_Equivalence} has defined 2 ways to make new types.
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Derived_Type}
  \item \nameref{def:Subtype}
  \end{enumerate}
\end{definition}

\begin{definition}[Reference Equivalence]\label{def:Type_Equivalence-Reference}
  \emph{Reference Equivalence} checks whether two pointers/references point to the same address in \nameref{def:Memory}.
\end{definition}

\begin{definition}[User-Defined Equivalence]\label{def:Type_Equivalence-User_Defined}
  \emph{User-defined equivalence} performs arbitrary equality checking but isn't provided by the language itself, and must be specified by the programmer.
\end{definition}

\begin{definition}[Derived Type]\label{def:Derived_Type}
  A \emph{derived type} is a new \nameref{def:Data_Type} that is based on some previously defined \nameref{def:Data_Type}, that \textbf{is not equivalent, but may have an identical structure}.
  Derived types inherit all the properties of their parent types.

  Take the following Ada code snippet as an example.
\begin{minted}[frame=lines,linenos]{ada}
type Celsius is new Float;
type Fahrenheit is new Float;
\end{minted}
  These are not equivalent, though they have identical structures.
  They are also not type equivalent to any other \texttt{Float} type.
\end{definition}

\begin{definition}[Subtype]\label{def:Subtype}
  A \emph{subtype} is a possibly range-constrained version of an existing type.
  A subtype \textbf{is equivalent with its parent type}.

  Take the following Ada code snippet as an example.
\begin{minted}[frame=lines,linenos]{ada}
subtype Small_type is Integer range 0..99;
\end{minted}
  The \texttt{Small\textunderscore{}type} is equivalent to the \texttt{Integer} type.
\end{definition}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
