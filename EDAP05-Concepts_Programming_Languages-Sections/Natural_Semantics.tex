\section{Natural Semantics}\label{sec:Natural_Semantics}
Natural semantics assumes that we know the syntax of the language.
We will assume that we have a \nameref{def:CFG_BNF_Form} \nameref{def:Context_Free_Grammar}.
We will also assume that ambiguities have been resolved, somehow.

\begin{definition}[Semantics]\label{def:Semantics}
  \emph{Semantics} is the act of attaching a meaning to a syntactic construct.
  For instance, we know the value of 1 to be 1, but does $\text{one} = 1$?
  We have defined the semantics of $\text{one}$ to be equivalent to the numeral 1.

  We can defined these semantic relationships with \nameref{def:Evaluation_Relation}s.
\end{definition}

\begin{definition}[Evaluation Relation]\label{def:Evaluation_Relation}
  The \emph{evaluation relation} states the relation between a program $p$ and the program's result $v$:
  \begin{equation}\label{eq:Evaluation_Relation}
    p \EvaluatesTo v
  \end{equation}

  This is read as ``$p$ evaluates to $v$''.

  \begin{remark}
    The value of the left-hand side is an arbitrary set of operator(s).
    For instance, if we wanted to specify addition, but using the \texttt{add} operator, then $p$ would look $\mathtt{e_{1} \: add \: e_{2}}$.
    However, on the right-hand side, we \emph{MUST} specify the operation that will take place.
    The right-hand side is a mathematical construction that the reader will understand.
  \end{remark}
\end{definition}

\begin{definition}[Metavariable]\label{def:Metavariable}
  A \emph{metavariable} is a variable in the \nameref{def:Metalanguage}.
  In \Cref{eq:Evaluation_Relation}, $p$ and $v$ are metavariables.
  
  $p$ is a metavariable that can contain any input program, and $v$ is a metavariable that can contain any result that the language might compute.
\end{definition}

\begin{blackbox}
  Throughout this section, we will use this \nameref{def:CFG_BNF_Form} \nameref{def:Context_Free_Grammar}.
  \begin{equation}\label{eq:DivAdd_Grammar}
    \begin{aligned}
      \Nonterminal{expr} &\rightarrow nat \\
      &\vert \Nonterminal{expr} \textcolor{Green4}{\mathtt{+}} \Nonterminal{expr} \\
      &\vert \Nonterminal{expr} \textcolor{Green4}{\mathtt{div}} \Nonterminal{expr} \\
    \end{aligned}
  \end{equation}
\end{blackbox}

Let's start with the programming language specified by the \nameref{def:Context_Free_Grammar} below.
\begin{equation*}
  \Nonterminal{W} \rightarrow \textcolor{Green4}{\mathtt{ett}} \vert \textcolor{Green4}{\text{\texttt{tv\r{a}}}} \vert \textcolor{Green4}{\mathtt{tre}}
\end{equation*}
This allows only 3 programs, each of which is a single word in Swedish.
We can define the semantics (attach meaning) with the following rules:
\begin{align*}
  \textcolor{Green4}{\mathtt{ett}} &\EvaluatesTo 1 & \textcolor{Green4}{\text{\texttt{tv\r{a}}}} &\EvaluatesTo 2 & \textcolor{Green4}{\mathtt{tre}} &\EvaluatesTo 3 \\
\end{align*}

\subsection{Ambiguous Semantics}\label{subsec:Ambiguous_Semantics}
Just like in \nameref{def:Context_Free_Grammar}s, there can be ambiguities in \nameref{def:Semantics} too.
They occur when there is more than 1 specification for a symbol.
For example,
\begin{equation*}
  \Nonterminal{Q} \rightarrow \textcolor{Green4}{\mathtt{eins}} \vert \textcolor{Green4}{\mathtt{zwei}} \vert \textcolor{Green4}{\mathtt{?}}
\end{equation*}
with the \nameref{def:Semantics} below:
\begin{align*}
  \textcolor{Green4}{\mathtt{eins}} &\EvaluatesTo 1 & \textcolor{Green4}{\mathtt{zwei}} &\EvaluatesTo 2 & \textcolor{Green4}{\mathtt{?}} &\EvaluatesTo 0 & \textcolor{Green4}{\mathtt{?}} &\EvaluatesTo 3 \\
\end{align*}

In this course, we are interested in unambiguous \nameref{def:Semantics}.
When language designers design a programming language, they try to avoid these ambiguities.

We can normally check if a set of semantic rules are unambiguous by checking that the left-hand side of each of the \nameref{def:Evaluation_Relation}s does not overlap with another \nameref{def:Evaluation_Relation}.
If there is an overlap, then it \textbf{must} be shown that the same result will be yielded.

\subsection{Conditional Rules}\label{subsec:Conditional_Rules}
When we want a \nameref{def:Metavariable} to only get a value under certain conditions, we have a special notation for that.
For example, say we want $n$ to be a natural number that is used in the grammar of \Cref{eq:DivAdd_Grammar}.
We can write this condition as:
\begin{equation}\label{eq:Conditional_Rules}
  \frac{n \in \NaturalNumbers}{n \EvaluatesTo \mathtt{asNat}(n)}
\end{equation}

The writers of these semantic grammars favor simplicity, so they might omit the \texttt{asNat} function by arguing ``separating between natural numbers and their textual representation is overly pedantic, as long as there is no ambiguity''.
They might write the rule in \Cref{eq:Conditional_Rules} as:
\begin{equation}\label{eq:Conditional_Rules_Simplified}
  \frac{n \in \NaturalNumbers}{n \EvaluatesTo n}
\end{equation}

\subsection{Recursion}\label{subsec:Semantics_Recursion}
If we want to construct the addition in \Cref{eq:DivAdd_Grammar}, then we can write:
\begin{equation}\label{eq:Semantics_Recursion}
  \frac{e_{1} \EvaluatesTo n_{1} \:\: e_{2} \EvaluatesTo n_{2}}{e_{1}+e_{2} \EvaluatesTo n_{1}+n_{2}}
\end{equation}

\subsection{Completeness}\label{subsec:Semantic_Completeness}
A semantic specification is \emph{complete} when all possible cases have been defined, in some way.
For example:
\begin{equation}\label{eq:Incomplete_Semantic_Rule}
  \frac{e_{1} \EvaluatesTo n_{1} \:\: e_{2} \EvaluatesTo n_{2}}{e_{1} \:\textcolor{Green4}{\mathtt{div}}\: e_{2} \EvaluatesTo \Bigl\lfloor \frac{n_{1}}{n_{2}} \Bigr\rfloor}
\end{equation}
This rule ignores the case when $n_{2} = 0$, which means we divide by 0.
In mathematics, this is an undefined operation.

There are 2 ways to solve this problem:
\begin{enumerate}[noitemsep]
\item \textbf{Adding a Meta-Rule:} Add an informal rule that states if the \nameref{def:Semantics} of an operation is not defined, then execution aborts with an error.
  This is a solution, but it allows the language designer to solve corner cases with strange behavior.
  This also prevents any forms of error recovery, harming \nameref{subsec:Reliability}.
\item \textbf{Error Values:} Extend the $\EvaluatesTo$ \nameref{def:Evaluation_Relation} operator so that we can return \emph{error values} along with intended results.
  This may require adding \textbf{MANY} new rules to the language.
\end{enumerate}

\begin{example}[Lecture 3]{Natural Semantics}
  For the given \nameref{def:Context_Free_Grammar}, construct rules for the Natural~\nameref{def:Semantics} of this language?
  Then, perform a proof/derivation using those rules for the statement $\max (1+2) (1+1)$?
  Ignore the parentheses; those are only used to show that the 2 expressions are separate.
  Assume there is a process before applying the \nameref{def:Context_Free_Grammar} which handles the parentheses.
  \begin{align*}
    \Nonterminal{expr} &\longrightarrow \textcolor{Green4}{\underline{\mathtt{num}}} \\
                       &\vert \Nonterminal{expr} \textcolor{Green4}{+} \Nonterminal{expr} \\
                       &\vert \, \textcolor{Green4}{\mathtt{\max}} \Nonterminal{expr} \Nonterminal{expr}
  \end{align*}
  \tcblower{}
  \textbf{NOTE}: Green will represent input to the rule and blue will represent rule output.
  When deriving statements with these rules, there may be additional colors to represent various values.

  The easiest rule to define is the rule for \textcolor{Green4}{\underline{\texttt{num}}}.
  \begin{equation*}
    \frac{\textcolor{Green4}{n} \in \textcolor{Green4}{\underline{\mathtt{num}}}}{\textcolor{Green4}{n} \EvaluatesTo \textcolor{Blue4}{n}} \textcolor{red}{(num)}
  \end{equation*}

  Next, we define the rule for the addition.
  \begin{equation*}
    \frac{\textcolor{Orange3}{e_{1}} \in \Nonterminal{expr} \: \textcolor{Orange3}{e_{2}} \in \Nonterminal{expr} \: \textcolor{Orange3}{e_{1}} \EvaluatesTo \textcolor{Blue4}{n_{1}} \: \textcolor{Orange3}{e_{2}} \EvaluatesTo \textcolor{Blue4}{n_{2}}}{\textcolor{Orange3}{e_{1}} \textcolor{Green4}{\mathtt{+}} \textcolor{Orange3}{e_{2}} \EvaluatesTo \textcolor{Blue4}{n_{1} + n_{2}}} \textcolor{red}{(add)}
  \end{equation*}
  \begin{remark*}
    In this case, the expression's rule actually returns the computed number from the expression $n_{1} + n_{2}$, rather than the 2 expressions added together (which would be had if we had written $e_{1} + e_{2}$ instead).
  \end{remark*}

  \begin{remark*}
    From here on out, if there is $e_{x} \EvaluatesTo n_{x}$, then we also implicitly say $e_{x} \in \Nonterminal{expr}$.
  \end{remark*}

  Now we have to define the \texttt{max} operation.
  In this case, we need 2 rules to specify the 2 cases, when the left expression is the relative maximum, and when the right expression is the relative maximum.
  \begin{equation*}
    \frac{e_{1} \EvaluatesTo \textcolor{Blue4}{n_{1}} \: e_{2} \EvaluatesTo \textcolor{Blue4}{n_{2}} \: \textcolor{Blue4}{n_{1}} \geq \textcolor{Blue4}{n_{2}}}{\textcolor{Green4}{\mathtt{\max}} \: e_{1} \; e_{2} \EvaluatesTo \textcolor{Blue4}{n_{1}}} \textcolor{red}{(\text{max left})}
  \end{equation*}
  \begin{equation*}
    \frac{e_{1} \EvaluatesTo \textcolor{Blue4}{n_{1}} \: e_{2} \EvaluatesTo \textcolor{Blue4}{n_{2}} \: \textcolor{Blue4}{n_{1}} \leq \textcolor{Blue4}{n_{2}}}{\textcolor{Green4}{\mathtt{\max}} \: e_{1} \; e_{2} \EvaluatesTo \textcolor{Blue4}{n_{2}}} \textcolor{red}{(\text{max right})}
  \end{equation*}
  \begin{remark*}
    Although the 2 equations for determining the relative maxima both have an equality aspect, in pure mathematics, that's fine.
    In mathematical terms, if both rules apply, because $e_{1} == e_{2}$, then, both are technically maxima and should be returned.

    However, this will change during implementation, because one of the rules will be checked first, which necessitates that the rules be made mutually exclusive.
  \end{remark*}

  Now that all the necessary rules have been developed, we can apply them to the statement $\max (1+2) (1+1)$.
  \begin{equation*}
    % Derivation of max started
    \dfrac{
      % Expression 1 derivation
      \dfrac{
        % Expression 1 Left number Derivation
        \dfrac{\textcolor{Green4}{1} \in \NaturalNumbers}{\textcolor{Green4}{1} \EvaluatesTo \textcolor{Purple2}{n_{1} = 1}} \textcolor{red}{(num)} \:\:
        % Expression 1 Right number derivation
        \dfrac{\textcolor{Green4}{2} \in \NaturalNumbers}{\textcolor{Green4}{2} \EvaluatesTo \textcolor{Purple2}{n_{2} = 2}} \textcolor{red}{(num)}}
      % Expression 1 bottom of derivation
      {\textcolor{Orange3}{e_{1}} = \textcolor{Green4}{1+2} \EvaluatesTo \textcolor{Burlywood4}{n_{1}} = \textcolor{Purple2}{n_{1}} + \textcolor{Purple2}{n_{2}} = \textcolor{Purple2}{1}+\textcolor{Purple2}{2}=\textcolor{Burlywood4}{3}} \textcolor{red}{(add)} \:\:
      % Expression 2 derivation
      \dfrac{
        % Expression 2 Left number Derivation
        \dfrac{\textcolor{Green4}{1} \in \NaturalNumbers}{\textcolor{Green4}{1} \EvaluatesTo \textcolor{Purple2}{n_{1} = 1}} \textcolor{red}{(num)} \:\:
        % Expression 2 Right number derivation
        \dfrac{\textcolor{Green4}{1} \in \NaturalNumbers}{\textcolor{Green4}{1} \EvaluatesTo \textcolor{Purple2}{n_{2} = 1}} \textcolor{red}{(num)}}
      % Expression 2 bottom of derivation
      {\textcolor{Orange3}{e_{2}} = \textcolor{Green4}{1+1} \EvaluatesTo \textcolor{Burlywood4}{n_{2}} = \textcolor{Purple2}{n_{1}} + \textcolor{Purple2}{n_{2}} = \textcolor{Purple2}{1}+\textcolor{Purple2}{1} = \textcolor{Burlywood4}{2}} \textcolor{red}{(add)} \:\:
      % Checking n1 geq n2
      \textcolor{Burlywood4}{n_{1}} \geq \textcolor{Burlywood4}{n_{2}} = \textcolor{Burlywood4}{3} \geq \textcolor{Burlywood4}{2}}
    % Bottom of the max rule derivation
    {\textcolor{Green4}{\mathtt{\max}} \textcolor{Orange3}{\underbrace{(\textcolor{Green4}{1+2}\textcolor{Orange3}{)}}_{\textcolor{Orange3}{e_{1}}}} \textcolor{Orange3}{\underbrace{\textcolor{Orange3}{(\textcolor{Green4}{1+1}\textcolor{Orange3}{)}}}_{\textcolor{Orange3}{e_{2}}}} \EvaluatesTo \textcolor{Burlywood4}{n_{1}} = \textcolor{Blue4}{3}} \textcolor{red}{(\text{max left})}
  \end{equation*}

  We chose the \textcolor{red}{max left} rule only \textbf{after} the values of $\textcolor{Orange3}{e_{1}}$ and $\textcolor{Orange3}{e_{2}}$ were calculated.
\end{example}

\subsection{Language with Variables}\label{subsec:Language_with_Variables}
For this section, we are going to use \Cref{eq:LetAdd_Grammar} as our \nameref{def:Context_Free_Grammar}.
\begin{blackbox}
  \begin{equation}\label{eq:LetAdd_Grammar}
    \begin{aligned}
      \Nonterminal{expr} &\rightarrow nat \\
      &\vert id \\
      &\vert \Nonterminal{expr} \textcolor{Green4}{\mathtt{+}} \Nonterminal{expr} \\
      &\vert \textcolor{Green4}{\mathtt{let}}\: id = \Nonterminal{expr} \textcolor{Green4}{\mathtt{in}} \Nonterminal{expr} \\
    \end{aligned}
  \end{equation}
\end{blackbox}

\subsubsection{Environments}\label{subsubsec:Semantic_Environments}
\begin{definition}[Environment]\label{def:Semantic_Environment}
  An \emph{environment} is a mathematical object that tells us the bindings of variables.
  We will use the following notation:
  \begin{equation}\label{eq:Environment}
    E_{n} = \lbrace \textcolor{Green4}{\mathtt{v_{1}}} \mapsto m_{1}, \textcolor{Green4}{\mathtt{v_{2}}} \mapsto m_{2} \rbrace
  \end{equation}
  where $v$ is a variable, and $n$ is the number of variables present.
  So, for example:
  \begin{equation*}
    E_{2} = \lbrace \textcolor{Green4}{\mathtt{a}} \mapsto 1, \textcolor{Green4}{\mathtt{b}} \mapsto 7 \rbrace
  \end{equation*}

  \begin{remark}[Empty \nameref*{def:Semantic_Environment}]\label{rmk:Empty_Environment}
    The \emph{empty environment} is written
    \begin{equation}\label{eq:Empty_Environment}
      E_{\emptyset} = \lbrace \rbrace
    \end{equation}
  \end{remark}
\end{definition}

To retrieve an value from an \nameref{def:Semantic_Environment}, where the \nameref{def:Semantic_Environment} being used is \Cref{eq:Environment}, we write:
\begin{equation}\label{eq:Semantic_Environment_Get_Variable}
  E(\textcolor{Green4}{\mathtt{a}}) \Rightarrow 1
\end{equation}

If we want to update an \nameref{def:Semantic_Environment} with a new binding,
\begin{subequations}\label{eq:Update_Environment}
  \begin{equation}\label{subeq:Update_Environment_New_Variable}
    E_{2} [\textcolor{Green4}{\mathtt{c}} \mapsto 42] = \lbrace \textcolor{Green4}{\mathtt{a}} \mapsto 1, \textcolor{Green4}{\mathtt{b}} \mapsto 7, \textcolor{Green4}{\mathtt{c}} \mapsto 42 \rbrace
  \end{equation}
  \begin{equation}\label{subeq:Update_Environment_Update_Variable}
    E_{2} [\textcolor{Green4}{\mathtt{a}} \mapsto 0] = \lbrace \textcolor{Green4}{\mathtt{a}} \mapsto 0, \textcolor{Green4}{\mathtt{b}} \mapsto 7\rbrace
  \end{equation}
\end{subequations}

We define this as:
\begin{equation}\label{eq:Update_Environment_Definition}
  E[x \mapsto v](y) =
  \begin{cases}
    v & \Longleftrightarrow x=y \\
    E(y) & \text{otherwise}
  \end{cases}
\end{equation}
This means that if $x=y$, then $x$ is remapped (updated) to the value $v$.

\subsubsection{Defining \nameref*{def:Semantics} with Environments}\label{subsubsec:Define_Semantics_with_Environments}
\nameref{def:Semantic_Environment}s, $E$, can now become parameters to our \nameref{def:Evaluation_Relation}s, $\EvaluatesTo$.
This is written
\begin{equation}\label{eq:Define_Semantics_with_Environments}
  E \vdash p \EvaluatesTo n
\end{equation}
Which means $p$ can be drawn from the environment $E$, and should evaluate to a number, $n$ ($n$ is defined elsewhere).

\begin{example}[Lecture 3]{Natural Semantics with Environments}
  Given the \nameref{def:Context_Free_Grammar},
  \begin{align*}
    \Nonterminal{expr} &\longrightarrow \textcolor{Green4}{\underline{\mathtt{num}}} \\
                       &\vert \Nonterminal{expr} \textcolor{Green4}{+} \Nonterminal{expr} \\
                       &\vert \, \textcolor{Green4}{\mathtt{\max}} \Nonterminal{expr} \Nonterminal{expr} \\
                       &\vert \, \textcolor{Green4}{\text{\texttt{let \underline{id}}} = } \Nonterminal{expr} \textcolor{Green4}{\mathtt{in}} \Nonterminal{expr} \\
                       &\vert \, \textcolor{Green4}{\mathtt{\underline{id}}}
  \end{align*}
  Compute the result of $\text{\texttt{let }} \mathtt{x = 2} \text{\texttt{ in }} \mathtt{x+3}$?
  \tcblower{}
  We will start by using the rules that we defined in \Cref{ex:Natural Semantics}.
  We will also need to add new semantic rules for \textcolor{Green4}{\texttt{id}} and the \texttt{let} statement.

  \begin{equation*}
    \frac{\textcolor{Green4}{i} \in \textcolor{Green4}{\mathtt{\underline{id}}}}{E \vdash \textcolor{Green4}{i} \EvaluatesTo E(\textcolor{Green4}{i})} \textcolor{red}{(id)}
  \end{equation*}
  \begin{equation*}
    \frac{E \vdash e_{1} \EvaluatesTo \textcolor{Blue4}{n_{1}} \:\: E[\textcolor{Green4}{i} \mapsto \textcolor{Blue4}{n_{1}}] \vdash e_{1} \EvaluatesTo e_{2}}{E \vdash \textcolor{Green4}{\text{\texttt{let }}\mathtt{i =}} \; e_{1} \; \textcolor{Green4}{\mathtt{\text{in}}} \; e_{2} \EvaluatesTo \textcolor{Blue4}{n_{2}}} \textcolor{red}{(let)}
  \end{equation*}

  We start by applying the most applicable rule, the \textcolor{red}{(let)} rule.
  \begin{equation*}
    \dfrac{
      % The number used in the let-assignment
      \dfrac{\textcolor{Green4}{2} \in \NaturalNumbers}{E_{\emptyset} \vdash \textcolor{Green4}{2} \EvaluatesTo \textcolor{Blue4}{2}} \textcolor{red}{(num)} \:\:
      % The addition operation inside the in-block
      \dfrac{
        % The dereferencing of the ID and grabbing the value mapped to the variable
        \dfrac{\textcolor{Green4}{\mathtt{x}} \in \textcolor{Green4}{\mathtt{\underline{id}}}}
        % The bottom of the dereferencing of the ID
        {E_{\emptyset} [\textcolor{Green4}{\mathtt{x}} \mapsto \textcolor{Blue4}{2}] \vdash \textcolor{Green4}{\mathtt{x}} \EvaluatesTo E(\textcolor{Green4}{\mathtt{x}}) \Rightarrow \textcolor{Orange3}{2}} \textcolor{red}{(id)} \:\:
        % The number, 3, added with x in the in-block
        \dfrac{\textcolor{Green4}{3} \in \NaturalNumbers}
        % The bottom of the num derivation
        {E_{\emptyset} [\textcolor{Green4}{\mathtt{x}} \mapsto \textcolor{Blue4}{2}] \vdash \textcolor{Green4}{3} \EvaluatesTo \textcolor{Orange3}{3}} \textcolor{red}{(num)}}
      % Bottom of the addition derivation
      {E_{\emptyset}[\textcolor{Green4}{\mathtt{x}} \mapsto \textcolor{Blue4}{2}] \vdash \textcolor{Green4}{\mathtt{x+3}} \EvaluatesTo \textcolor{Orange3}{2+3} = \textcolor{Burlywood4}{5}} \textcolor{red}{(add)}}
    % Bottom portion of let expression
    {E_{\emptyset} \vdash \textcolor{Green4}{\text{\texttt{let }}} \mathtt{\textcolor{Green4}{x=}\,2} \textcolor{Green4}{\text{\texttt{ in }}} \mathtt{x+3} \EvaluatesTo \textcolor{Burlywood4}{5}} \textcolor{red}{(let)}
  \end{equation*}

  Once we've applied the \textcolor{red}{(let)} rule, we apply the \textcolor{red}{(num)} rule, because the expression being assigned is just a number.
  The result of that expression evaluation is piped into the next \textcolor{red}{(add)} derivation.
  From there, it is mapped to the input \textcolor{Green4}{\texttt{x}}, and the \texttt{x+3} is calculated.
  The first thing is to get the value of \textcolor{Green4}{\texttt{x}} from the mapping with the \textcolor{red}{(id)} rule.
  Once the $E(\textcolor{Green4}{\mathtt{x}})$ returns the value of the variable \textcolor{Green4}{\texttt{x}}, we can use it.
  The other operand in the addition is found using the \textcolor{red}{(num)} rule.
  Then the addition occurs, and the derivation completes.
\end{example}
  
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
