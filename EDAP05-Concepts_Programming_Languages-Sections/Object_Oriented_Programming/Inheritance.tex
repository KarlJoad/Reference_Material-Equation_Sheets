\subsection{Inheritance}\label{subsec:OOP_Inheritance}
The use of \nameref{def:OOP_Inheritance} allows for \nameref{def:Abstract_Data_Type}s to be reused between pieces of software.
This, in turn, means code is reused, but some of it must be specialized.
Additionally, some of the underlying problem has categories of objects that are related, both as siblings (similar to each other) and as parents and children (having a descendant relationship).

\begin{definition}[Class]\label{def:OOP_Class}
  A \emph{class} is the \nameref{def:Abstract_Data_Type} of \nameref{def:Object_Oriented_Programming} languages.
  They are the building blocks of the programming paradigm.

  Classes have 2 kinds of \nameref{def:Variable}s:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:OOP_Class_Variable}
  \item \nameref{def:OOP_Instance_Variable}
  \end{enumerate}

  They also have 2 kinds of \nameref{def:OOP_Method}s:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:OOP_Class_Method}
  \item \nameref{def:OOP_Instance_Method}
  \end{enumerate}
\end{definition}

\begin{definition}[Object]\label{def:OOP_Object}
  An \emph{object} in an \nameref{def:Object_Oriented_Programming} setting is an instance of a \nameref{def:OOP_Class}.
\end{definition}

\begin{definition}[Subclass]\label{def:OOP_Subclass}
  A \nameref{def:OOP_Class} that is derived from another \nameref{def:OOP_Class} is called a \emph{subclass} or \emph{derived class}.
\end{definition}

\begin{definition}[Superclass]\label{def:OOP_Superclass}
  A \nameref{def:OOP_Class} from which other \nameref{def:OOP_Class}es are derived is called a \emph{superclass}, or \emph{parent class}.
\end{definition}

A \nameref{def:OOP_Subclass} can differ from its \nameref{def:OOP_Superclass} in several ways.
\begin{enumerate}[noitemsep]
\item The \nameref{def:OOP_Superclass} can define some of its \nameref{def:Variable}s or \nameref{def:OOP_Method}s to have private access, which means they won't be visible to the \nameref{def:OOP_Subclass}.
\item The \nameref{def:OOP_Subclass} can add \nameref{def:Variable}s and/or \nameref{def:OOP_Method}s to those inherited from the \nameref{def:OOP_Superclass}.
\item The \nameref{def:OOP_Subclass} can modify the behavior of one or more of its inherited \nameref{def:OOP_Method}s. A modified \nameref{def:OOP_Method} has the same name, and often the same protocol, as the original.
\end{enumerate}

\begin{definition}[Method]\label{def:OOP_Method}
  A \emph{method} is a subprogram that defines the operations of/on \nameref{def:OOP_Object}s of a \nameref{def:OOP_Class}.
\end{definition}

\begin{definition}[Message]\label{def:OOP_Message}
  The calls to \nameref{def:OOP_Method}s are sometimes called \emph{message}s.
  Passing a message is different than calling a traditional subprogram.
  A message is sent to an \nameref{def:OOP_Object} that is a request to execute a \nameref{def:OOP_Method}.
  These \nameref{def:OOP_Method}s can operate on themselves, or on other \nameref{def:OOP_Object}s.
\end{definition}

\begin{definition}[Message Interface]\label{def:OOP_Message_Interface}
  Thus, the entire collection of \nameref{def:OOP_Method}s is called the \emph{message interface}, or \emph{message protocol} of the \nameref{def:OOP_Object}.
\end{definition}

\begin{definition}[Override]\label{def:OOP_Override}
  A new \nameref{def:OOP_Subclass}'s \nameref{def:OOP_Method} can \emph{override} a \nameref{def:OOP_Superclass}'s \nameref{def:OOP_Method}.
  This is then called an \emph{overridden method}.

  Overriding a \nameref{def:OOP_Method} is useful because it allows us to provide an operation in the \nameref{def:OOP_Subclass} that is similar to the one in the \nameref{def:OOP_Superclass}, but specialized for \nameref{def:OOP_Object}s of the \nameref{def:OOP_Subclass}.
\end{definition}

\begin{definition}[Instance Method]\label{def:OOP_Instance_Method}
  An \emph{instance \nameref{def:OOP_Method}} is a \nameref{def:OOP_Method} that \textbf{only} operates on instances of the \nameref{def:OOP_Class}.
\end{definition}

\begin{definition}[Instance Variable]\label{def:OOP_Instance_Variable}
  An \emph{instance \nameref{def:Variable}} is a unique set of \nameref{def:Variable}s defined by the initializing \nameref{def:OOP_Class}, and stores that \nameref{def:OOP_Object}'s state.
\end{definition}

\begin{definition}[\nameref*{def:OOP_Class} Variable]\label{def:OOP_Class_Variable}
  \emph{\nameref{def:OOP_Class} \nameref{def:Variable}}s belong to and operate on the \nameref{def:OOP_Class} itself, rather than just the \nameref{def:OOP_Object}s of a \nameref{def:OOP_Class}.
  This means there is only \textbf{one} copy for the whole \nameref{def:OOP_Class}, rather than a copy for every instance of this \nameref{def:OOP_Class}.

  For example, a counter of the number of instantiated \nameref{def:OOP_Object}s of that \nameref{def:OOP_Class} would require a class variable.
\end{definition}

\begin{definition}[\nameref*{def:OOP_Class} Method]\label{def:OOP_Class_Method}
  A \emph{\nameref{def:OOP_Class} \nameref{def:OOP_Method}} performs operations on the \nameref{def:OOP_Class} as a whole, rather than the individual \nameref{def:OOP_Object}s of that \nameref{def:OOP_Class}.
  This means there is only \textbf{one} copy for the whole \nameref{def:OOP_Class}, rather than a copy for every instance of this \nameref{def:OOP_Class}.
\end{definition}

\begin{definition}[Inheritance]\label{def:OOP_Inheritance}
  \emph{Inheritance} is the act of making a \nameref{def:OOP_Superclass} and deriving (inheriting) a \nameref{def:OOP_Subclass} from it.
  This creates a new \nameref{def:OOP_Class} as the original, but is slightly different.

  \begin{remark}
    The ability to reuse code through \nameref{def:OOP_Inheritance} means that dependencies between these \nameref{def:Abstract_Data_Type}s can form.
    This technically defeats the purpose of \nameref{def:Abstract_Data_Type}s' independence of each other.
    However, increasing the reusability without introducing dependencies may not be possible.
    In addition, these dependencies may make solving the issue in the problem domain easier.
  \end{remark}
\end{definition}

\begin{definition}[Single Inheritance]\label{def:OOP_Single_Inheritance}
  In \emph{single \nameref{def:OOP_Inheritance}}, a \nameref{def:OOP_Class} can \textbf{only} have 1 parent \nameref{def:OOP_Superclass}.
  However, any \nameref{def:OOP_Superclass} can have an infinite number of derived, child, \nameref{def:OOP_Subclass}es.

  When a relationship between \nameref{def:OOP_Class}es that use single \nameref{def:OOP_Inheritance} is visualized, a derivation tree is made.
\end{definition}

\begin{definition}[Multiple Inheritance]\label{def:OOP_Multiple_Inheritance}
  In \emph{multiple \nameref{def:OOP_Inheritance}}, a \nameref{def:OOP_Class} can have multiple parent \nameref{def:OOP_Superclass}es.
  Any \nameref{def:OOP_Superclass} can also have an infinite number of derived, child, \nameref{def:OOP_Subclass}es.

  When a relationship between \nameref{def:OOP_Class}es that uses multiple \nameref{def:OOP_Inheritance} it can be visualized as a derivation graph.

  \begin{remark}[Diamond Dependency]\label{rmk:Diamond_Dependency}
    In a language that supports \nameref{def:OOP_Multiple_Inheritance}, a problem can arise when a single class inherits from 2 \nameref{def:OOP_Class}es, which both inherit from one superclass.
    In the class derivation graph, this ends up creating a diamond shape, hence the name \emph{diamond dependency}.
    If any superclasses have methods that are overridden, then without an explicit statement to tell the compiler which method to use, it is impossible to decide which to use.
    The approach C++ takes is that the programmer must specify which superclass' method to use.
  \end{remark}
\end{definition}

\subsubsection{Top \nameref*{def:OOP_Superclass}}\label{subsubsec:Top_OOP_Superclass}
To have a class hierarchy in a programming language, there must be a ``top'' \nameref{def:OOP_Superclass} somewhere in the hierarchy, one class from which all subsequent classes derive from.

In Java, there is a single top class \texttt{\SemanticType{java.lang.Object}}.

However, C++ takes the stance of not having any implicit single top \nameref{def:OOP_Superclass}.
Instead, it can have multiple top \nameref{def:OOP_Superclass}es, and also allows any number of top-level classes without a \nameref{def:OOP_Superclass}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
