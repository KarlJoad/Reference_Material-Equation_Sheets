\section{Names}\label{sec:Names}
\emph{Names} or \emph{identifiers} are, obviously, names given to things.
They can identify:
\begin{itemize}[noitemsep]
\item Variables
\item Subprograms
\item Formal Parameters
\item Other program constructs
\end{itemize}

\subsection{Issues}\label{subsec:Names_Issues}
There are 2 questions that need to be asked when designing the names or identifiers possible in a language.
\begin{enumerate}[noitemsep]
\item Are names case-sensitive? For example, are these identifiers different?
  \begin{itemize}[noitemsep]
  \item \texttt{myvariable}
  \item \texttt{MYVARIABLE}
  \item \texttt{MyVariable}
  \item \texttt{myVariable}
  \end{itemize}
\item Are the special words of the language \nameref{def:Reserved_Word}s or are they \nameref{def:Keyword}s?
\end{enumerate}

\subsection{Name Forms}\label{subsec:Name_Forms}
How is a name/identifier defined?
\begin{itemize}[noitemsep]
\item Is there a character limit on the identifier/name?
\item Are all characters in the identifier/name significant?
\item What characters are allowed in the identifier/name?
\item Are there special characters required by a language?
  \begin{itemize}[noitemsep]
  \item \texttt{\$} being required in front of identifiers in PHP
  \item \texttt{\$}, \texttt{@}, \texttt{\%} specifying a ``type''  in Perl
  \item \texttt{@} and \texttt{@@} to denote an instance or class variable in Ruby, respectively
  \end{itemize}
\end{itemize}

Some languages are \emph{case-sensitive}.
C, Java, C++, etc.\ would all treat \texttt{rose}, \texttt{ROSE}, and \texttt{Rose} differently.
This could be a detriment to readability, because names that \textit{look} similar are actually not.
In terms of writability, the programmer must remember the exact typecasing of the identifier/name.

\subsection{Special Names}\label{subsec:Special_Names}
There are \nameref{def:Reserved_Word}s and \nameref{def:Keyword}s.
They are similar in that the programming language specification defines that these words have special meanings when constructing programs.
However, the 2 differ in how these words can potentially be reused.

\begin{definition}[Keyword]\label{def:Keyword}
  \emph{Keyword}s are words that are defined by the language constructors to have some special meaning.
  However, it only has these special meanings in \textbf{\emph{certain contexts}}.
  This means you can define a keyword as a variable and use it together with the keyword.
  For example, this is a perfectly valid piece of Fortran code:
\begin{minted}[frame=lines,linenos]{fortran}
Integer Apple
Integer = 4
\end{minted}
\end{definition}

\begin{definition}[Reserved Word]\label{def:Reserved_Word}
  \emph{Reserved word}s are words that are reserved by the language constructors because those particular words have a meaning in the language.
  These words cannot be used as identifiers for \textbf{ANYTHING} else.
  For example:
  \begin{itemize}[noitemsep]
  \item \texttt{while}
  \item \texttt{class}
  \item \texttt{for}
  \end{itemize}

  \begin{remark}[Too Many \nameref{def:Reserved_Word}s]\label{rmk:Too_Many_Reserved_Words}
    The potential problem with \nameref{def:Reserved_Word}s is that if a language has a large number of reserved words, the user might have a hard time creating names for themselves.
    Unfortunately, the most commonly chosen words by programs are usually \nameref{def:Reserved_Word}s.
    For example,
    \begin{itemize}[noitemsep]
    \item \texttt{LENGTH}
    \item \texttt{BOTTOM}
    \item \texttt{DESTINATION}
    \item \texttt{COUNT}
    \end{itemize}
  \end{remark}
\end{definition}

\subsection{Variables}\label{subsec:Variables}
\begin{definition}[Variable]\label{def:Variable}
  A program \emph{variable} is an abstraction of a computer \nameref{def:Memory} cell or a collection of \nameref{def:Memory} cells.
  A variable can be characterized by a sextuple of attributes:
  \begin{enumerate}[noitemsep]
  \item \nameref{subsubsec:Variable_Name}
  \item \nameref{subsubsec:Variable_Address}
  \item \nameref{subsubsec:Variable_Value}
  \item \nameref{subsubsec:Variable_Type}
  \item \nameref{subsubsec:Storage_Bindings_and_Lifetime}
  \item \nameref{subsec:Variable_Scope}
  \end{enumerate}
\end{definition}

\subsubsection{Name}\label{subsubsec:Variable_Name}
Most \nameref{def:Variable}s have names.
These are symbolic references to the value that is actually stored.
There are various issues that may arise with the name of a variable, which were discussed earlier.

\subsubsection{Address}\label{subsubsec:Variable_Address}
\begin{definition}[Address]\label{def:Variable_Address}
  The \emph{address} of a \nameref{def:Variable} is the machine's memory address with which the \nameref{def:Variable} is associated.

  The address of a variable is sometimes called its \emph{L-Value}.
  This is because the address is required when the name of a variable appears on the left-hand side of an assignment statement.

  \begin{remark}[Alias]
    An \emph{alias} is having another \nameref{def:Variable} have the same \nameref{def:Variable_Address}, so the 2 \nameref{def:Variable}s point to the same value in \nameref{def:Memory}.
  \end{remark}
\end{definition}

For some languages, it is possible for the same \nameref{def:Variable} to be associated with different addresses at different times during the \nameref{def:Variable}'s lifetime.

\subsubsection{Type}\label{subsubsec:Variable_Type}
\begin{definition}[Type]\label{def:Variable_Type}
  The \emph{type} of a \nameref{def:Variable} determines the range of values that \nameref{def:Variable} can store.
  For example, the \texttt{int} type in Java specifies a value range of $-2147483648$ to $2147483647$.
  It is a 32-bit signed integer.
\end{definition}

\subsubsection{Value}\label{subsubsec:Variable_Value}
\begin{definition}[Value]\label{def:Variable_Value}
  The \emph{value} of a \nameref{def:Variable} is the contents of the \nameref{def:Memory} cell or cells associated with the \nameref{def:Variable}.
  The value of a variable is sometimes called it \emph{R-Value}.
  This is because the value of the \nameref{def:Variable} is required on the right-hand side of an assignment statement.
  To access the \textit{r}-value, the \textit{l}-value must be determined first.
  
  \begin{remark}[Abstract Memory Cells]\label{rmk:Abstract_Memory_Cells}
    While in hardware, the individual sizes of \nameref{def:Memory} are fixed, we can think of \nameref{def:Memory} as having \emph{abstract memory cells}, that can accomodate anything we attempt to put into \nameref{def:Memory}.
    This means that a single-precision floating point number technically takes up 4 bytes, 32 bits, of \nameref{def:Memory} cells, that number only takes one abstract memory cell.
  \end{remark}
\end{definition}

\subsection{Binding}\label{subsec:Binding}
\begin{definition}[Binding]\label{def:Binding}
  A \emph{binding} is an association between an attribute and an entity.
  This association can be between:
  \begin{itemize}[noitemsep]
  \item A variable
    \begin{itemize}[noitemsep]
    \item Its type
    \item Its value
    \end{itemize}
  \item An operation
    \begin{itemize}[noitemsep]
    \item Its symbol
    \end{itemize}
  \end{itemize}

  The time at which a binding occurs is called the \nameref{def:Binding_Time}.
\end{definition}

\begin{definition}[Binding Time]\label{def:Binding_Time}
  The time at which \nameref{def:Binding} occurs is called the \emph{binding time}.
  These include:
  \begin{itemize}[noitemsep]
  \item Language Design Time
    \begin{itemize}[noitemsep]
    \item Defining \texttt{*} to represent multiplication
    \end{itemize}
  \item Language Implementation Time
    \begin{itemize}[noitemsep]
    \item Having an \texttt{int} in C be a 32-bit signed integer
    \end{itemize}
  \item Compiler Time
    \begin{itemize}[noitemsep]
    \item The type of a variable in a Java program
    \end{itemize}
  \item Link Time
    \begin{itemize}[noitemsep]
    \item A call to a library subprogram is bound to the subprogram code
    \end{itemize}
  \item Load Time
    \begin{itemize}[noitemsep]
    \item \nameref{def:Variable} bound when loaded into \nameref{def:Memory}
    \item Could happen at run time too
    \end{itemize}
  \item Run Time
    \begin{itemize}[noitemsep]
    \item \nameref{def:Variable} bound when loaded into \nameref{def:Memory}
    \item Could happen at compile time too
    \end{itemize}
  \end{itemize}
\end{definition}

We need to know the \nameref{def:Binding_Time}s for the attributes of a program to understand the semantics of the programming language.

\subsubsection{Binding of Attributes to \nameref*{def:Variable}s}\label{subsubsec:Binding_Attributes_Variables}
\begin{definition}[Static]\label{def:Static_Variable_Binding}
  A \nameref{def:Binding} is \emph{static} if the \nameref{def:Binding} first occurs before run time begins and remains unchanged throughout program execution.
  An example of this is declaring a \nameref{def:Variable} as an \texttt{int} in C.
  Throughout the whole C program, that \nameref{def:Variable} can only hold signed 32-big integers.
\begin{minted}[frame=lines,linenos]{c}
int x = 4;
float x = 4.0; // Error here, x already declared
x = 4.0 // Error here, x is of int type
\end{minted}
\end{definition}

\begin{definition}[Dynamic]\label{def:Dynamic_Variable_Binding}
  A \nameref{def:Binding} is \emph{dynamic} if the \nameref{def:Binding} occurs during run time, or can change in the course of program execution.
  An example of this is declaring a \nameref{def:Variable} in Python.
\begin{minted}[frame=lines,linenos]{python3}
x = 4
x = [1, 2, 3]
x = 'dynamically bound string'
\end{minted}
  All three lines have a variable declaration, where the \nameref{def:Binding} occur during the program's execution and changed during it.
\end{definition}

We are only concerned with the distinction between \nameref{def:Static_Variable_Binding} and \nameref{def:Dynamic_Variable_Binding} \nameref{def:Variable} \nameref{def:Binding}.
Meaning, we will ignore how hardware may bind and unbind things repeatedly when it is switching and moving things around.

\subsubsection{Type \nameref*{subsec:Binding}s}\label{subsubsec:Type_Bindings}
Before a \nameref{def:Variable} can be used or referenced in a program, its \nameref{def:Variable_Type} must be declared.
A \nameref{def:Variable}'s \emph{type} determines the range of values that can be stored in the \nameref{def:Variable}.
In a more abstract sense, it also determines what kind of operations make sense and are possible to use on these \nameref{def:Variable}s.
There are 2 important aspects of this \nameref{def:Binding}:
\begin{enumerate}[noitemsep]
\item How the \nameref{def:Variable} \nameref{def:Variable_Type} is specified
\item When the \nameref{def:Binding} takes place
\end{enumerate}

There are 2 ways to bind \nameref{def:Variable_Type}s to \nameref{def:Variable}s:
\begin{enumerate}[noitemsep]
\item \nameref{par:Static_Variable_Type_Binding}
  \begin{itemize}[noitemsep]
  \item \nameref{def:Explicit_Static_Variable_Type_Binding}
  \item \nameref{def:Implicit_Static_Variable_Type_Binding}
  \end{itemize}
\item \nameref{par:Dynamic_Variable_Type_Binding}
\end{enumerate}

\paragraph{Static \nameref*{def:Variable_Type} \nameref*{subsec:Binding}}\label{par:Static_Variable_Type_Binding}
\begin{definition}[Static]\label{def:Static_Variable_Type_Binding}
  \emph{Static} \nameref{def:Binding} of \nameref{def:Variable}s means that the \nameref{def:Variable_Type} of a \nameref{def:Variable} is given to the program, either \nameref{def:Explicit_Static_Variable_Type_Binding}ly or \nameref{def:Implicit_Static_Variable_Type_Binding}ly before run time begins.
  Once the \nameref{def:Variable_Type} is declared, it cannot be changed throughout the entire program's execution.

  There are 2 ways to \nameref{def:Static_Variable_Type_Binding}ly bind a \nameref{def:Variable_Type} to a \nameref{def:Variable}:
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Explicit_Static_Variable_Type_Binding}ly
  \item \nameref{def:Implicit_Static_Variable_Type_Binding}ly
  \end{enumerate}
\end{definition}

\begin{definition}[Explicit]\label{def:Explicit_Static_Variable_Type_Binding}
  An \emph{explicit} \nameref{def:Static_Variable_Type_Binding} \nameref*{def:Variable_Type} \nameref*{def:Binding} is a statement that explicitly sets each \nameref{def:Variable} to its respective \nameref{def:Variable_Type}.
  These are statements in a program that lists variable names and specifies that they are of a particular \nameref{def:Variable_Type}.
  For example,
\begin{minted}[frame=lines,linenos]{c}
int x = 0;
float x = 0.0;
char x = 'x';
\end{minted}
\end{definition}

\begin{definition}[Implicit]\label{def:Implicit_Static_Variable_Type_Binding}
  An \emph{implicit} \nameref{def:Static_Variable_Type_Binding} \nameref*{def:Variable_Type} \nameref*{def:Binding} declaration associates \nameref{def:Variable}s with \nameref{def:Variable_Type}s through default conventions, rather than \nameref{def:Explicit_Static_Variable_Type_Binding} declaration statements.
  The first appearance of a \nameref{def:Variable} name is its implicit declaration.

  \begin{remark}[Effects on \nameref*{subsec:Reliability}]
    While \nameref{def:Implicit_Static_Variable_Type_Binding} can be helpful for programmers, they can be quite detrimental to \nameref{subsec:Reliability} because the compilation process cannot determine some type errors and some programmer errors.
  \end{remark}
\end{definition}

\nameref{def:Implicit_Static_Variable_Type_Binding} declarations are handled by the language processor (\nameref{def:Compiler} or Interpreter).
There are several ways to have \nameref{def:Implicit_Static_Variable_Type_Binding} declarations work, some of which are:
\begin{itemize}[noitemsep]
\item Naming conventions
  \begin{itemize}[noitemsep]
  \item In \textbf{Fortran}, if an identifier starts with
    \begin{itemize}[noitemsep]
    \item \texttt{I}, \texttt{J}, \texttt{K}, \texttt{L}, \texttt{M}, or \texttt{N}, or their lowercase versions, it is \nameref{def:Implicit_Static_Variable_Type_Binding}ly declared to be an \texttt{Integer} type.
    \item Otherwise, it is \nameref{def:Implicit_Static_Variable_Type_Binding}ly declared to be a \texttt{Real} type.
    \end{itemize}
  \item In \textbf{Perl}, an identifier must be preceded by a special character denoting the \nameref{def:Variable_Type}. This method forms separate namespaces for each \nameref{def:Variable} \nameref{def:Variable_Type}.
    \begin{itemize}[noitemsep]
    \item \texttt{\$}, is a scalar. This holds numbers and strings
    \item \texttt{@}, is an array.
    \item \texttt{\%}, is a hash structure.
    \item The separate namespaces means that all 3 of these variables are considered unique, and potentially unrelated.
      \begin{itemize}[noitemsep]
      \item \texttt{\$apple}
      \item \texttt{@apple}
      \item \texttt{\%apple}
      \end{itemize}
    \end{itemize}
  \end{itemize}
  
\item Context or type inference
  \begin{itemize}[noitemsep]
  \item In \textbf{C\#}, a \texttt{var} declaration for a \nameref{def:Variable} must include an initial value, which determines the \nameref{def:Variable_Type} of the \nameref{def:Variable}.
\begin{minted}[frame=lines,linenos]{csharp}
var sum = 0;
var total = 0.0;
var name = "Fred";
\end{minted}
  \item \texttt{sum}, \texttt{total}, and \texttt{name} are an \texttt{int}, \texttt{float}, and \texttt{string}, respectively.
  \end{itemize}
\end{itemize}

\begin{remark*}
  Both \nameref{def:Explicit_Static_Variable_Type_Binding} and \nameref{def:Implicit_Static_Variable_Type_Binding} declarations create \nameref{def:Static_Variable_Binding} \nameref{def:Binding}s to \nameref{def:Variable_Type}s.
\end{remark*}

\paragraph{Dynamic \nameref*{def:Variable_Type} \nameref*{subsec:Binding}}\label{par:Dynamic_Variable_Type_Binding}
With \nameref*{par:Dynamic_Variable_Type_Binding}, the \nameref{def:Variable_Type} of a \nameref{def:Variable}:
\begin{itemize}[noitemsep]
\item Is not specified by a declaration statement
\item Cannot be determined by the spelling of the \nameref{def:Variable}'s name
\end{itemize}

\begin{definition}[Dynamic]\label{def:Dynamic_Variable_Type_Binding}
  A \emph{dynamic} \nameref{def:Binding} happens when a \nameref{def:Variable} is bound to a \nameref{def:Variable_Type} \textbf{when it is assigned a \nameref{def:Variable_Value}.}
  Such an assignment might also bind the \nameref{def:Variable} to an \nameref{def:Variable_Address}.

  Any \nameref{def:Variable} can be assigned any \nameref{def:Variable_Type}.
  A \nameref{def:Variable}'s \nameref{def:Variable_Type} can be changed any number of times during program execution.

  The name of the \nameref{def:Variable} is bound to the \nameref{def:Variable}, then the \nameref{def:Variable} is bound to a \nameref{def:Variable_Type} and given its \nameref{def:Variable_Value}.

  2 programming languages that use this are:
  \begin{enumerate}[noitemsep]
  \item Python
  \item Ruby
  \end{enumerate}

  \begin{remark}[Benefits of \nameref*{def:Dynamic_Variable_Type_Binding} \nameref*{def:Binding}]\label{rmk:Dynamic_Variable_Type_Bindign-Benefits}
    The primary benefit of having \nameref{def:Dynamic_Variable_Type_Binding} \nameref{def:Binding} is the programming flexibility it provides.
  \end{remark}

  \begin{remark}[Drawbacks of \nameref*{def:Dynamic_Variable_Type_Binding} \nameref*{def:Binding}]\label{rmk:Dynamic_Variable_Type_Binding-Drawbacks}
    The 2 major disadvantages are:
    \begin{enumerate}[noitemsep]
    \item Programs are less reliable, because error-detection of the compiler/interpreter is diminished relative to a compiler/interpreter for a language with \nameref{def:Static_Variable_Type_Binding} \nameref{def:Variable_Type} \nameref{def:Binding}s.
    \item The \nameref{subsec:Cost} is quite high because of the \nameref{def:Type_Checking} that must occur at run time. Also, every variable must have a run-time descriptor to describe the \nameref{def:Variable}'s current \nameref{def:Variable_Type}.
    \end{enumerate}
  \end{remark}
\end{definition}

\begin{remark*}
  \nameref{def:Dynamic_Variable_Type_Binding} \nameref{def:Variable_Type} \nameref{def:Binding} is usually implemented with \nameref{subsec:Interpretation}.
  This is because:
  \begin{itemize}[noitemsep]
  \item The overall \nameref{subsec:Cost} of \nameref{def:Variable_Type} handing is hidden by the \nameref{subsec:Cost} of the interpreter.
  \item The \nameref{def:Variable_Type} of an operation's operands must be known to translate the instruction to the correct machine code instruction, which isn't possible with \nameref{def:Dynamic_Variable_Type_Binding} \nameref{def:Variable_Type} \nameref{def:Binding}.
  \end{itemize}
\end{remark*}

\subsubsection{Storage \nameref*{subsec:Binding}s and Lifetime}\label{subsubsec:Storage_Bindings_and_Lifetime}
The \nameref{def:Memory} cell to which a \nameref{def:Variable} is bound must be pulled from the pool of available \nameref{def:Memory}.
The act of binding the \nameref{def:Variable_Value} to a \nameref{def:Variable} is called \nameref{def:Variable_Memory_Allocation}.
The act of unbinding is called \nameref{def:Variable_Memory_Deallocation}.

\begin{definition}[Allocation]\label{def:Variable_Memory_Allocation}
  \emph{Allocation} is the act of binding a \nameref{def:Variable_Value} to a \nameref{def:Memory} cell for a \nameref{def:Variable}.
\end{definition}

\begin{definition}[Deallocation]\label{def:Variable_Memory_Deallocation}
  \emph{Deallocation} is the process of placing a \nameref{def:Memory} cell that has been unbound from a variable back into the pool of available \nameref{def:Memory}.
\end{definition}

\begin{definition}[Lifetime]\label{def:Variable_Lifetime}
  The \emph{lifetime} of a \nameref{def:Variable} is the time in which the \nameref{def:Variable} is bound to a \nameref{def:Memory} cell.
  The lifetime of a \nameref{def:Variable} starts when it is bound to a cell and ends when it has been unbound from that cell.

  We will split the discussion of \nameref*{subsubsec:Storage_Bindings_and_Lifetime} of scalar \nameref{def:Variable}s into 4 categories, according to their \nameref{def:Variable_Lifetime}s.
  \begin{itemize}[noitemsep]
  \item \nameref{par:Static_Variable_Binding_Lifetime}
  \item \nameref{par:Stack-Dynamic_Variable_Binding_Lifetime}
  \item \nameref{par:Explicit_Heap-Dynamic_Variable_Binding_Lifetime}
  \item \nameref{par:Implicit_Heap-Dynamic_Variable_Binding_Lifetime}
  \end{itemize}
\end{definition}

\paragraph{Static Variables}\label{par:Static_Variable_Binding_Lifetime}
\begin{definition}[Static Variable]\label{def:Static_Variable_Binding_Lifetime}
  \emph{Static variable}s are those that are bound to \nameref{def:Memory} cells before program execution begins and remain bound until the program terminates.
  They are placed in the ``static'' section of \nameref{def:Memory}.
  \nameref{def:Static_Variable_Binding_Lifetime}s can be used as globally accessible \nameref{def:Variable}s, or ensure that subprograms are history-sensitive.

  The pros and cons of \nameref{def:Static_Variable_Binding_Lifetime}s are:
  \begin{itemize}[noitemsep]
  \item Pros
    \begin{itemize}[noitemsep]
    \item Efficiency. All \nameref{def:Memory} addressing is done with absolute addresses, making things very fast.
    \item No cost to allocate and deallocate the \nameref{def:Memory} during run-time.
    \item Programs can be history sensitive.
    \end{itemize}
  \item Cons
    \begin{itemize}[noitemsep]
    \item Reduced flexibility. If there is a language that only has \nameref{def:Static_Variable_Binding_Lifetime}s, then recursive subprograms are impossible.
    \item \nameref{def:Memory} cannot be shared between inactive and active subprograms.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{remark*}
  In C and C++, \texttt{static} can be set on functions, making the \nameref{def:Variable}s declared in the function \nameref{def:Static_Variable_Binding_Lifetime}.
\end{remark*}

\begin{remark*}
  In Java, C++, and C\#, \texttt{static} can appear on classes, meaning class \nameref{def:Variable}s are created statically some time before the class is first instantiated.
\end{remark*}

\paragraph{Stack-Dynamic Variables}\label{par:Stack-Dynamic_Variable_Binding_Lifetime}
\begin{definition}[Stack-Dynamic Variable]\label{def:Stack-Dynamic_Variable_Binding_Lifetime}
  \emph{Stack-dynamic variable}s are those whose storage \nameref{def:Binding}s are created when their declaration statements are elaborated.
  These are allocated from the run-time \nameref{def:Call_Stack}.
  Thus, when a function on the \nameref{def:Call_Stack} is \texttt{return}ed from, all the variables here lose their value.

  \begin{remark}
    These are the variables that are most commonly used, and are usually function-local variables
  \end{remark}

  \begin{remark}
    In languages that allow for variable declaration anywhere in the function, like Java and C++, the \nameref{def:Stack-Dynamic_Variable_Binding_Lifetime}s may be bound to storage at the beginning of the block, thus starting the variable's \nameref{def:Variable_Lifetime}.
    In these cases, the \nameref{def:Variable} becomes visible at the declaration, but the storage \nameref{def:Binding} occurs when the block begins execution.
    So, it is both in \nameref{def:Variable_Scope} and has begun its \nameref{def:Variable_Lifetime}, but has no useful value.
  \end{remark}

  The advantages and disadvantages of \nameref{def:Stack-Dynamic_Variable_Binding_Lifetime}s, compared to \nameref{def:Static_Variable_Binding_Lifetime}s, are:
  \begin{itemize}[noitemsep]
  \item Advantages
    \begin{itemize}[noitemsep]
    \item Allows for recursive subprograms that have local variables
    \item All subprograms can share the same memory space for their locals, allowing for a smaller memory footprint, by only having some variables bound to storage at once.
    \end{itemize}
  \item Disadvantages
    \begin{itemize}[noitemsep]
    \item Runtime overhead of \nameref{def:Variable_Memory_Allocation} and \nameref{def:Variable_Memory_Deallocation}.
    \item Slower accessing of \nameref{def:Stack-Dynamic_Variable_Binding_Lifetime}s because of indirect addressing.
    \item Subprograms cannot be history-sensitive with just \nameref{def:Stack-Dynamic_Variable_Binding_Lifetime}s.
    \end{itemize}
  \end{itemize}
\end{definition}

\begin{definition}[Elaboration]\label{def:Variable_Storage_Binding_Elaboration}
  \emph{Elaboration} of a \nameref{def:Variable} declaration refers to the storage \nameref{def:Variable_Memory_Allocation} and \nameref{def:Binding} process indicated by the declaration, which takes place when execution reaches that code.

  This occurs at run time.
\end{definition}

\paragraph{Explicit Heap-Dynamic Variables}\label{par:Explicit_Heap-Dynamic_Variable_Binding_Lifetime}
\begin{definition}[Explicit Heap-Dynamic Variable]\label{def:Explicit_Heap-Dynamic_Variable_Binding_Lifetime}
  \emph{Explicit heap-dynamic variables} are nameless (abstract) memory cells that are allocated and deallocated by explicit run-time instructions written by the programmer.
  These \nameref{def:Variable}s are allocated to and deallocated from the \nameref{def:Heap}.
  They can only be referenced through pointers or reference variables.

  The pointer/reference can only be created and returned by:
  \begin{itemize}[noitemsep]
  \item An operator (in C++), \texttt{new}
  \item A subprogram (in C), \texttt{malloc}
  \end{itemize}

  Some languages include ways to destroy these pointers/references:
  \begin{itemize}[noitemsep]
  \item An operator (in C++), \texttt{delete}
  \item A subprogram (in C), \texttt{free}
  \end{itemize}

  The advantages and disadvantages of these types of \nameref{def:Variable}s are:
  \begin{itemize}[noitemsep]
  \item Advantages
    \begin{itemize}[noitemsep]
    \item \nameref{def:Explicit_Heap-Dynamic_Variable_Binding_Lifetime} are often used to construct dynamic data structures, like linked lists and trees. These are built conveniently using pointers and data.
    \end{itemize}
  \item Disadvantages
    \begin{itemize}[noitemsep]
    \item The difficulty of using pointer/reference variables correctly.
    \item The \nameref{subsec:Cost} of using these pointers/reference variables.
    \item Complexity of the required storage management implementation (Although, this is a question of \nameref{def:Heap} management, which is costly and complicated and completely separate discussion).
    \end{itemize}
  \end{itemize}
\end{definition}

An example of an \nameref{def:Explicit_Heap-Dynamic_Variable_Binding_Lifetime} is shown below.
\begin{minted}[frame=lines,linenos]{c++}
int *intnode; // Create a pointer
intnode = new int; // Create the heap-dynamic variable
...
delete intnode; // Deallocate the heap-dynamic variable to which intnode points
\end{minted}

The \nameref{def:Heap} is highly disorganized because of the unpredictability of its use.
There are 2 ways to manage the \nameref{def:Heap}:
\begin{enumerate}[noitemsep]
\item Explicit \nameref{def:Variable_Memory_Deallocation}
  \begin{itemize}[noitemsep]
  \item The programmer must explicitly free the \nameref{def:Memory} themselves.
  \item C and C++ require this with their \texttt{free} and \texttt{delete} subprograms/operators, respectively.
  \end{itemize}
\item Implicit \nameref{def:Variable_Memory_Deallocation}
  \begin{itemize}[noitemsep]
  \item The programming language has facilities, called \emph{garbage collection} that automatically manages the \nameref{def:Heap}.
  \item There are many algorithms that handle garbage collection, some of which are faster, others slower.
  \end{itemize}
\end{enumerate}

\paragraph{Implicit Heap-Dynamic Variables}\label{par:Implicit_Heap-Dynamic_Variable_Binding_Lifetime}
\begin{definition}[Implicit Heap-Dynamic Variable]\label{def:Implicit_Heap-Dynamic_Variable_Binding_Lifetime}
  \emph{Implicit heap-dynamic variable}s are bound to \nameref{def:Heap} storage \textbf{only when they are assigned \nameref{def:Variable_Value}s}.
  In many regards, \nameref{def:Implicit_Heap-Dynamic_Variable_Binding_Lifetime}s and \nameref{def:Explicit_Heap-Dynamic_Variable_Binding_Lifetime}s are quite similar.

  However, \nameref{def:Implicit_Heap-Dynamic_Variable_Binding_Lifetime}s have \textbf{ALL} their attributes bound \textbf{EVERY} time they are assigned.
  The advantages and disadvantages of these types of \nameref{def:Variable}s are:
  \begin{itemize}[noitemsep]
  \item Advantages
    \begin{itemize}[noitemsep]
    \item Highest degree of flexibility, allowing for highly generic code
    \end{itemize}
  \item Disadvantages
    \begin{itemize}[noitemsep]
    \item Run time overhead of maintaining all the dynamic attributes, which could include subscript types and ranges
    \item Loss of some error dectection by the compiler/interpreter
    \end{itemize}
  \end{itemize}
\end{definition}

\subsection{Scope}\label{subsec:Variable_Scope}
\begin{definition}[Scope]\label{def:Variable_Scope}
  The \emph{scope} of a \nameref{def:Variable} is the range of statements in which the \nameref{def:Variable} is \nameref{def:Visible_Variable}.
\end{definition}

\nameref{def:Variable_Scope} might seem similar to \nameref{def:Variable_Lifetime}, but they are different.
Here are 2 examples that illustrate this point:
\begin{enumerate}[noitemsep]
\item At the second \texttt{print(x)}, \texttt{x} is \emph{in scope} (visible), but is \emph{dead} (deallocated).
\begin{minted}[frame=lines,linenos]{c}
int f(void) {
  int *x;
  x = (int *) calloc(sizeof(int), 1);
  print(x);
  free(x);
  print(x);
}
\end{minted}
  
\item When executing inside of \texttt{g(y)}, the \texttt{x} in function \texttt{f} is \emph{alive} (allocated), but is \emph{out of scope} (not visible).
\begin{minted}[frame=lines,linenos]{python3}
def f(x):
  return g(7)
def g(y):
  print (y)
  return
\end{minted}
\end{enumerate}

\begin{definition}[Visible]\label{def:Visible_Variable}
  A \nameref{def:Variable} is \emph{visible} in a statements if it can be referenced in that statement.

  \begin{remark}[In-Scope]\label{rmk:In_Scope_Variable}
    Sometimes, a \nameref{def:Variable} that is \nameref{def:Visible_Variable} is called \emph{in-\nameref{def:Variable_Scope}}.
  \end{remark}
\end{definition}

\begin{definition}[Local Variable]\label{def:Local_Variable}
  A \nameref{def:Variable} is a \emph{local variable} in a program unit or block if it is declared there.
  \nameref{def:Variable}s defined within subprograms are also local variables.
  The \nameref{def:Variable_Scope} is usually the body of the subprogram in which they are defined.

  \begin{remark}[Storage Binding]
    If the \nameref{def:Local_Variable} is a \nameref{def:Stack-Dynamic_Variable_Binding_Lifetime}, it is bound to storage when the subprogram begins and unbound when that execution terminates.
  \end{remark}
\end{definition}

\begin{definition}[Nonlocal Variable]\label{def:Nonlocal_Variable}
  The nonlocal variables of a program are visible with that particular program unit or block, but are not declared there.

  \begin{remark}[Global Variables]
    Global variables are a special case of \nameref{def:Nonlocal_Variable}s.
    These are discussed in \Cref{subsubsec:Variable_Global_Scope}.
  \end{remark}
\end{definition}

\subsubsection{Static Scope}\label{subsubsec:Static_Scope}
\begin{definition}[Static Scoping]\label{def:Static_Scoping}
  \emph{Static scoping} is a way to statically determine the scope of a \nameref{def:Variable}.
  When there is a reference to a \nameref{def:Variable}, the attributes of the \nameref{def:Variable} can be determined by finding the statement in which it is declared (either explicitly or implicitly).
  This makes it easy for a human reader and compiler/interpreter to figure out the \nameref{def:Variable_Type} of every \nameref{def:Variable} in the program.

  There are 2 types of statically-scoped languages:
  \begin{enumerate}[noitemsep]
  \item Subprograms can be nested inside programs (Python)
  \item Subprograms cannot be nested inside programs (Java)
  \end{enumerate}

  \begin{remark}[Lexical Scoping]\label{rmk:Variable_Lexical_Scoping}
    \nameref{def:Static_Scoping} is sometimes called \emph{lexical scoping}.
  \end{remark}
\end{definition}

\nameref{def:Static_Scoping} creates a tree-like structure, where each \nameref{def:Variable} declared in a program unit/block has a \nameref{def:Variable_Static_Parent}.
Then, each \nameref{def:Variable_Static_Parent} has a list of \nameref{def:Variable_Static_Ancestor}s.

\begin{definition}[Static Parent]\label{def:Variable_Static_Parent}
  If the \nameref{def:Variable} referenced is not present as a \nameref{def:Local_Variable}, then we have to go to the next outer program unit or block, the \emph{static parent}.
\end{definition}

\begin{definition}[Static Ancestor]\label{def:Variable_Static_Ancestor}
  The \emph{static ancestor}s are all the \nameref{def:Variable_Static_Parent}s to that particular program unit/block.
\end{definition}

This is illustrated by finding \texttt{x} in \texttt{sub2()} in this JavaScript function.
\begin{minted}[frame=lines,linenos]{javascript}
function big() {
  function sub1() {
    var x = 7;
    sub2();
  }
  function sub2() {
    var y = x;
  }
  var x = 3;
  sub1();
}
\end{minted}
The \texttt{x} in \texttt{sub2()} refers to the \texttt{x=3} in \texttt{big()}, because \texttt{sub1()} is not a \nameref{def:Variable_Static_Ancestor} of \texttt{sub2()}.
However, inside of \texttt{sub1()}, the use of the variable \texttt{x} would refer to the \texttt{x=7} value, and never the \texttt{x=3} value.

In some languages, if a \nameref{def:Variable} is declared in a sub-program unit/block, like in \texttt{sub1()}, then preceding the \nameref{def:Variable} name with the outer program unit/block will give the outer \nameref{def:Variable} \nameref{def:Variable_Value}.

\subsubsection{Dynamic Scope}\label{subsubsec:Dynamic_Scope}
\begin{definition}[Dynamic Scoping]\label{def:Dynamic_Scoping}
  \emph{Dynamic scoping} is based on the calling sequence of subprograms, and not their spatial relationship to each other.
  Thus, the scope can only be determined at run time.

  Some languages that implement this are:
  \begin{itemize}[noitemsep]
  \item APL
  \item SNOBOL4
  \item Early LISP
  \item Perl (Allowed, but must be said explicitly)
  \item Common LISP (Allowed, but must be said explicitly)
  \end{itemize}
\end{definition}

To illustrate \nameref{def:Dynamic_Scoping}, look at the code block below, and assume it is in a language that uses \nameref{def:Dynamic_Scoping}.
\begin{minted}[frame=lines,linenos]{javascript}
function big() {
  function sub1() {
    var x = 7;
    sub2();
  }
  function sub2() {
    var y = x;
  }
  var x = 3;
  sub1();
  sub2();
}
\end{minted}

The call to \texttt{sub1()} by \texttt{big()}, which then calls \texttt{sub2()}.
In that running of \texttt{sub2()}, the use of \texttt{x} cannot be determined locally (within that function).
Thus, it goes to its dynamic parent, \texttt{sub1()} and finds a declaration for \texttt{x}.
Thus, the \texttt{y} in \texttt{sub2()} evaluates to \texttt{y=7}.

The next instruction, the call to \texttt{sub2()} by \texttt{big()}, produces a different result.
In that running of \texttt{sub2()}, the use of \texttt{x} cannot be determined locally (within that function).
Thus, it goes to its dynamic parent, \texttt{big()} and finds a declaration for \texttt{x}.
Thus, the \texttt{y} in \texttt{sub2()} evaluates to \texttt{y=3}.

\subsubsection{Blocks}\label{subsubsec:Variable_Blocks}
New \nameref{subsubsec:Static_Scope}s can be defined in the middle of executing code.
This allows a small section to have its own \nameref{def:Local_Variable}s.

\begin{definition}[Block]\label{def:Block_Scope}
  A \emph{block} is a section of code that has its own \nameref{def:Local_Variable}s.
  These \nameref{def:Local_Variable}s are \textbf{not} shared with any \nameref{def:Variable_Static_Ancestor}s.
\end{definition}

The use of \nameref{def:Block_Scope}s create a \nameref{def:Block_Structured_Language}.

\begin{definition}[Block-Structured Language]\label{def:Block_Structured_Language}
  The use of \nameref{def:Block_Scope}s to create the \nameref{subsubsec:Static_Scope}s creates a \emph{block-structured language}.
\end{definition}

Consider the following C function:
\begin{minted}[frame=lines,linenos]{c}
void sub() {
  int count;
  ...
  while (...) {
    int count;
    count++;
  }
  ...
}
\end{minted}
The \texttt{count} inside the \texttt{while} loop is that loop's local count, and does not reference the \texttt{count} in \texttt{sub}.

\paragraph{Blocks in Functional Languages}\label{par:Variable_Block_in_Functional_Languages}
Since \nameref{def:Variable}s in \nameref{def:Functional_Programming_Language}s actually evaluate and store expressions, they behave differently.
Each functional language handles this differently, so you will have to look at the language specification to find out exactly how \nameref{def:Variable}s are scoped.

\subsubsection{Declaration Order}\label{subsubsec:Variable_Declaration_Order}
Some languages require that all \nameref{def:Variable} declarations occur at the beginning of a function (C89).

In some languages, \nameref{def:Variable}s cannot used before they have been declared.
\begin{itemize}[noitemsep]
\item Some of these languages allow for \nameref{def:Variable}s to be declared anywhere in the function, but can only be referenced \textbf{after} their declaration until the end of their scope.
\item Some of these languages allow for \nameref{def:Variable}s to be declared anywhere in the function, but if used before their declaration, they use a value like \texttt{undefined} (JavaScript).
\end{itemize}

This is a highly language-dependent thing, and one must consult with the language specification to figure out exactly how it works.

\subsubsection{Global Scope}\label{subsubsec:Variable_Global_Scope}
\begin{definition}[Global Variable]\label{def:Global_Variable}
  These are usually \nameref{def:Variable}s that sit outside of all functions.
  They can be accessed from anywhere in the program.
  They can also be defined and/or declared in other files in the program's project.
\end{definition}

It important to note the difference between a \nameref{def:Global_Variable}'s declaration and definition.
\begin{itemize}[noitemsep]
\item Declaration: The \nameref{def:Variable_Type}s and attributes are bound, but the \nameref{def:Memory} space required is \textbf{not} allocated.
\item Definition: The \nameref{def:Variable_Type}s and attributes are bound, but the \nameref{def:Memory} space required \textbf{is} allocated.
\end{itemize}

\begin{remark*}
  This is a highly language-dependent thing, and one must consult with the language specification to figure out exactly how it works.
\end{remark*}

\subsection{Referencing Environments}\label{subsec:Referencing_Environments}
\begin{definition}[Referencing Environment]\label{def:Referencing_Environment}
  The \emph{referencing environment} of a statement is the collection of all \nameref{def:Variable}s that are visible in the statement.
\end{definition}

\subsubsection{\nameref*{subsec:Referencing_Environments} in Languages with \nameref*{subsubsec:Static_Scope}}\label{subsubsec:Static_Scope_Referencing_Environment}
In a language that uses \nameref{subsubsec:Static_Scope}ing, the referencing environment includes all \nameref{def:Local_Variable}s in its \nameref{def:Variable_Scope} and all \nameref{def:Variable}s in the \nameref{def:Variable_Static_Ancestor} scopes that are \nameref{def:Visible_Variable}.
This also includes all function definitions and \nameref{def:Global_Variable}s up to that point.

The code block below and \Cref{tab:Static_Scope_Referencing_Environment-Execution} illustrate how a \nameref{def:Referencing_Environment} behave in a language that uses \nameref{def:Static_Scoping}.

\begin{minted}[frame=lines,linenos]{python3}
g = 3  # A global variable
def sub1():
    a = 5  # Create a local variable
    b = 7  # Create another local variable
    ...    # EXECUTION POINT 1
    def sub2():
        global g  # The global variable g is assignable here now
        c = 9 # Create a new local variable
        ...  # EXECUTION POINT 2
        def sub3():
            nonlocal c:  # Makes the nonlocal variable "c" visible here
            g = 11;
            ...  # EXECUTION POINT 3
\end{minted}

\begin{table}[h!]
  \centering
  \begin{tabular}{cl}
    \toprule
    Execution Point & \multicolumn{1}{c}{Referencing Environment} \\
    \midrule
    1 & Locals \texttt{a} and \texttt{b} of \texttt{sub1}, the global \texttt{g}, for reference and not assignment \\
    2 & Local \texttt{c} of \texttt{sub2}, the global \texttt{g} for reference and assignment (\texttt{global} \nameref{def:Reserved_Word}) \\
    3 & Local \texttt{g} of \texttt{sub3}, the nonloca \texttt{c} of \texttt{sub2} (\texttt{nonlocal} \nameref{def:Reserved_Word}) \\
    \bottomrule
  \end{tabular}
  \caption{\nameref{def:Referencing_Environment} of a Statically Scoped Program}
  \label{tab:Static_Scope_Referencing_Environment-Execution}
\end{table}

\subsubsection{\nameref*{subsec:Referencing_Environments} in Languages with \nameref*{subsubsec:Dynamic_Scope}}\label{subsubsec:Dynamic_Scope_Referencing_Environment}
In a language that uses \nameref{subsubsec:Dynamic_Scope}ing, the referencing environment includes all the \nameref{def:Local_Variable}s, the \nameref{def:Variable}s of all other \nameref{def:Subprogram_Active} subprograms, and the subprogram names.
This means that some \nameref{def:Variable}s in \nameref{def:Subprogram_Active} subprograms can be hidden from the referencing environment.

The code block below and \Cref{tab:Dynamic_Scope_Referencing_Environment-Execution} illustrate how a \nameref{def:Referencing_Environment} behave in a language that uses \nameref{def:Dynamic_Scoping}.

\begin{minted}[frame=lines,linenos]{c++}
void sub1() {
  int a, b;
  ...       // EXECUTION POINT 1
}
void sub2() {
  int b, c;
  ...       // EXECUTION POINT 2
  sub1();
}
void main() {
  int c, d;
  ...       // EXECUTION POINT 3
  sub2();
}
\end{minted}

\begin{table}[h!]
  \centering
  \begin{tabular}{cl}
    \toprule
    Execution Point & \multicolumn{1}{c}{Referencing Environment} \\
    \midrule
    1 & \texttt{a} and \texttt{b} of \texttt{sub1}, \texttt{c} of \texttt{sub2}, \texttt{d} of \texttt{main} \\
                    & \texttt{c} of \texttt{main} is hidden by \texttt{sub2} and \texttt{b} of \texttt{sub2} hidden by \texttt{sub1} \\
    2 & \texttt{b} and \texttt{c} of \texttt{sub2}, \texttt{d} of \texttt{main} \\
                    & \texttt{c} of \texttt{main} is hidden by \texttt{sub2} \\
    3 & \texttt{c} and \texttt{d} of \texttt{main} \\
    \bottomrule
  \end{tabular}
  \caption{\nameref{def:Referencing_Environment} of a Dynamically Scoped Program}
  \label{tab:Dynamic_Scope_Referencing_Environment-Execution}
\end{table}

\begin{definition}[Active]\label{def:Active}
  A subprogram is \emph{active} if its execution has begin, but not yet terminated.
\end{definition}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
