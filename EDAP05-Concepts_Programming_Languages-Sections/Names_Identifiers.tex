\section{Names}\label{sec:Names}
\emph{Names} or \emph{identifiers} are, obviously, names given to things.
They can identify:
\begin{itemize}[noitemsep]
\item Variables
\item Subprograms
\item Formal Parameters
\item Other program constructs
\end{itemize}

\subsection{Issues}\label{subsec:Names_Issues}
There are 2 questions that need to be asked when designing the names or identifiers possible in a language.
\begin{enumerate}[noitemsep]
\item Are names case-sensitive? For example, are these identifiers different?
  \begin{itemize}[noitemsep]
  \item \texttt{myvariable}
  \item \texttt{MYVARIABLE}
  \item \texttt{MyVariable}
  \item \texttt{myVariable}
  \end{itemize}
\item Are the special words of the language \nameref{def:Reserved_Word}s or are they \nameref{def:Keyword}s?
\end{enumerate}

\subsection{Name Forms}\label{subsec:Name_Forms}
How is a name/identifier defined?
\begin{itemize}[noitemsep]
\item Is there a character limit on the identifier/name?
\item Are all characters in the identifier/name significant?
\item What characters are allowed in the identifier/name?
\item Are there special characters required by a language?
  \begin{itemize}[noitemsep]
  \item \texttt{\$} being required in front of identifiers in PHP
  \item \texttt{\$}, \texttt{@}, \texttt{\%} specifying a ``type''  in Perl
  \item \texttt{@} and \texttt{@@} to denote an instance or class variable in Ruby, respectively
  \end{itemize}
\end{itemize}

Some languages are \emph{case-sensitive}.
C, Java, C++, etc.\ would all treat \texttt{rose}, \texttt{ROSE}, and \texttt{Rose} differently.
This could be a detriment to readability, because names that \textit{look} similar are actually not.
In terms of writability, the programmer must remember the exact typecasing of the identifier/name.

\subsection{Special Names}\label{subsec:Special_Names}
There are \nameref{def:Reserved_Word}s and \nameref{def:Keyword}s.
They are similar in that the programming language specification defines that these words have special meanings when constructing programs.
However, the 2 differ in how these words can potentially be reused.

\begin{definition}[Keyword]\label{def:Keyword}
  \emph{Keyword}s are words that are defined by the language constructors to have some special meaning.
  However, it only has these special meanings in \textbf{\emph{certain contexts}}.
  This means you can define a keyword as a variable and use it together with the keyword.
  For example, this is a perfectly valid piece of Fortran code:
\begin{minted}[frame=lines,linenos]{fortran}
Integer Apple
Integer = 4
\end{minted}
\end{definition}

\begin{definition}[Reserved Word]\label{def:Reserved_Word}
  \emph{Reserved word}s are words that are reserved by the language constructors because those particular words have a meaning in the language.
  These words cannot be used as identifiers for \textbf{ANYTHING} else.
  For example:
  \begin{itemize}[noitemsep]
  \item \texttt{while}
  \item \texttt{class}
  \item \texttt{for}
  \end{itemize}

  \begin{remark}[Too Many \nameref{def:Reserved_Word}s]\label{rmk:Too_Many_Reserved_Words}
    The potential problem with \nameref{def:Reserved_Word}s is that if a language has a large number of reserved words, the user might have a hard time creating names for themselves.
    Unfortunately, the most commonly chosen words by programs are usually \nameref{def:Reserved_Word}s.
    For example,
    \begin{itemize}[noitemsep]
    \item \texttt{LENGTH}
    \item \texttt{BOTTOM}
    \item \texttt{DESTINATION}
    \item \texttt{COUNT}
    \end{itemize}
  \end{remark}
\end{definition}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Names_Identifiers/Variables}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Names_Identifiers/Binding}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Names_Identifiers/Scope}

\input{./EDAP05-Concepts_Programming_Languages-Sections/Names_Identifiers/Referencing_Environments}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Reference_Sheet"
%%% End:
