\section{Syntax}\label{sec:Syntax}
Syntax describes the possible structure (or form) of programs of a given programming language.
Backus-Naur Form (BNF) grammars have emerged as the standard mechanism for describing language syntax.
BNF grammars used to describe languages when communicating with language adopters and compiler implementors.
There are also many tools (particularly the yacc and antlr families of programs) for automatically generating parsers, programs that recognise whether an input program matches a grammar and, if it does, execute user-defined actions upon encountering certain language constructs.

\subsection{}
You should be able to determine whether a given property of a language is part of the syntax, of the static semantics, or of the dynamic semantics.

\begin{itemize}
\item Syntax --- This is done with the context-free grammar and parsing the input symbols
\item Static Semantics --- This is done during the implementation of the compiler/interpreter. These define some of the operations possible and how they should behave.
  \begin{itemize}[noitemsep]
  \item For example, the \texttt{+} operator must be defined to mean addition when given integers and concatenation when given strings.
  \item It is required that the syntax be defined and relatively fixed for the semantics to be well-defined.
  \end{itemize}

\item Dynamic Semantics --- This is done while the program is running. These determine the behaviors of the operators while the program is in-use.
\end{itemize}

\subsection{}
You should be able to read a BNF grammar and understand the difference between terminals and nonterminals.

\begin{itemize}
\item Terminals --- Symbols that represent a terminating point in the recursion.
  \begin{itemize}[noitemsep]
  \item Typically, these are symbols that mean we have reached the end of our recursion.
  \item In a programming language, these are usually keywords.
  \item In this course, they are typically symbols that lack the $\langle$ and $\rangle$.
  \end{itemize}

\item Nonterminals --- Symbols that continue the recursion of a production to another production with the same symbol.
  \begin{itemize}[noitemsep]
  \item These are things used to construct a parse tree of what we have input to the parser/grammar.
  \item In this course, they are typically denoted as $\langle A \rangle$.
  \end{itemize}
\end{itemize}

\subsection{}
Given a BNF grammar, you should be able to write down examples of programs that can be generated by the grammar.

\begin{itemize}[noitemsep]
\item This means you must be able to run through and recurse through the grammar.
\end{itemize}

\subsection{}
Given a BNF grammar, you should be able to tell whether a given program can be generated by the grammar. If the program is generated by the grammar, you should also be able to generate a parse tree for the program.

\begin{itemize}[noitemsep]
\item Essentially, you must run the grammar on the given program and confirm whether the program could be accepted/generated by the grammar.
\end{itemize}

\subsection{}
You should be able to determine whether a given (small) BNF grammar is ambiguous (the problem is undecidable in general, so this skill only pertains to practically relevant examples as covered in the textbook).

\begin{itemize}[noitemsep]
\item There needs to be more than one way to generate a parse tree given a grammar.
\end{itemize}

\subsection{}
Given a BNF grammar, you should be able to determine the associativity of any operator used therein.

\begin{itemize}[noitemsep]
\item Left associative operators are left-recursive in their grammar, so the parentheses build up towards the left, with the first operation to be performed deepest in the parse tree on the left, with all subsequent operations higher in the tree and to the right.
\item Right associative operators are right-recursive in their grammar, so the parentheses build towards the right, with the first operation to be performed deepest in the parse tree to the right, with all subsequent operation higher in the tree and to the left.
\end{itemize}

\subsection{}
You should be able to describe the difference between an object language and a meta-language.

\begin{itemize}
\item Object language --- A language that is used for something, for example, C. These can be meta-languages in some cases.
\item Meta-language --- A language that describes other languages, Context-free grammars, for example.
\end{itemize}

\subsection{}
Understand \textbf{arity}, \textbf{fixity}, and \textbf{precedence}, and \textbf{associativity} of operators

\begin{itemize}
\item Arity
  \begin{enumerate}[noitemsep]
  \item Unary --- An operator that takes a single argument. Logical NOT is an example of this, as well as \texttt{i++}.
  \item Binary --- An operator that takes 2 arguments. Most mathematical and logical operations are like this.
  \item Ternary --- An operator that takes 3 arguments. The ternary \texttt{if} operator is an example of this.
  \end{enumerate}

\item Fixity
  \begin{itemize}[noitemsep]
  \item Prefix --- Operator symbol before arguments, $+\, 3\, 2 = 5$
  \item Infix --- Operator symbol between arguments, $3 + 2 = 5$
  \item Postfix --- Operator symbol after arguments, $3\, 2\, + = 5$
  \end{itemize}

\item Precedence
  \begin{itemize}[noitemsep]
  \item Given several operators in a single line, which one should have the highest priority?
  \item Only way to figure this out is to run tests which force certain operations to have mutually disjoint outputs. Meaning for some inputs, you will get different outputs for operations with different precedences.
  \end{itemize}

\item Associativity
  \begin{itemize}[noitemsep]
  \item Given several operators of the same precedence, what order should they be evaluated in?
  \item Most mathematical and logical operators are left-associative, meaning they should be left-recursive in their grammar.
  \item The exceptions to this are exponentiation and function types, which are right-associative, and thus must be right-recursive in their grammar.
  \end{itemize}
\end{itemize}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAP05-Concepts_Programming_Languages-Skills"
%%% End:
