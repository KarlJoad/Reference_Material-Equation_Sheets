\section{Syntax}\label{sec:Syntax}
The C language helped define a whole class of syntax that is used by many programming languages today.
C's syntactic decisions can be seen in Java, Rust, C++, C\#, and many others.

\subsection{Primitive Types}\label{subsec:Primitive_Types}
C has just 4 primitive types:
\begin{description}[noitemsep]
\item[\cinline{char}:] \textbf{One byte} integers (0--255), meant to represent ASCII characters.
\item[\cinline{int}:] Integers, which is defined to be \textit{at least} 16 bits.
  \begin{itemize}[noitemsep]
  \item Additional prefixes can be used to increase or decrease the range of the integer.
  \item These are shown in \Cref{subsubsec:Integer_Type_Prefixes}.
  \end{itemize}
\item[\cinline{float}:] Single precision IEEE floating point number.
\item[\cinline{double}:] Double precision IEEE floating point number.
\end{description}

\subsubsection{Integer Type Prefixes}\label{subsubsec:Integer_Type_Prefixes}
\begin{description}[noitemsep]
\item[\cinline{signed}:] The default for integers, meaning you \textbf{do not} have to specify this.
  Can represent both negative and positive integers.
  The range for this is $-2^{\text{\# bits} - 1}$--$2^{\text{\# bits} - 1}-1$
\item[\cinline{unsigned}:], Can only represent 0 and positive integers.
  Its range is $0$--$2^{\text{\# bits}}$
\item[\cinline{short}:] Tells the compiler that the integer must be at least 16 bits.
\item[\cinline{long}:] Tells the compiler that the integer must be at least 32 bits.
\item[\cinline{long long}:] Tells the compiler that the integer must be at least 64 bits.
\end{description}

\input{./C_Primer-Sections/Syntax/Basic_Operators}

\input{./C_Primer-Sections/Syntax/Control_Flow}

\subsection{Variables}\label{subsec:Variables}
Because C is a statically typed language, the type of every expression \textbf{MUST} be known before or during compilation.
In addition, C compilers do not have any type inferencing, so you \textbf{MUST} explicitly tell the compiler the type of your variables.
This means that you \textbf{MUST} declare before use.
It is important to note that the declaration implicitly allocates storage for the data that will be stored.

One thing that will come up throughout this section is the concept of aliveness and scope.
It is import to note that variables do \textbf{not} have to be in-scope to be alive, and vice versa.

\subsubsection{Visibility}\label{subsubsec:Variable_Visibility}
Visibility or \emph{scope} is where a symbol can be seen from.
If the symbol cannot be seen, then it cannot be used in any way

In addition, we need to ask \textit{how} we can refer to the symbol.
This includes what kid of identifiers/modifiers/namespacing is needed to identify the symbol in question.

\paragraph{Global Variables}\label{par:Global_Variables}
They \textbf{MUST} be declared outside any function.
These are not deallocated \textbf{AT ANY TIME} during a program's execution, as they are always in-scope, however the variable may not be alive.
Additionally, these are \textbf{ALWAYS} available, until the program terminates.

Using global variables is typically bad practice as this can introduce weird and hard-to-debug errors into a program.
So, most variables that you will use will be local variables.
Local variables are limited to the scope they were created within.
Typically, the scope is a function, but can be an \texttt{if}, a \texttt{while}, etc.

\paragraph{\texorpdfstring{\cinline{extern}}{\texttt{extern}} Variables}\label{par:extern_Variables}
\cinline{extern} is used to denote a variable that is external to this program.
This means the variable in question is a global variable in another file

The opposite of the \cinline{extern} keyword is the \cinline{static} keyword, which limits the scope of a symbol to the file it is declared in.
In addition, when the variable is declared to be \cinline{static}, the value lasts throughout the program's execution, ensuring the variable is always available.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../C_Primer"
%%% End:
