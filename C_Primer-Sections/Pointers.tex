\section{Pointers}\label{sec:Pointers}
This should technically go in \Cref{sec:Syntax}, but pointers deserve their own section.

\begin{definition}[Pointer]\label{def:Pointer}
A \emph{pointer} is a variable declared to store a memory address.
With this memory address, we can refer to data in-memory.
The size of the pointer is determined by the architecture of the CPU.\@
\end{definition}

A pointer is designated by its \textbf{DECLARED} type, \textbf{NOT} its contents.
This allows the data the pointer points to to be re-interpreted based on the declared type of the pointer.
This is shown in \Cref{lst:Pointers_Reinterpret_Data}.

\begin{listing}[h!tbp]
\csourcefile{./C_Primer-Sections/Pointers/Code/pointers-reinterpret-data.c}
\caption{Pointers Reinterpret Data}
\label{lst:Pointers_Reinterpret_Data}

\begin{minted}[frame=lines,linenos]{console}
$ ./a.out
ip: 63
cp: ?
fp: 0.000000
\end{minted}
\end{listing}

\subsection{Pointer Syntax}\label{subsec:Pointer_Syntax}.
The syntax that \nameref{def:Pointer}s use can sometimes be confusing for new programmers.
So, we will break down each portion of a pointer and its usage to more fully understand them.

\subsubsection{Declaration}\label{subsubsec:Pointer_Declaration}
\nameref{def:Pointer}s are declared using the same type name as the data type they will store.
In addition, you \textbf{MUST} add a \cinline{*} to the declaration.
The placement of this symbol does not matter, but for clarity, most programmers put it on the variable name.
However, it can be attached to the type as well.

\Cref{lst:Pointer_Declaration} shows how to do this.
\begin{listing}[h!tbp]
\csourcefile{./C_Primer-Sections/Pointers/Code/pointer-declaration.c}
\caption{Pointer Declaration}
\label{lst:Pointer_Declaration}
\end{listing}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../C_Primer"
%%% End:
