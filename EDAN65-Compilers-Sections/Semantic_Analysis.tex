\section{Semantic Analysis}\label{sec:Semantic_Analysis}
This is the time where we can start attaching some meaning to the tokens that we have read.
We can attach types to the tokens to note that they are number literals, variables, identifiers, expressions, etc.
This will begin the portion of the compiler where we have read in our program and now we need to start making sure that it makes sense.

To improve modularity, it is better to seaparate issues of syntax (parsing) from issues of semantics (type-checking and translation to machine code).

\subsection{Visitors}\label{subsec:Visitors}
\nameref{def:Visitors} are an example of ``The Expression Problem''.
This problem states that we would like to:
\begin{itemize}[noitemsep]
\item Define \emph{language constructs} in a modular way (Java Class Hierarchy)
\item Define \emph{computations} in a modular way (On those Classes)
\item \emph{Compose} these modules as we like
\item Be able to \emph{separately compile} these modules
\item Have full \emph{static type safety} (No need for typecasting or instanceof)
\end{itemize}

The Expression Problem contains:
\begin{itemize}[noitemsep]
\item \textit{Kinds} of objects: compound statements, assignment statements, print statements, etc.
\item \textit{Interpretations} of these objects: type-checking, translate to other code, optimize, interpret, etc.
\end{itemize}

This means there are 2 ``methods'' to solve The Expression Problem:
\begin{enumerate}[noitemsep]
\item Separate your \nameref{def:Abstract_Syntax} from your interpretation.
  This makes it easy and modular to:
  \begin{itemize}[noitemsep]
  \item Add a new interpretation, because they are all logically grouped together
  \item However, it is hard to add a new kind of interpretation, because you need to add new functions to all existing interpretations
  \end{itemize}
\item Tie your \nameref{def:Abstract_Syntax} to your interpretations
  \begin{itemize}[noitemsep]
  \item Easy to add new kind. All the interpretations of that kind are grouped together as methods of the new kind.
  \item Not modular to add a new interpretation, a new method must be added to every class
  \end{itemize}
\end{enumerate}

These require your language to support static aspects, and Java natively doesn't.
You would need another language like AspectJ or JastAdd.

So, to deal with The Expression Problem, there are a few options:
\begin{enumerate}[noitemsep]
\item Edit the AST classes
  \begin{itemize}[noitemsep]
  \item Doesn't actually solve the problem
  \item Non-modular
  \item Non-compositional
  \item \textbf{BAD IDEA TO EDIT GENERATED CODE}
  \item However, sometimes this is done in industry
  \end{itemize}
\item \nameref{def:Visitors}
  \begin{itemize}[noitemsep]
  \item An Object-Oriented design pattern
  \item Modularize through clever indirect function/method calls
  \item Not full modularization
  \item No composition
  \item Supported by many parser generators
  \item Reasonably useful, commonly used in industry
  \end{itemize}
\item Static Aspect-Oriented Programming (AOP)
  \begin{itemize}[noitemsep]
  \item Also known as \textit{Inter-Type Declarations (ITDs)}
  \item Use new language constructs (aspects) to factor out code
  \item Solves The Expression Problem in a nice simple way
  \item Drawback: You need a new language
    \begin{itemize}[noitemsep]
    \item AspectJ
    \item JastAdd
    \end{itemize}
  \end{itemize}
\item Advanced Language Constructs
  \begin{itemize}[noitemsep]
  \item Use more advanced language constructs:
    \begin{itemize}[noitemsep]
    \item Virtual Classes in bgeta
    \item Traits in Scala
    \item Typeclasses in Haskell
    \end{itemize}
  \item Drawbacks:
    \begin{itemize}[noitemsep]
    \item More complex than Static Aspect-Oriented Programming
    \item You need an advanced language
    \item Not much practical experience (so far)
    \end{itemize}
  \end{itemize}
\end{enumerate}

\begin{definition}[Visitors]\label{def:Visitors}
  \emph{Visitors} are used to modularize compilers in Java, or any other Object-Oriented language without Aspect-Oriented Programming mechanisms.
  ``The Visitor design pattern lets you define a new operation without changing the elements on which it operates'' \parencite{ElementsReusableObjectOrientedSoftware1994}.

  The Visitor pattern is a technique to use the \nameref{def:Abstract_Syntax}-separate-from-interpretation style.

  A visitor implements an interpretation; it is an object which contains a \texttt{visit} method for each \nameref{def:Abstract_Parse_Tree} class.
  Each \nameref{def:Abstract_Parse_Tree} should contain an \texttt{accept} method, which serves a hook for all interpretations.
  It is called by a visitor and passes control back to an appropriate method of the visitor.

  This can be thought of as a dialogue between the \nameref{def:Abstract_Parse_Tree} class and the visitor class.
  The visitor calls the \texttt{accept} method of a node and asks ``What is your class?''
  The \texttt{accept} method answers by calling the corresponding \texttt{visit} method from the visitor.

  These \texttt{visit} methods are usually overloaded for the various types present in the \nameref{def:Abstract_Parse_Tree}, further increasing code modularity.
\end{definition}

\begin{table}[h!]
  \centering
  \begin{tabular}{ccc}
    \toprule
    & Frequent type-casts? & Frequent recompilation? \\
    \midrule
    \texttt{Instanceof} and type-casts & Yes & No \\
    Dedicated methods & No & Yes \\
    The Visitor Pattern & No & No \\
    \bottomrule
  \end{tabular}
  \caption{Summary of the \nameref{def:Visitors} Pattern}
  \label{tab:Visitor_Pattern_Summary}
\end{table}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAN65-Compilers-Reference_Sheet"
%%% End:
