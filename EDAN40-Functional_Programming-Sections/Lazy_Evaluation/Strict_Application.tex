\subsection{Strict Application}\label{subsec:Strict_Application}
Haskell uses \nameref{def:Lazy_Evaluation} by default, but also provides a special \nameref{def:Strict} version of \nameref{def:Function} application, written as \texttt{\$!}, which can be useful.

\begin{definition}[Strict]\label{def:Strict}
  \emph{Strict} function application, in Haskell, means that the specified argument provided to the \nameref{def:Function} is evaluated with \nameref{subsec:Pass_by_Value}, rather than \nameref{subsec:Pass_by_Name}.

  Formally, an expression of the form \haskellinline{f $! x} is only a \nameref{def:Reducible_Expression} once evaluation of the argument \texttt{x}, which itself uses \nameref{def:Lazy_Evaluation}, has reached the point where it is known that the result is not an undefined value.
  At that point the expression can be reduced to the normal application \haskellinline{f x}.
\end{definition}

\begin{itemize}[noitemsep]
\item If the argument has a basic type, such as \texttt{Int} or \texttt{Bool}, then top-level evaluation is simply complete evaluation.
\item For a \nameref{def:Tuple} type such as \texttt{(Int, Bool)}, evaluation is performed until a pair of expressions is obtained, but no further.
\item For a \nameref{def:List} type, evaluation is performed until the empty list or the cons of two expressions is obtained.
\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
