\subsection{Language Basics}\label{subsec:Lang_Basics}
All of the functions and operations presented below come from \textbf{The Standard Prelude}.
The library file \emph{Prelude.hs} is loaded first by the REPL (Read, Evaluate, Print, Loop) environment that we will use.
It defines:
\begin{itemize}[noitemsep]
\item \nameref{subsubsec:Math_Ops}
\item \nameref{subsubsec:List_Ops}
\item And other conveniences for writing Haskell.
\end{itemize}

\subsubsection{Mathematical Operations}\label{subsubsec:Math_Ops}
\emph{Prelude.hs} defines the basic mathematical \textbf{integer} functions of:
\begin{itemize}[noitemsep]
\item Addition
\item Subtraction
\item Multiplication
\item Division
\item Exponentiation
\end{itemize}
\begin{listing}[h!tbp]
\begin{haskellsource}
> 2+3
5
> 2-3
-1
> 2*3
6
>7 `div` 2
3
> 2^3
8
\end{haskellsource}
\caption{Integer Mathematical Operations}
\label{lst:Int_Math_Ops}
\end{listing}

\paragraph{Precedences}\label{par:Math_Precedences}
Just like in normal mathematics, there exists a precedence to disambiguate mathematical expressions containing multiple, different operations.
In order of highest-to-lowest precedence:
\begin{enumerate}[noitemsep]
\item Negation
\item Exponentiation
\item Multiplication and Division
\item Addition and Subtraction
\end{enumerate}

\paragraph{Associativity}\label{par:Math_Associativity}
Just like in normal mathematics, there are rules associativity rules to disambiguate mathematical expressions containing multiple of the same operations.
There are only 2 types of associativity, left and right.
\begin{enumerate}[noitemsep]
\item Left Associative:
  \begin{itemize}[noitemsep]
  \item Everything else.
  \item Addition. $2+3+4 = (2+3)+4$
  \item Subtraction. $2-3-4 = (2-3)-4$
  \item Multiplication. $2*3*4 = (2*3)*4$
  \item Division. $2 \div 3 \div 4 = (2 \div 3) \div 4$
  \end{itemize}
\item Right Associative:
  \begin{itemize}[noitemsep]
  \item Exponentiation. $2^{3^{4}} = 2^{(3^{4})}$
  \item Negation. $--2 = -(-2) = 2$
  \end{itemize}
\end{enumerate}

\begin{remark*}[Types of Associativity]
  Technically, there are 3 types of associativity.
  \begin{enumerate}[noitemsep]
  \item Left-Associative
  \item Right-Associative
  \item Non-Associative
  \end{enumerate}

  Non-associativity means that it does not have an implicit associativity rule associated with it.
  It could also mean it is neither left-, nor right-associative.
\end{remark*}

\subsubsection{List Operations}\label{subsubsec:List_Ops}
\emph{Prelude.hs} also defines the basic list operations that we will need.
To denote a list in Haskell, the elements are comma-delimited inside of square braces.
For example, the mathematical list (set) of integers 1 to 3 $\lbrace 1, 2, 3 \rbrace$ is written in Haskell like so \haskellinline{[1, 2, 3]}.

Lists are a homogenous data structure.
It stores several \textbf{elements of the same type}.
So, we can have a list of integers or a list of characters but we can't have a list with both integers and characters.
The most common list operations are shown below.

\paragraph{\texorpdfstring{\haskellinline{head}}{\texttt{head}}}\label{par:List_Head_Function}
Get the \emph{head} of a list. Return the first element of a non-empty list. Remove all elements other than the first element.
If the list \textbf{is} empty, then an Exception is returned.
See \Cref{lst:List_Head_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > head [1, 2, 3, 4, 5]
  1
\end{haskellsource}
\caption{Haskell \haskellinline{head} Function}
\label{lst:List_Head_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{tail}}{\texttt{tail}}}\label{par:List_Tail_Function}
Get the \emph{tail} of a list. Return the second through $n$th elements of a non-empty list. Remove the first element.
If the list \textbf{is} empty, then an Exception is returned.
See \Cref{lst:List_Tail_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > tail [1, 2, 3, 4, 5]
  [2, 3, 4, 5]
\end{haskellsource}
\caption{Haskell \haskellinline{tail} Function}
\label{lst:List_Tail_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{last}}{\texttt{last}}}\label{par:List_Last_Function}
Get the \emph{last} element in a list.
See \Cref{lst:List_Last_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > last [1, 2, 3, 4, 5]
  5
\end{haskellsource}
\caption{Haskell \haskellinline{last} Function}
\label{lst:List_Last_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{init}}{\texttt{init}}}\label{par:List_Init_Function}
Get the \emph{init}ial portion of the list, namely all elements except the last one.
See \Cref{lst:List_Init_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > init [1, 2, 3, 4, 5]
  [1, 2, 3, 4]
\end{haskellsource}
\caption{Haskell \haskellinline{init} Function}
\label{lst:List_Init_Function}
\end{listing}

\paragraph{\texorpdfstring{Selection, \haskellinline{!!}}{Selection, \texttt{!!}}}\label{par:List_Select_Function}
Select the $n$th element of a list. Lists in Haskell are zero-indexed.
See \Cref{lst:List_Select_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > [1, 2, 3, 4, 5] !! 2
  3
\end{haskellsource}
\caption{Haskell \haskellinline{!!} Function}
\label{lst:List_Select_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{take}}{\texttt{take}}}\label{par:List_Take_Function}
\emph{Take} the first $n$ elements of a list.
See \Cref{lst:List_Take_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > take 3 [1, 2, 3, 4, 5]
  [1, 2, 3]
\end{haskellsource}
\caption{Haskell \haskellinline{take} Function}
\label{lst:List_Take_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{drop}}{\texttt{drop}}}\label{par:List_Drop_Function}
\emph{Drop} the first $n$ elements of a list.
See \Cref{lst:List_Drop_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > drop 3 [1, 2, 3, 4, 5]
  [4, 5]
\end{haskellsource}
\caption{Haskell \haskellinline{drop} Function}
\label{lst:List_Drop_Function}
\end{listing}

\paragraph{\texorpdfstring{Appending Lists to Lists, \haskellinline{++}}{Appending Lists to Lists}}\label{par:List_Append_Function}
Append the second list to the end of the first list.
See \Cref{lst:List_Append_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > [1, 2, 3, 4] ++ [9, 10, 11, 12]
  [1, 2, 3, 4, 9, 10, 11, 12]
\end{haskellsource}
\caption{Haskell \haskellinline{++} Function}
\label{lst:List_Append_Function}
\end{listing}

\begin{remark*}
  Be careful of this function.
  It runs in $O(n_{1})$-like time, where $n_{1}$ is the length of the first list.
\end{remark*}

\paragraph{\texorpdfstring{Constructing Lists, \haskellinline{:}}{\texttt{cons}tructing Lists}}\label{par:List_Cons_Function}
To construct lists, they need to be composed from single expressions.
This is done with the \texttt{cons} function.
See \Cref{lst:List_Cons_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > 8:[1, 2, 3, 4]
  [8, 1, 2, 3, 4]
\end{haskellsource}
\caption{Haskell \haskellinline{:} Function}
\label{lst:List_Cons_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{length}}{\texttt{length}}}\label{par:List_Length_Function}
To get the \emph{length} of a list, use \Cref{lst:List_Length_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > length [1, 2, 3, 4, 5]
  5
\end{haskellsource}
\caption{Haskell \haskellinline{length} Function}
\label{lst:List_Length_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{sum}}{\texttt{sum}}}\label{par:List_Sum_Function}
The \emph{sum} function is used to find the sum of all elements in a list.
See \Cref{lst:List_Sum_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > sum [1, 2, 3, 4, 5]
  15
\end{haskellsource}
\caption{Haskell \haskellinline{sum} Function}
\label{lst:List_Sum_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{product}}{\texttt{product}}}\label{par:List_Product_Function}
The \emph{product} function is used to find the product of all elements in a list.
See \Cref{lst:List_Product_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > product [1, 2, 3, 4, 5]
  120
\end{haskellsource}
\caption{Haskell \haskellinline{product} Function}
\label{lst:List_Product_Function}
\end{listing}

\paragraph{\texorpdfstring{\haskellinline{reverse}}{\texttt{reverse}}}\label{par:List_Reverse_Function}
The \emph{reverse} function is used to reverse the order of the elements in a list.
See \Cref{lst:List_Reverse_Function}.
\begin{listing}[h!tbp]
\begin{haskellsource}
  > reverse [1, 2, 3, 4, 5]
  [5, 4, 3, 2, 1]
\end{haskellsource}
\caption{Haskell \haskellinline{reverse} Function}
\label{lst:List_Reverse_Function}
\end{listing}

\subsubsection{Function Application}\label{subsubsec:Function_Application}
Like in mathematics, functions can be used in expressions, and are treated as first-class objects.
This means they have the same properties as regular variables, for almost all intents and purposes.
For example, the equation
\begin{equation*}
  f(a,b) + cd
\end{equation*}
would be translated to Haskell like so
\begin{haskellsource}
  f a b + c * d
\end{haskellsource}

To ensure that functions are handled in Haskell like they are in mathematics, they have the highest precedence in an expression.
This means that
\begin{haskellsource}
  f a + b
\end{haskellsource}
means
\begin{equation*}
  f(a) + b
\end{equation*}
in mathematics.

\Cref{tab:Function_Parens} illustrates the use of parentheses to ensure Haskell functions are interpretted like their mathematical counterparts.

\begin{table}[h!tbp]
  \centering
  \begin{tabular}{cc}
    \toprule
    Mathematics & Haskell \\
    \midrule
    $f(x)$ & \haskellinline{f x} \\
    $f(x, y)$ & \haskellinline{f x y} \\
    $f \bigl( g(x) \bigr)$ & \haskellinline{f (g x)} \\
    $f \bigl(x, g(y) \bigr)$ & \haskellinline{f x (g x)} \\
    $f(x) g(y)$ & \haskellinline{f x * g y} \\
    \bottomrule
  \end{tabular}
  \caption{Parentheses Used with Functions}
  \label{tab:Function_Parens}
\end{table}

Note that parentheses are still required in the Haskell expression \haskellinline{f (g x)} above, because \haskellinline{f g x} on its own would be interpreted as the application of the function \texttt{f} to two arguments \texttt{g} and \texttt{x}, whereas the intention is that \texttt{f} is applied to one argument, namely the result of applying the function \texttt{g} to an argument \texttt{x}.

\subsubsection{Haskell Files/Scripts}\label{subsubsec:Haskell_Scripts}
New functions can be defined within a script, a text file comprising a sequence of definitions.
By convention, Haskell scripts usually have a \texttt{.hs} file extension on their filename.

If you load a script into a REPL environment, the \emph{Prelude.hs} library is already loaded for you, so you can work with that directly.
To load a file, you use the \texttt{:load} command at the REPL.\@
Once loaded, you can call all the functions in the script at the REPL line.

If you edit the script, save it, and want your changes to be reflected in the REPL, you must \texttt{:reload} the REPL.\@

Some basic REPL commands are shown in \Cref{tab:Basic_REPL_Commands}

\begin{table}[h!tbp]
  \centering
  \begin{tabular}{ll}
    \toprule
    Command & Meaning \\
    \midrule
    \texttt{:load \emph{name}} or \texttt{:l \emph{name}} & Load script \texttt{\emph{name}} \\
    \texttt{:reload} or \texttt{:r} & Reload the current scripts \\
    \texttt{:type \emph{expr}} or \texttt{:t \emph{expr}} & Show the type of \texttt{\emph{expr}} \\
    \texttt{:?} & Show all possible commands\\
    \texttt{:quit} or \texttt{:q} & Quit the REPL \\
    \bottomrule
  \end{tabular}
  \caption{Basic REPL Commands}
  \label{tab:Basic_REPL_Commands}
\end{table}

\paragraph{Naming Conventions}\label{par:Naming_Conventions}
There are some conventions and requirements when it comes to naming expressions in Haskell.

\subparagraph{Function Naming Conventions}\label{subpar:Function_Naming_Conventions}
Functions \textbf{\emph{MUST}}:
\begin{itemize}[noitemsep]
\item Start with a \textbf{LOWER}-case letter
\item Every subsequent character in the name can be upper-, lower-case, a number, underscores, or single quotes (\texttt{'}).
\end{itemize}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
