\subsection{Function Types}\label{subsec:Function_Types}
\begin{definition}[Function]\label{def:Function}
  A \emph{function} a mapping from arguments of one \nameref{def:Type} to another.
  The type signature of a function is written $\mathtt{T_{1}} -> \mathtt{T_{2}}$.

  Some examples of functions are shown in \Cref{lst:Function_Examples}.

  \begin{remark}[Pureness of Definition]\label{rmk:Function_Definition_Pureness}
    This is the purest definition of a function, drawn right from mathematics.
    This interpretation forms the basis of \nameref{def:Functional_Programming_Language}s.
    This definition also prevents the introduction of side-effects, another basis for the developement of \nameref{def:Functional_Programming_Language}s.
  \end{remark}
\end{definition}

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Code/Function_Examples.hs}
\caption{Example of Functions in Haskell}
\label{lst:Function_Examples}
\end{listing}

Type signatures can be provided for a function, although the language system will typically figure out the most generic \nameref{def:Type}s possible for a function because of the \nameref{def:Type_Inferencing} system.
However, including them is good practice for documentation and for helping to write recursive functions.

\begin{blackbox}
  The only way to handle \textbf{MULTIPLE} parameters passed into and returned from a single function is to put them into either a \nameref{def:List} or \nameref{def:Tuple}.
\end{blackbox}

\begin{blackbox}
  There is \textbf{NO RESTRICTION} for a function to be \emph{total} on the arguments provided to a function, namely there may be some arguments for which the function is undefined.
\end{blackbox}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
