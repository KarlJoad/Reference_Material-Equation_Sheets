\subsection{Typeclasses}\label{subsec:Typeclasses}
\begin{definition}[Typeclass]\label{def:Typeclass}
  A \emph{typeclass} is a way to group \nameref{def:Type}s together and ensure that any \nameref{def:Type} in the same typeclass has the same operations available to it.
  This is a way to group together \nameref{def:Type}s that support certain overloaded functions, called methods.

  A single \nameref{def:Type} can belong to multiple typeclasses.
  Making typeclasses similar to interfaces from the OOP world.

  \begin{remark}[Class Constraint]\label{rmk:Class_Constraint}
    A \emph{class constraint} is a way to constrain the \nameref{def:Type}s that an expression can take.
    In this section, we discuss some of the basic \nameref{def:Typeclass}es that form these class constraints.
  \end{remark}

  \begin{remark}[Class vs. Typeclass]\label{rmk:Class_vs_Typeclass}
    In Haskell, \nameref{def:Typeclass}es are called \emph{class}es.
    I deliberately call them a different name to make it clear that we are not using the term class like used in Object-Oriented Programming.
  \end{remark}
\end{definition}

\subsubsection{\texorpdfstring{\haskellinline{Eq}}{\texttt{Eq}}}\label{subsubsec:Eq_Typeclass}
The \haskellinline{Eq} \nameref{def:Typeclass} contains \nameref{def:Type}s that can be compared for equality and inequality.
For a \nameref{def:Type} to be part of this class, they must provide the methods seen in \Cref{lst:Eq_Typeclass_Methods}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Code/Eq_Typeclass_Methods.hs}
\caption{\haskellinline{Eq} Typeclass Required Methods}
\label{lst:Eq_Typeclass_Methods}
\end{listing}

\textbf{ALL} the basic \nameref{def:Type}s are part of this \nameref{def:Typeclass}, including lists and tuples (if their elements are instances of types in this typeclass).
The only basic type that is \textbf{NOT} in this \nameref{def:Typeclass} are \nameref{def:Function}s, because there is no general way to compare two functions for equality.

\subsubsection{\texorpdfstring{\haskellinline{Ord}}{\texttt{Ord}}}\label{subsubsec:Ord_Typeclass}
The \haskellinline{Ord} \nameref{def:Typeclass} contains \nameref{def:Type}s that can be compared for relative value.
For a \nameref{def:Type} to be part of this class, they must provide the methods seen in \Cref{lst:Ord_Typeclass_Methods}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Code/Ord_Typeclass_Methods.hs}
\caption{\haskellinline{Ord} Typeclass Required Methods}
\label{lst:Ord_Typeclass_Methods}
\end{listing}

\textbf{ALL} the basic \nameref{def:Type}s are part of this \nameref{def:Typeclass}, including lists and tuples (if their elements are instances of types in this typeclass).
\haskellinline{String}s, lists, and tuples are ordered lexicographically, meaning they are sorted according to their first distinguishing element.
The only basic type that is \textbf{NOT} in this \nameref{def:Typeclass} are \nameref{def:Function}s, because there is no general way to compare two functions for their values.

\subsubsection{\texorpdfstring{\haskellinline{Show}}{\texttt{Show}}}\label{subsubsec:Show_Typeclass}
The \haskellinline{Show} \nameref{def:Typeclass} contains \nameref{def:Type}s that can be converted to a string of characters using the \haskellinline{show} function.
For a \nameref{def:Type} to be part of this class, they must provide the methods seen in \Cref{lst:Show_Typeclass_Methods}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Code/Show_Typeclass_Methods.hs}
\caption{\haskellinline{Show} Typeclass Required Methods}
\label{lst:Show_Typeclass_Methods}
\end{listing}

\textbf{ALL} the basic \nameref{def:Type}s are part of this \nameref{def:Typeclass}, including lists and tuples (if their elements are instances of types in this typeclass).
The only basic type that is \textbf{NOT} in this \nameref{def:Typeclass} are \nameref{def:Function}s, because there is no general way to show the value of a function.

\subsubsection{\texorpdfstring{\haskellinline{Read}}{\texttt{Read}}}\label{subsubsec:Read_Typeclass}
The \haskellinline{Read} \nameref{def:Typeclass} contains \nameref{def:Type}s whose values can be converted from strings of characters to values.
For a \nameref{def:Type} to be part of this class, they must provide the methods seen in \Cref{lst:Read_Typeclass_Methods}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Code/Read_Typeclass_Methods.hs}
\caption{\haskellinline{Read} Typeclass Required Methods}
\label{lst:Read_Typeclass_Methods}
\end{listing}

\textbf{ALL} the basic \nameref{def:Type}s are part of this \nameref{def:Typeclass}, including lists and tuples (if their elements are instances of types in this typeclass).
The only basic type that is \textbf{NOT} in this \nameref{def:Typeclass} are \nameref{def:Function}s, because there is no general way to show the value of a function.

\subsubsection{\texorpdfstring{\haskellinline{Num}}{\texttt{Num}}}\label{subsubsec:Num_Typeclass}
\subsubsection{\texorpdfstring{\haskellinline{Integral}}{\texttt{Integral}}}\label{subsubsec:Integral_Typeclass}
\subsubsection{\texorpdfstring{\haskellinline{Fractional}}{\texttt{Fractional}}}\label{subsubsec:Fractional_Typeclass}
%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
