\subsection{Curried Function Types}\label{subsec:Curried_Function_Types}
\nameref{def:Function}s with multiple arguments can be handled differently, if we are allowed to Curry functions and use \nameref{def:Higher_Order_Function}s.
If we can use those, then we can have a function take a function as an argument as return a function as a result.
So, instead of making \texttt{add} take 2 integers at once, we could instead give it just one, and that function will return another that adds the given value to the previously provided one.
An example is shown in \Cref{lst:Curried_Add_Example}

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Code/Curried_Add_Example.hs}
\caption{Curried Version of Addition}
\label{lst:Curried_Add_Example}
\end{listing}

There are some conventions regarding curried functions and their type signatures.
\begin{itemize}[noitemsep]
\item The arrow in function types are \emph{right associative}.
\item The application of arguments to a function is done with spacing, and is assumed to associate to the left.
\item Unless a function explicitly takes/returns a tuple as an argument/return value, functions are defined in their curried form.
\end{itemize}

\subsubsection{The Power of Currying}\label{subsubsec:Power_of_Currying}
All functions that could be expressed with tuple arguments can also be expressed by using functions that take functions as arguments and return functions as results.
Some functions that return tuples as results cannot always be converted to return functions, as some tuples is actual data.

Currying functions is important to allow for \nameref{def:Partial_Application}.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
