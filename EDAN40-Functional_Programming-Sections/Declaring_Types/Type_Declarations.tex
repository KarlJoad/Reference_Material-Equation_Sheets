\subsection{Type Declarations}\label{subsec:Type_Declarations}
The simplest way to define a new \nameref{def:Type} is to use a new name for an already existing type.
This is done with the \haskellinline{type} keyword in Haskell.
This keyword allows us to create \nameref{def:Type_Alias}es, making things easier to deal with.

\begin{definition}[Type Alias]\label{def:Type_Alias}
  A \emph{type alias} is the process of creating another name for an already existing \nameref{def:Type}.
  The langauge system can just ``replace'' each occurrence of a type alias with its definition until it has fully expanded the \nameref{def:Type}s until it has reached its base types.
  Type aliases can also be nested, allowing for one to define itself \textbf{IN TERMS OF ANOTHER}.

  \begin{remark}[Recursive Types]\label{rmk:Recursive_Type_Alias}
    \textbf{IT IS NOT POSSIBLE TO CONSTRUCT A RECURSIVE DATA TYPE USING A \nameref{def:Type_Alias}!!}
    That can only be done with the \haskellinline{data} keyword.
  \end{remark}
\end{definition}

Some examples of \nameref{def:Type_Alias}es used to create new \nameref{def:Type}s are shown in \Cref{lst:New_Types-Type}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/New_Types-Type.hs}
\caption{New Types Declared with \haskellinline{type}}
\label{lst:New_Type-Type}
\end{listing}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
