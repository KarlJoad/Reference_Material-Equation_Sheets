\subsection{Type Declarations}\label{subsec:Type_Declarations}
The simplest way to define a new \nameref{def:Type} is to use a new name for an already existing type.
This is done with the \haskellinline{type} keyword in Haskell.
This keyword allows us to create \nameref{def:Type_Alias}es, making things easier to deal with.

\begin{definition}[Type Alias]\label{def:Type_Alias}
  A \emph{type alias} is the process of creating another name for an already existing \nameref{def:Type}.
  The langauge system can just ``replace'' each occurrence of a type alias with its definition until it has fully expanded the \nameref{def:Type}s until it has reached its base types.
  Type aliases can also be nested, allowing for one to define itself \textbf{IN TERMS OF ANOTHER}.

  \begin{remark}[Recursive Types]\label{rmk:Recursive_Type_Alias}
    \textbf{IT IS NOT POSSIBLE TO CONSTRUCT A RECURSIVE DATA TYPE USING A \nameref{def:Type_Alias}!!}
    That can only be done with the \haskellinline{data} keyword.
  \end{remark}
\end{definition}

Some examples of \nameref{def:Type_Alias}es used to create new \nameref{def:Type}s are shown in \Cref{lst:New_Types-Type}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/New_Types-Type.hs}
\caption{New Types Declared with \haskellinline{type}}
\label{lst:New_Types-Type}
\end{listing}

Now, wherever there was a list of positions, we can replace \haskellinline{[Position]} with \haskellinline{Board}.
However, like mentioned in \Cref{rmk:Recursive_Type_Alias}, we cannot specify a recursive data \nameref{def:Type} with the \haskellinline{type} keyword.

\subsubsection{Parameterized Type Declarations}\label{subsubsec:Parameterized_Type_Declarations}
In addition to creating new \nameref{def:Type}s entirely, we can also parameterize them.
To do this, you must create a \emph{type function}.
Just like regular \nameref{def:Function}s, there is no limit to the number of parameters that is accepted.
Just like using normal \nameref{def:Type_Alias}es, parameterized ones also simplify the writing of programs with parametric dependencies.
All of these are shown in \Cref{lst:New_Types-Type_Parameterized}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/New_Types-Type_Parameterized.hs}
\caption{New Types Declared with \haskellinline{type}}
\label{lst:New_Types-Type_Parameterized}
\end{listing}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
