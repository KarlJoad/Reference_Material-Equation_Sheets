\subsection{Typeclass Declaration}\label{subsec:Typeclass_Declaration}
In Haskell, a new \nameref{def:Typeclass} can be defined with the \haskellinline{class} keyword.
For example, the standard library defines the \haskellinline{Eq} typeclass.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/Eq_Typeclass-Definition.hs}
\caption{Haskell's Standard Library Implementation of \haskellinline{Eq} Typeclass}
\label{lst:Eq_Typeclass_Definition}
\end{listing}

This states that for any \nameref{def:Type} \texttt{a} to be part of the \texttt{Eq} \nameref{def:Typeclass}, it must support the equality and inequality operators/functions.
Note that because of the way that inequality is defined, with its reliance on equality, only equality needs to be defined.
To add a \nameref{def:Type} to a \nameref{def:Typeclass}, the \haskellinline{instance} keyword is used.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/Eq_Typeclass-Instance.hs}
\caption{Haskell's \haskellinline{Bool} Instantiation with the \haskellinline{Eq} Typeclass}
\label{lst:Eq_Typeclass_Instance}
\end{listing}

Only \nameref{def:Type}s declared with the \haskellinline{data} keyword can be added to \nameref{def:Typeclass}es.
Ones declared with \haskellinline{type} inherit their typeclass information from their constiuent parts.

\subsubsection{Extending Typeclasses}\label{subsubsec:Extending_Typeclasses}
Sometimes it makes sense for a \nameref{def:Typeclass} to depend on another.
This is the case for the \haskellinline{Ord} typeclass, shown in \Cref{lst:Ord_Typeclass_Definition}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/Ord_Typeclass-Definition.hs}
\caption{Haskell's Standard Library Implementation of \haskellinline{Ord} Typeclass}
\label{lst:Ord_Typeclass_Definition}
\end{listing}

This means that for a \nameref{def:Type} to be added to the \haskellinline{Ord} \nameref{def:Typeclass}, it must instantiate the 6 methods defined in \haskellinline{Ord} and the 2 defined in \haskellinline{Eq}.

\subsubsection{Derived Instances}\label{subsubsec:Derived_Instances}
When creating new \nameref{def:Type}s, they are usually derived from built-in \nameref{def:Type}s, or \nameref{def:Type_Alias}ed ones, which themselves already belong to \nameref{def:Typeclass}es.
Instead of having to manually add our new \haskellinline{data} \nameref{def:Type} to every typeclass, we can instead derive from them.
An example involving the definition of the standard library's definition of \haskellinline{Bool} is shown in \Cref{lst:Bool_Derived_Instance}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/Derived_Instance-Bool.hs}
\caption{Derived Instance of Standard Library's \haskellinline{Bool} Type}
\label{lst:Bool_Derived_Instance}
\end{listing}

In addition to the simpler examples of unparameterized \nameref{def:Type_Constructor}s and \nameref{def:Type}s, we can also derive \nameref{def:Typeclass}es on parameterized types too.
This requires that the types used in as the types support those typeclasses in the first place.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/Derived_Instance-Shape.hs}
\caption{Derived Instance of \haskellinline{Shape} Type}
\label{lst:Shape_Derived_Instance}
\end{listing}

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/Derived_Instance-Maybe.hs}
\caption{Derived Instance of \haskellinline{Maybe} Type}
\label{lst:Maybe_Derived_Instance}
\end{listing}

\subsubsection{Monadic Types}\label{subsubsec:Monadic_Types}
A \nameref{def:Monad} can be seen by the \nameref{def:Typeclass} declaration seen in \Cref{lst:Monad_Declaration_Definition}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
