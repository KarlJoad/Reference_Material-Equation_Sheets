\subsection{Data Declarations}\label{subsec:Data_Declarations}
To declare a completely new \nameref{def:Type} with its own typechecking rules is done with the \haskellinline{data} keyword.
For example, the \haskellinline{Bool} \nameref{def:Type} is defined in the standard library as
\begin{haskellsource}
data Bool = False | True
\end{haskellsource}

The \texttt{|} symbol is read as ``or''.
Each of the new values is a \nameref{def:Type_Constructor}, \texttt{False} and \texttt{True} in this case.
The first letter of these constructors must be a capital letter, and constructor names must be unique to modules.
It is important to note that the constructor values, names, and the data type's name are all arbitrary.
The only way to attach any meaning to one of these constructor types is by defining functions on them.
For example, the below code is functionally identical to the definition of \haskellinline{Bool}.
\begin{haskellsource}
data A = B | C
\end{haskellsource}

\begin{definition}[Type Constructor]\label{def:Type_Constructor}
  A \emph{type constructor} is a function that constructs a new type in the compiler/runtime system.
\end{definition}

\Cref{lst:Data_Declaration-Simple} is a simple example of declare a new \nameref{def:Type} and functions to define it.
\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/Data_Declaration-Simple.hs}
\caption{Simple \haskellinline{data} Declaration and Definition}
\label{lst:Data_Declaration-Simple}
\end{listing}

\subsubsection{Parameterized Constructor Functions}\label{subsubsec:Parameterized_Constructor_Functions}
We can attach parameters to the constructor functions in a new \nameref{def:Type}.
An extended example of such a declaration and subsequent definition is shown in \Cref{lst:Data_Declaration-Parameterized_Constructors}.

\begin{listing}[h!tbp]
\haskellsourcefile{./EDAN40-Functional_Programming-Sections/Declaring_Types/Code/Data_Declaration-Parameterized_Constructors.hs}
\caption{Parameterized Constructors}
\label{lst:Data_Declaration-Parameterized_Constructors}
\end{listing}

In this case, \haskellinline{Circle 1.0} is an \nameref{def:Expression} that represents a piece of data.
It cannot be further simplified to anything.

\subsubsection{Parameterized Data Declarations}\label{subsubsec:Parameterized_Data_Declarations}
Just like in \Cref{subsubsec:Parameterized_Type_Declarations}, we can parameterize our \haskellinline{data} declarations as well.
These allow us to express some interesting things.
One example is the application of potentially error-causing functions without causing an error, and instead checking if a value is present.
This is demonstrated in \Cref{lst:Data_Declaration-Parameterized}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
