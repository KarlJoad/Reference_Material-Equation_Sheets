\subsection{Using Lambda Calculus}\label{subsec:Using_Lambda_Calculus}
When using \nameref{def:Lambda_Calculus}, there are some things to keep in mind.
\begin{enumerate}[noitemsep]
\item Reductions involve reducing or manipulating an expression somehow.
  There are 3 kinds of reductions, the first 2 being the most common.
  \begin{enumerate}[noitemsep]
  \item \nameref{def:Alpha_Conversion}
  \item \nameref{def:Beta_Reduction}
  \item \nameref{def:Eta_Reduction}
  \end{enumerate}
\item Computations in $\lambda$ calculus is performed by performing successive $\beta$-reductions whenever possible and for as long as possible.
\end{enumerate}

\begin{definition}[Alpha Conversion]\label{def:Alpha_Conversion}
  \emph{Alpha conversion} (\emph{$\alpha$-conversion}) is the process of replacing one variable name with another.
  For example, in the expression, $\lambda x. zx$, an $\alpha$-conversion of $x$ to $y$ results in $\lambda y. zy$.
\end{definition}

\begin{definition}[Beta Reduction]\label{def:Beta_Reduction}
  \emph{Beta reduction} (\emph{$\beta$-reduction}) is the process of following substitution rules defined by the $\lambda$ functions.
  For example, performing a $\beta$-reduction on $(\lambda n. n \times 2) 7$ results in the expression $7 \times 2$.
\end{definition}

\begin{definition}[Eta Reduction]\label{def:Eta_Reduction}
  \emph{Eta reduction} (\emph{$\eta$-reduction}) is a reduction of a $\lambda$ function to a single expression when the variable does not appear free.
  In practice, an $\eta$-reduction is the process of converting a regular function to Point-free form.
  For example, an $\eta$-reduction on $\lambda x. f x$ would yield $f$.
\end{definition}

There is a key theorem, the \nameref{thm:Church_Rosser_Theorem} that discusses the order of computation in \nameref{def:Lambda_Calculus}, namely that the order of computation does not matter.

\begin{theorem}[Church-Rosser Theorem]\label{thm:Church_Rosser_Theorem}
  The order of reductions does not matter, as there will always be some final reduction that is common to any path taken.
\end{theorem}

Discussed earlier, and now here, is the concept of \nameref{def:Normal_Form}.
Haskell tends to use \nameref{def:Weak_Head_Normal_Form}, but \nameref{def:Lambda_Calculus} only uses \nameref{def:Normal_Form}.
\begin{definition}[Normal Form]\label{def:Normal_Form}
  \emph{Normal form} is an expression that can have no more \nameref{def:Beta_Reduction} apply.
  This is equivalent to the halting state of a Turing Machine.
\end{definition}

However, not all terms have a \nameref{def:Normal_Form}.
These expressions correspond to non-halting computations in a Turing Machine.
An example is shown in \Cref{eq:No_Normal_Form}.
\begin{equation}\label{eq:No_Normal_Form}
  (\lambda x. x x) (\lambda x. x x)
\end{equation}

\Cref{eq:No_Normal_Form} cannot be reduced to a \nameref{def:Normal_Form} as the following derivation shows.
I have performed an \nameref{def:Alpha_Conversion} on the second lambda function, to make things clearer.
I went from $x$ to $y$.
\begin{align*}
  \intertext{Apply the $\lambda y$ expression as the variable $x$ in the $\lambda x$ expression.}
  (\lambda x. x x) (\lambda y. y y) &= (\lambda y. y y) (\lambda y. y y)
\end{align*}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
