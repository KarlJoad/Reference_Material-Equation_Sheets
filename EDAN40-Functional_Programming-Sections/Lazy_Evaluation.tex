\section{Lazy Evaluation}\label{sec:Lazy_Evaluation}
So far, the basic method of computation in Haskell has been the application of \nameref{def:Function}s to arguments.
Because these functions are pure, changing the order in which functions are applied does not affect the final result.
This is not specific to simple examples, but an important general property of function application in Haskell.
Formally, in Haskell any two different ways of evaluating the same expression will always produce the same final value, provided that they both terminate.

An \nameref{def:Expression} that has the form of a \nameref{def:Function} applied to one or more arguments that can be ``reduced'' by performing the application is called a \nameref{def:Reducible_Expression}

\begin{definition}[Reducible Expression]\label{def:Reducible_Expression}
  A \emph{reducible expression} or \emph{redex} has the form of a \nameref{def:Function} applied to one or more arguments that can be ``reduced'' by performing the appropriate function application.
  These reductions do not necessarily decrease the size of an \nameref{def:Expression}, but often do.
\end{definition}

Consider the expression \haskellinline{mult (1+2) (2+3)}.
This expression contains three redexes:
\begin{enumerate}[noitemsep]
\item The sub-expression 1 + 2, the \texttt{+} function applied with two arguments.
\item The sub-expression 2 + 3, the \texttt{+} function applied with two arguments.
\item The entire expression itself, which has the form of the function \texttt{mult} applied to a pair of arguments.
\end{enumerate}

Performing the corresponding reductions gives the expressions:
\begin{enumerate}[noitemsep]
\item \haskellinline{mult (3, 2 + 3)}
\item \haskellinline{mult (1 + 2, 5)}
\item \haskellinline{(1 + 2) * (2 + 3)}
\end{enumerate}

The order in which we evaluate these redexes determines what ``Pass-by'' type we use.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
