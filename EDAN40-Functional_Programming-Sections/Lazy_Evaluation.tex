\section{Lazy Evaluation}\label{sec:Lazy_Evaluation}
So far, the basic method of computation in Haskell has been the application of \nameref{def:Function}s to arguments.
Because these functions are pure, changing the order in which functions are applied does not affect the final result.
This is not specific to simple examples, but an important general property of function application in Haskell.
Formally, in Haskell any two different ways of evaluating the same expression will always produce the same final value, provided that they both terminate.

An \nameref{def:Expression} that has the form of a \nameref{def:Function} applied to one or more arguments that can be ``reduced'' by performing the application is called a \nameref{def:Reducible_Expression}

\begin{definition}[Reducible Expression]\label{def:Reducible_Expression}
  A \emph{reducible expression} or \emph{redex} has the form of a \nameref{def:Function} applied to one or more arguments that can be ``reduced'' by performing the appropriate function application.
  These reductions do not necessarily decrease the size of an \nameref{def:Expression}, but often do.
\end{definition}

Consider the expression \haskellinline{mult (1+2) (2+3)}.
This expression contains three redexes:
\begin{enumerate}[noitemsep]
\item The sub-expression 1 + 2, the \texttt{+} function applied with two arguments.
\item The sub-expression 2 + 3, the \texttt{+} function applied with two arguments.
\item The entire expression itself, which has the form of the function \texttt{mult} applied to a pair of arguments.
\end{enumerate}

Performing the corresponding reductions gives the expressions:
\begin{enumerate}[noitemsep]
\item \haskellinline{mult (3, 2 + 3)}
\item \haskellinline{mult (1 + 2, 5)}
\item \haskellinline{(1 + 2) * (2 + 3)}
\end{enumerate}

The order in which we evaluate these redexes determines what ``Pass-by'' type we use.

\subsection{Pass-by-Value}\label{subsec:Pass_by_Value}
Innermost evaluation, always chooses the innermost redex, meaning it contains no other redex.
If there is more than one innermost redex, by convention we choose that which begins at the leftmost position in the expression.

Innermost evaluation can also be characterised in terms of how arguments are passed to \nameref{def:Function}s.
In particular, using this strategy ensures that the argument of a function is always fully evaluated before the function itself is applied.
That is, arguments are \emph{Passed-By-Value}.


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
