\section{Types and Typeclasses}\label{sec:Types_Typeclasses}
\begin{definition}[Type]\label{def:Type}
  A \emph{type} is a collection of related values.
  For example, the \haskellinline{Bool} type contains 2 values, \haskellinline{True} and \haskellinline{False}.
  The definition of a type limits the types and amount of values that an expression of that type can take.
\end{definition}

In Haskell, to denote the \nameref{def:Type} of an expression, you use the \texttt{::} symbol.
Namely, \haskellinline{e :: T} meaning that the \nameref{def:Expression} \texttt{e} ``has type'' \texttt{T}, or \texttt{e} ``is of type'' \texttt{T}.

\begin{blackbox}
  {\large{\textbf{EVERY \nameref{def:Expression} MUST HAVE A \nameref{def:Type}!}}}
\end{blackbox}

To ensure that every \nameref{def:Expression} has a \nameref{def:Type} before execution, Haskell (like most other functional languages) uses \nameref{def:Type_Inferencing} to attempt to determine the type of every expression.

\begin{definition}[Type Inferencing]\label{def:Type_Inferencing}
  \emph{Type inferencing} is the process of solving the system of type equations introduced by expressions and operators/functions used on them to determine the \nameref{def:Type} of every \nameref{def:Expression} in a program.

  When an operator or function is used, it has a type signature.
  This indicates what \nameref{def:Type}s it takes in and what type(s) it returns.
  If there are operators/functions with pre-determined type signatures, like addition, then the types of the expressions that are fed into the addition operator need to be something that can be added.
  After the language system has gone through the whole file/program, a system of equations for the type of every expression can be created.
  By solving this system of equations, the \nameref{def:Type} of every expression can be determined.

  \begin{remark}[Done Statically]\label{rmk:Type_Inferencing_Static}
    It is important to note that \nameref{def:Type_Inferencing} is done \textbf{statically}, meaning it is done before the program is even executed.
    When compiled, the \nameref{def:Type}s are determined during compilation.
    When loaded into the REPL, the \nameref{def:Type}s are determined when the file is parsed and interpreted.
  \end{remark}

  \begin{remark}[Doesn't Catch Everything]
    \nameref{def:Type_Inferencing} does \textbf{NOT} catch all possible errors.
    Namely, it does not catch runtime errors, such as division-by-zero.
    However, it does remove a large category of errors that present themselves due to inappropriate typing.
  \end{remark}
\end{definition}

Because \nameref{def:Type_Inferencing} is done statically, Haskell programs are both \emph{strongly typed} and \emph{type safe}.
Meaning all \nameref{def:Type} errors that could occur in a program are found before program execution.
The use of \nameref{def:Type_Inferencing} is the reason that \textbf{all execution paths must have the same type}.

\begin{remark*}
  The determination of \nameref{def:Type}s in a program using \nameref{def:Type_Inferencing} where selection statements have different \nameref{def:Type}s is an undecidable problem.
  Thus, the language designers enforced programmers to write all \nameref{def:Conditional_Expression}, \nameref{def:Guarded_Equation}s and pattern matching paths to have the same \nameref{def:Type}.
\end{remark*}

\input{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Basic_Types}

\input{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/List_Types}

\input{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Tuple_Types}

\input{./EDAN40-Functional_Programming-Sections/Types_Typeclasses/Function_Types}

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../EDAN40-Functional_Programming-Reference_Sheet"
%%% End:
